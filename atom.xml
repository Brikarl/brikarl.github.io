<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>吸口好时光</title>
  
  <subtitle>读书观影写字</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-23T17:08:17.116Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Brikarl</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「剑指 Offer（第 2 版）」刷题记录</title>
    <link href="http://yoursite.com/2020/03/30/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87%20Offer/"/>
    <id>http://yoursite.com/2020/03/30/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87%20Offer/</id>
    <published>2020-03-30T10:55:13.000Z</published>
    <updated>2020-04-23T17:08:17.116Z</updated>
    
    <content type="html"><![CDATA[<p>本文是刷「剑指 Offer（第 2 版）」的个人记录，有每道题目的个人解法和思考过程，以及一些比较好的题解和分析过程，使用语言为 Python，主要原因是 Python 的语言非常简洁，初学者可以只关注其具体思考与实现的过程而非代码本身，而且 Python 的语法糖也会让整个代码变得异常简洁。未来会加 Java 代码（因为我Java 学的还是不太行）。</p><a id="more"></a><h2 id="面试题03-数组中重复的数字"><a href="#面试题03-数组中重复的数字" class="headerlink" title="面试题03. 数组中重复的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题03. 数组中重复的数字</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">[2, 3, 1, 0, 2, 5, 3]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">输出：2 或 3</span></pre></td></tr></table></figure><h3 id="个人思路"><a href="#个人思路" class="headerlink" title="个人思路"></a>个人思路</h3><p>第一个想到的是 Python 的<strong>集合</strong>，通过 <code>set()</code> 函数来去重，分别比较两个数组间的区别，输出<strong>差集</strong>。查了一下，输出差集的方式还是集合中的 <code>diffrence()</code> 函数，后来也没想到较好的解法，于是就换了另一个思路。</p><p>使用 <code>collections</code> 模块的 <code>Counter()</code> 函数，可以将数组变为键是数字，值为重复次数的字典。从而返回其中重复次数大于 1 的数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        dic = collections.Counter(nums)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> dic.keys():</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> dic[key] &gt; <span class="number">1</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> key</span></pre></td></tr></table></figure><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        dic = &#123;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> dic:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                dic[num] = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> num</span></pre></td></tr></table></figure><p>这个思路是创建字典，遍历数组，如果数字没有出现在字典里，则加入字典，如果出现在字典里，则产生重复，返回该数字。</p><h2 id="面试题04-二维数组中的查找"><a href="#面试题04-二维数组中的查找" class="headerlink" title="面试题04. 二维数组中的查找"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener">面试题04. 二维数组中的查找</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>示例:</strong></p><p>现有矩阵 matrix 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">[</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  [1,   4,  7, 11, 15],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  [2,   5,  8, 12, 19],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  [3,   6,  9, 16, 22],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  [10, 13, 14, 17, 24],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  [18, 21, 23, 26, 30]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">]</span></pre></td></tr></table></figure><p>给定 target = <code>5</code>，返回 <code>true</code>。</p><p>给定 target = <code>20</code>，返回 <code>false</code>。</p><h3 id="个人思路-1"><a href="#个人思路-1" class="headerlink" title="个人思路"></a>个人思路</h3><p>刚开始想到的肯定是暴力，这样也最简单粗暴，但是时间复杂度就不容乐观，是 O(nm) 的时间复杂度，结果也是如此。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberIn2DArray</span><span class="params">(self, matrix: List[List[int]], target: int)</span> -&gt; bool:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> raw <span class="keyword">in</span> range(len(matrix)):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> matrix[raw][col] == target:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span></pre></td></tr></table></figure><h3 id="官方题解-1"><a href="#官方题解-1" class="headerlink" title="官方题解"></a>官方题解</h3><p>由于矩阵是每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。因此可以从右上角元素开始查找，如果 target 比该数小，则向左查找；反之则向下查找，直到全部遍历完成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberIn2DArray</span><span class="params">(self, matrix: List[List[int]], target: int)</span> -&gt; bool:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> matrix == []:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># 从右上角开始遍历</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        i, j = <span class="number">0</span>, len(matrix[<span class="number">0</span>]) - <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> i &lt; len(matrix) <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="comment"># 目标比元素大，向下遍历</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> target &gt; matrix[i][j]:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                i += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            <span class="comment"># 目标比元素小，向左遍历</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">elif</span> target &lt; matrix[i][j]:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                j -= <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span></pre></td></tr></table></figure><h2 id="面试题05-替换空格"><a href="#面试题05-替换空格" class="headerlink" title="面试题05. 替换空格"></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener">面试题05. 替换空格</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;We are happy.&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：&quot;We%20are%20happy.&quot;</span></pre></td></tr></table></figure><h3 id="个人思路-2"><a href="#个人思路-2" class="headerlink" title="个人思路"></a>个人思路</h3><p>这个用 Python 的 <code>replace()</code> 简直不要太鸡贼。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s: str)</span> -&gt; str:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> s.replace(<span class="string">' '</span>, <span class="string">'%20'</span>)</span></pre></td></tr></table></figure><h3 id="官方题解-2"><a href="#官方题解-2" class="headerlink" title="官方题解"></a>官方题解</h3><p>无（面试不可能考这么简单的）</p><h2 id="面试题06-从尾到头打印链表"><a href="#面试题06-从尾到头打印链表" class="headerlink" title="面试题06. 从尾到头打印链表"></a><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">面试题06. 从尾到头打印链表</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 </p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,3,2]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：[2,3,1]</span></pre></td></tr></table></figure><h3 id="个人思路-3"><a href="#个人思路-3" class="headerlink" title="个人思路"></a>个人思路</h3><p>一开始用的反转链表的思路：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(head: Node)</span> -&gt; Optional[Node]:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    reversed_head = <span class="literal">None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    current = head</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span> current:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        reversed_head, reversed_head._next, current = current, reversed_head, current._next</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> reversed_head</span></pre></td></tr></table></figure><p>可惜没有通过，后来看题解用的是将元素压栈，然后返回逆序的数组。</p><h3 id="官方题解-3"><a href="#官方题解-3" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># class ListNode:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#    def __init__(self, x):</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#        self.val = x</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#        self.next = None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span><span class="params">(self, head: ListNode)</span> -&gt; List[int]:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        stack = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> head:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            stack.append(head.val)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            head = head.next</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> stack[::<span class="number">-1</span>]</span></pre></td></tr></table></figure><h2 id="面试题07-重建二叉树"><a href="#面试题07-重建二叉树" class="headerlink" title="面试题07. 重建二叉树"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题07. 重建二叉树</a></h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 </p><p>例如，给出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span></pre></td></tr></table></figure><p>返回如下的二叉树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">  3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"> &#x2F; \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">9  20</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &#x2F;  \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"> 15   7</span></pre></td></tr></table></figure><h3 id="个人思路-4"><a href="#个人思路-4" class="headerlink" title="个人思路"></a>个人思路</h3><p>由于前序遍历的遍历方式为<strong>根左右</strong>，中序遍历的方式为<strong>左根右</strong>，由此我们可以通过前序遍历的第一个元素找到<strong>根结点</strong>，再从中序遍历中分开<strong>左右子树</strong>，用<strong>分治</strong>思想<strong>递归</strong>地实现。</p><h3 id="官方题解-4"><a href="#官方题解-4" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder, inorder)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="string">"""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="string">        :type preorder: List[int]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="string">        :type inorder: List[int]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="string">        :rtype: TreeNode</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="string">        """</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> len(inorder) == <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># 前序遍历第一个值为根节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># 因为没有重复元素，所以可以直接根据值来查找根节点在中序遍历中的位置</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        mid = inorder.index(preorder[<span class="number">0</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># 构建左子树</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        root.left = self.buildTree(preorder[<span class="number">1</span>:mid+<span class="number">1</span>], inorder[:mid])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># 构建右子树</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        root.right = self.buildTree(preorder[mid+<span class="number">1</span>:], inorder[mid+<span class="number">1</span>:])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> root</span></pre></td></tr></table></figure><h2 id="面试题09-用两个栈实现队列"><a href="#面试题09-用两个栈实现队列" class="headerlink" title="面试题09. 用两个栈实现队列"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">面试题09. 用两个栈实现队列</a></h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 -1 )</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">[[],[3],[],[]]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">输出：[null,null,3,-1]</span></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">[[],[],[5],[2],[],[]]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">输出：[null,-1,null,null,5,2]</span></pre></td></tr></table></figure><h3 id="个人思路-5"><a href="#个人思路-5" class="headerlink" title="个人思路"></a>个人思路</h3><p>两个栈，一个用于存放元素，另一个用于实现删除头部的概念，将 a 栈的数据全部出栈压入到 b 栈中，然后将 b 中的元素出栈，即为队列头部。</p><h3 id="官方题解-5"><a href="#官方题解-5" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        self.a = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        self.b = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appendTail</span><span class="params">(self, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        self.a.append(value)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteHead</span><span class="params">(self)</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># 如果 b 中还有元素，则还需要出栈</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> self.b:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> self.b.pop()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># a 中没有元素，则队列中无元素</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.a:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># 执行出队操作</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> self.a:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            self.b.append(self.a.pop())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> self.b.pop()</span></pre></td></tr></table></figure><h2 id="面试题10-I-斐波那契数列"><a href="#面试题10-I-斐波那契数列" class="headerlink" title="面试题10- I. 斐波那契数列"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/" target="_blank" rel="noopener">面试题10- I. 斐波那契数列</a></h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">F(0) &#x3D; 0,   F(1) &#x3D; 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.</span></pre></td></tr></table></figure><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：1</span></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 5</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：5</span></pre></td></tr></table></figure><h3 id="个人思路-6"><a href="#个人思路-6" class="headerlink" title="个人思路"></a>个人思路</h3><p>这道题目是经典的递归求解问题，但是使用递归无疑会有很多重复的计算量，这是我们不希望的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n: int)</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">2</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> ((self.fib(n - <span class="number">1</span>) + self.fib(n <span class="number">-2</span>)) % <span class="number">1000000007</span>)</span></pre></td></tr></table></figure><p>最后会显示超时。</p><h3 id="官方题解-6"><a href="#官方题解-6" class="headerlink" title="官方题解"></a>官方题解</h3><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>几乎所有的问题都可以用迭代求解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, N: int)</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        f1, f2 = <span class="number">0</span>, <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            f1, f2 = f2, f1 + f2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> f1 % <span class="number">1000000007</span></span></pre></td></tr></table></figure><h4 id="使用备忘录递归"><a href="#使用备忘录递归" class="headerlink" title="使用备忘录递归"></a>使用备忘录递归</h4><p>正如我们之前所说，递归会用大量的时间去计算重复数据，这个时候我们可以采用<strong>备忘录</strong>的方式，记录已经计算过的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, N: int)</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        known_fib=&#123;<span class="number">0</span>:<span class="number">0</span>,<span class="number">1</span>:<span class="number">1</span>&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get_fib</span><span class="params">(N)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> N <span class="keyword">in</span> known_fib: </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> known_fib[N]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="comment"># 存储数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            known_fib[N] = get_fib( N<span class="number">-1</span> ) + get_fib( N<span class="number">-2</span> )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> known_fib[N]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> get_fib(N) % <span class="number">1000000007</span></span></pre></td></tr></table></figure><h2 id="面试题10-II-青蛙跳台阶问题"><a href="#面试题10-II-青蛙跳台阶问题" class="headerlink" title="面试题10- II. 青蛙跳台阶问题"></a><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/" target="_blank" rel="noopener">面试题10- II. 青蛙跳台阶问题</a></h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：2</span></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 7</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：21</span></pre></td></tr></table></figure><h3 id="个人思路-7"><a href="#个人思路-7" class="headerlink" title="个人思路"></a>个人思路</h3><p> 本质上，这依然是一个<strong>斐波那契数列</strong>：</p><ul><li>n = 1 或 n = 2 时，都各只有一种上台阶的方法：上一级或上两级；</li><li>当 n 大于 2 时，F(n) = F(n - 1) + F(n - 2)，即 F(n) 等于最后上一级的次数加上最后上两级的次数。</li></ul><h3 id="官方题解-7"><a href="#官方题解-7" class="headerlink" title="官方题解"></a>官方题解</h3><p>同上</p><h2 id="面试题11-旋转数组的最小数字"><a href="#面试题11-旋转数组的最小数字" class="headerlink" title="面试题11. 旋转数组的最小数字"></a><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">面试题11. 旋转数组的最小数字</a></h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一个旋转，该数组的最小值为1。  </p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：[3,4,5,1,2]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：1</span></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：[2,2,2,0,1]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：0</span></pre></td></tr></table></figure><h3 id="个人思路-8"><a href="#个人思路-8" class="headerlink" title="个人思路"></a>个人思路</h3><p>这个题目的思路是二分查找，由于是旋转数组，即部分有序，我们需要做的就是找出有序的部分，从而找到最小值：</p><ul><li><code>nums[mid] &gt; nums[high]</code>时，<code>nums[mid, high]</code>的部分是无序的，即为旋转的部分，则<code>min</code>在其中；</li><li><code>nums[mid] &lt; nums[low]</code>时，<code>nums[low, mid]</code>的部分是无序的，则最小值在其中；</li><li>当<code>nums[low] &lt;= nums[mid] &lt;= nums[high]</code> 时，则为有序，从中查找最小值（例外<code>[3, 3, 3, 1]</code>）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        low, high = <span class="number">0</span>, len(nums) - <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(nums, low, high)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> low &gt;= high:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> nums[low]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            mid = low + ((high- low) // <span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[high]:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> helper(nums, mid + <span class="number">1</span>, high)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; nums[low]:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> helper(nums, low - <span class="number">1</span>, mid)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> helper(nums, low, high - <span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> helper(nums, low, high)</span></pre></td></tr></table></figure><h3 id="官方题解-8"><a href="#官方题解-8" class="headerlink" title="官方题解"></a>官方题解</h3><p>除了用递归，还可以使用迭代的方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        low, high = <span class="number">0</span>, len(nums) - <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> low &lt; high:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            mid = low + ((high - low) // <span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[high]:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                low = mid + <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; nums[low]:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                high = mid</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                low += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                high -= <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> nums[low]</span></pre></td></tr></table></figure><h2 id="面试题12-矩阵中的路径"><a href="#面试题12-矩阵中的路径" class="headerlink" title="面试题12. 矩阵中的路径"></a><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/" target="_blank" rel="noopener">面试题12. 矩阵中的路径</a></h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p><p>[[“a”,”<strong>b</strong>“,”c”,”e”],<br>[“s”,”<strong>f</strong>“,”<strong>c</strong>“,”s”],<br>[“a”,”d”,”<strong>e</strong>“,”e”]]</p><p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：true</span></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word &#x3D; &quot;abcd&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：false</span></pre></td></tr></table></figure><h3 id="个人思路-9"><a href="#个人思路-9" class="headerlink" title="个人思路"></a>个人思路</h3><p>这道题目的思路有点儿像<a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">岛屿数量</a>，使用<strong>深度优先搜索遍历</strong>，回溯求解。从一个点出发，分别向下、向左、向右、向上遍历，如果该值与字符串的第一个值相同，则将该值更新，表示已经查询过该点，然后接着遍历其他点。</p><h3 id="官方题解-9"><a href="#官方题解-9" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board: List[List[str]], word: str)</span> -&gt; bool:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># 从每个点依次遍历</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> self.dfs(board, i, j, word):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, board, i, j, word)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> word: <span class="comment"># 此时已经全部查找完毕，返回 True</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= len(board) <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= len(board[<span class="number">0</span>]) <span class="keyword">or</span> word[<span class="number">0</span>] != board[i][j]: <span class="comment"># 越界或者该值不等于目标值，返回 False</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        tmp = board[i][j]  <span class="comment"># 找到目标值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        board[i][j] = <span class="string">"#"</span>  <span class="comment"># 更新数据 </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># 递归遍历其他位置</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        res = self.dfs(board, i+<span class="number">1</span>, j, word[<span class="number">1</span>:]) <span class="keyword">or</span> self.dfs(board, i<span class="number">-1</span>, j, word[<span class="number">1</span>:]) <span class="keyword">or</span> self.dfs(board, i, j+<span class="number">1</span>, word[<span class="number">1</span>:]) <span class="keyword">or</span> self.dfs(board, i, j<span class="number">-1</span>, word[<span class="number">1</span>:])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        board[i][j] = tmp <span class="comment"># 恢复以便下次遍历</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> res</span></pre></td></tr></table></figure><p>值得一提的是，第 13 行之前代码为<code>if len(word) == 0</code>，当改为<code>if not word</code>，速度整整提高了一倍。</p><h2 id="面试题13-机器人的运动范围"><a href="#面试题13-机器人的运动范围" class="headerlink" title="面试题13. 机器人的运动范围"></a><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener">面试题13. 机器人的运动范围</a></h2><h3 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h3><p>地上有一个m行n列的方格，从坐标<code>[0,0]</code>到坐标<code>[m-1,n-1]</code>。一个机器人从坐标<code>[0, 0]</code>的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于 k 的格子。例如，当 k 为 18 时，机器人能够进入方格<code>[35, 37]</code>，因为 3+5+3+7=18 。但它不能进入方格<code>[35, 38]</code>，因为 3+5+3+8=19 。请问该机器人能够到达多少个格子？ </p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：m &#x3D; 2, n &#x3D; 3, k &#x3D; 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：3</span></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：m &#x3D; 3, n &#x3D; 1, k &#x3D; 0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：1</span></pre></td></tr></table></figure><h3 id="个人思路-10"><a href="#个人思路-10" class="headerlink" title="个人思路"></a>个人思路</h3><p>思路如上</p><p><strong>深度优先搜索遍历：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, m: int, n: int, k: int)</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sumofDigit</span><span class="params">(x, y)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            result = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">while</span> x &gt; <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                result += x % <span class="number">10</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                x //= <span class="number">10</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">while</span> y &gt; <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                result += y % <span class="number">10</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                y //= <span class="number">10</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> result</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> i == m <span class="keyword">or</span> j == n <span class="keyword">or</span> sumofDigit(i, j) &gt; k <span class="keyword">or</span> (i, j) <span class="keyword">in</span> marked:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            marked.add((i, j))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            dfs(i + <span class="number">1</span>, j)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            dfs(i, j + <span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        marked = set()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> len(marked)</span></pre></td></tr></table></figure><p><strong>广度优先搜索遍历：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum_rc</span><span class="params">(self,row,col)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        tmp = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> row &gt; <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            tmp += row % <span class="number">10</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            row //= <span class="number">10</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> col &gt; <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            tmp += col % <span class="number">10</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            col //= <span class="number">10</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> tmp</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, m: int, n: int, k: int)</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        marked = set()  <span class="comment"># 将访问过的点添加到集合marked中,从(0,0)开始</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        queue = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        queue.append((<span class="number">0</span>,<span class="number">0</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> queue:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            x, y = queue.pop()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (x,y) <span class="keyword">not</span> <span class="keyword">in</span> marked <span class="keyword">and</span> self.sum_rc(x,y) &lt;= k:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">                marked.add((x,y)) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">for</span> dx, dy <span class="keyword">in</span> [(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">1</span>)]:  <span class="comment"># 仅考虑向右和向下即可</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">if</span> <span class="number">0</span> &lt;= x + dx &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= y + dy &lt; n:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">                        queue.append((x+dx,y+dy)) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> len(marked)</span></pre></td></tr></table></figure><h2 id="面试题14-剪绳子"><a href="#面试题14-剪绳子" class="headerlink" title="面试题14. 剪绳子"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" target="_blank" rel="noopener">面试题14. 剪绳子</a></h2><h3 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m]</code> 。请问 <code>k[0]*k[1]*...*k[m]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1</span></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: 10</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: 36</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36</span></pre></td></tr></table></figure><h3 id="个人思路-11"><a href="#个人思路-11" class="headerlink" title="个人思路"></a>个人思路</h3><p>第一眼看到这道题目是没什么思路的，但是猜可能用<strong>贪心</strong>来解决。</p><p>我们可以先枚举一下简单的几个例子：</p><div class="table-container"><table><thead><tr><th>n</th><th>拆分</th><th>乘积</th></tr></thead><tbody><tr><td>2</td><td>1 + 1</td><td>1</td></tr><tr><td>3</td><td>1 + 2</td><td>2</td></tr><tr><td>4</td><td>2 + 2</td><td>4</td></tr><tr><td>5</td><td>2 + 3</td><td>6</td></tr><tr><td>6</td><td>3 + 3</td><td>9</td></tr><tr><td>7</td><td>2 + 2 + 3</td><td>12</td></tr></tbody></table></div><p>可以看出在2、3 时是不拆分的，我们要做的就是尽可能将 n 拆分成更多的 3。当然在 4 拆分成 1 和 3 时，还是拆分成 2 和 2 乘积会更大些，因此需要考虑到这种特殊情况。</p><h3 id="官方题解-10"><a href="#官方题解-10" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span><span class="params">(self, n: int)</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">3</span>: <span class="comment"># 小于等于 3 不可分</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        num_3 = n // <span class="number">3</span> <span class="comment"># 3 的个数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        remainder = n % <span class="number">3</span> <span class="comment"># 余数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> remainder == <span class="number">1</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            remainder = <span class="number">4</span> <span class="comment"># 将 3 与 1 合并，2 * 2 &gt; 1 * 3</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            num_3 -= <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">elif</span> remainder == <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            remainder = <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> pow(<span class="number">3</span>, num_3) * remainder</span></pre></td></tr></table></figure><h2 id="面试题15-二进制中1的个数"><a href="#面试题15-二进制中1的个数" class="headerlink" title="面试题15. 二进制中1的个数"></a><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/" target="_blank" rel="noopener">面试题15. 二进制中1的个数</a></h2><h3 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：00000000000000000000000000001011</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</span></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：00000000000000000000000010000000</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</span></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：11111111111111111111111111111101</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：31</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</span></pre></td></tr></table></figure><h3 id="个人思路-12"><a href="#个人思路-12" class="headerlink" title="个人思路"></a>个人思路</h3><p>将利用<code>count()</code>直接计数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n: int)</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> bin(n).count(<span class="string">'1'</span>)</span></pre></td></tr></table></figure><h3 id="官方题解-11"><a href="#官方题解-11" class="headerlink" title="官方题解"></a>官方题解</h3><p>还有一种思路就是利用<strong>按位与 &amp;</strong> 的操作，从低到高消除 1 ，每消除一位计数器加一。</p><p>例如：<code>n = XXXXXX1000</code>,<code>n - 1 = XXXXXX0111</code>。<code>n &amp; (n - 1) =XXXXXX0000</code> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n: int)</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        count = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> n:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            n &amp;= (n <span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            count += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> count</span></pre></td></tr></table></figure><h2 id="面试题16-数值的整数次方"><a href="#面试题16-数值的整数次方" class="headerlink" title="面试题16. 数值的整数次方"></a><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">面试题16. 数值的整数次方</a></h2><h3 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h3><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: 2.00000, 10</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: 1024.00000</span></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: 2.10000, 3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: 9.26100</span></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: 2.00000, -2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: 0.25000</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">解释: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span></pre></td></tr></table></figure><h3 id="个人思路-13"><a href="#个人思路-13" class="headerlink" title="个人思路"></a>个人思路</h3><p>第一个想到的肯定是暴力法，但是这样会做很多重复的计算。</p><p>这个时候我们可以用<strong>分治</strong>的思想，因为 $x^n = (x^{\frac{n}{2}})^2$ ，所以我们只需要计算 $x^{\frac{n}{2}}$ 即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x, n)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="number">1</span> / self.myPow(x, -n)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> x * self.myPow(x, n<span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> self.myPow(x*x, n/<span class="number">2</span>)</span></pre></td></tr></table></figure><h3 id="官方题解-12"><a href="#官方题解-12" class="headerlink" title="官方题解"></a>官方题解</h3><p>当然，我们也可以使用迭代的方式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x, n)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            x = <span class="number">1</span> / x</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            n = -n</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        pow = <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> n:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span>: <span class="comment"># 等同于 n % 2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                pow *= x</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            x *= x</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            n &gt;&gt;= <span class="number">1</span> <span class="comment"># 等同于 n // 2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> pow</span></pre></td></tr></table></figure><h2 id="面试题17-打印从1到最大的n位数"><a href="#面试题17-打印从1到最大的n位数" class="headerlink" title="面试题17. 打印从1到最大的n位数"></a><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/" target="_blank" rel="noopener">面试题17. 打印从1到最大的n位数</a></h2><h3 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: [1,2,3,4,5,6,7,8,9]</span></pre></td></tr></table></figure><h3 id="个人思路-14"><a href="#个人思路-14" class="headerlink" title="个人思路"></a>个人思路</h3><p>这个有点儿简单，不再赘述，分享一个利用 Python 语法糖一行代码输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printNumbers</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> list(range(<span class="number">1</span>, <span class="number">10</span>**n))</span></pre></td></tr></table></figure><h2 id="面试题18-删除链表的节点"><a href="#面试题18-删除链表的节点" class="headerlink" title="面试题18. 删除链表的节点"></a><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/" target="_blank" rel="noopener">面试题18. 删除链表的节点</a></h2><h3 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><p><strong>注意：</strong>此题对比原题有改动</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 5</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: [4,1,9]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: [4,5,9]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span></pre></td></tr></table></figure><h3 id="个人思路-15"><a href="#个人思路-15" class="headerlink" title="个人思路"></a>个人思路</h3><p>这道题目也比较简单，这里也不再赘述：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># class ListNode:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#     def __init__(self, x):</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.val = x</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.next = None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, head: ListNode, val: int)</span> -&gt; ListNode:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> head.val == val:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> head.next</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        pre, cur = head, head.next</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> cur.val != val:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            pre, cur = cur, cur.next</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> cur:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            pre.next = cur.next</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> head</span></pre></td></tr></table></figure><h2 id="面试题19-正则表达式匹配"><a href="#面试题19-正则表达式匹配" class="headerlink" title="面试题19. 正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/" target="_blank" rel="noopener">面试题19. 正则表达式匹配</a></h2><h3 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数用来匹配包含<code>&#39;.&#39;</code>和<code>&#39;*&#39;</code>的正则表达式。模式中的字符<code>&#39;.&#39;</code>表示任意一个字符，而<code>&#39;*&#39;</code>表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串<code>&quot;aaa&quot;</code>与模式<code>&quot;a.a&quot;</code>和<code>&quot;ab*ac*a&quot;</code>匹配，但与<code>&quot;aa.a&quot;</code>和<code>&quot;ab*a&quot;</code>均不匹配。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">s &#x3D; &quot;aa&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">p &#x3D; &quot;a&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">输出: false</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">s &#x3D; &quot;aa&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">p &#x3D; &quot;a*&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">输出: true</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">解释: 因为 &#39;*&#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#39;a&#39;。因此，字符串 &quot;aa&quot; 可被视为 &#39;a&#39; 重复了一次。</span></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">s &#x3D; &quot;ab&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">p &#x3D; &quot;.*&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">输出: true</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。</span></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">s &#x3D; &quot;aab&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">p &#x3D; &quot;c*a*b&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">输出: true</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">解释: 因为 &#39;*&#39; 表示零个或多个，这里 &#39;c&#39; 为 0 个, &#39;a&#39; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">s &#x3D; &quot;mississippi&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">p &#x3D; &quot;mis*is*p*.&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">输出: false</span></pre></td></tr></table></figure><ul><li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li><li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 . 和 *。</li></ul><h3 id="个人思路-16"><a href="#个人思路-16" class="headerlink" title="个人思路"></a>个人思路</h3><p>知道可以用动态规划，但是仅限于此，直接上题解。</p><h3 id="官方题解-13"><a href="#官方题解-13" class="headerlink" title="官方题解"></a>官方题解</h3><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>首先我们先看，直接匹配两个字符串的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(text, pattern)</span> -&gt; bool:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pattern:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> text</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    first_match = bool(text) <span class="keyword">and</span> pattern[<span class="number">0</span>] == text[<span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> first_match <span class="keyword">and</span> isMatch(text[<span class="number">1</span>:], pattern[<span class="number">1</span>:])</span></pre></td></tr></table></figure><p>然后再看需要匹配通配符<code>&#39;.&#39;</code>的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(text, pattern)</span> -&gt; bool:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pattern:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> text</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"># 字符串不为空且表达式要么与字符串匹配，要么是'.'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    first_match = bool(text) <span class="keyword">and</span> pattern[<span class="number">0</span>] <span class="keyword">in</span> &#123;text[<span class="number">0</span>], <span class="string">'.'</span>&#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> first_match <span class="keyword">and</span> isMatch(text[<span class="number">1</span>:], pattern[<span class="number">1</span>:])</span></pre></td></tr></table></figure><p>最后我们来看匹配<code>&#39;*&#39;</code>的过程，有两种方式：一是第一个字符就不匹配，那么就跳过<code>&#39;*&#39;</code>去匹配剩下的字符；二是第一个字符与之匹配，那么就看剩下的字符是否是重复出现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(text, pattern)</span> -&gt; bool:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    memo = dict() <span class="comment"># 备忘录</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(i, j)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i, j) <span class="keyword">in</span> memo: <span class="keyword">return</span> memo[(i, j)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> j == len(pattern): <span class="keyword">return</span> i == len(text)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        first = i &lt; len(text) <span class="keyword">and</span> pattern[j] <span class="keyword">in</span> &#123;text[i], <span class="string">'.'</span>&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> j &lt;= len(pattern) - <span class="number">2</span> <span class="keyword">and</span> pattern[j + <span class="number">1</span>] == <span class="string">'*'</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            ans = dp(i, j + <span class="number">2</span>) <span class="keyword">or</span> first <span class="keyword">and</span> dp(i + <span class="number">1</span>, j)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            ans = first <span class="keyword">and</span> dp(i + <span class="number">1</span>, j + <span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        memo[(i, j)] = ans</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> ans</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> dp(<span class="number">0</span>, <span class="number">0</span>)</span></pre></td></tr></table></figure><h4 id="暴力递归法"><a href="#暴力递归法" class="headerlink" title="暴力递归法"></a>暴力递归法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(text, pattern)</span> -&gt; bool:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pattern:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> text</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    first = bool(text) <span class="keyword">and</span> pattern[<span class="number">0</span>] <span class="keyword">in</span> &#123;text[<span class="number">0</span>], <span class="string">'.'</span>&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> len(pattern) &gt;= <span class="number">2</span> <span class="keyword">and</span> pattern[<span class="number">1</span>] == <span class="string">'*'</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> isMatch(text, pattern[<span class="number">2</span>:]) <span class="keyword">or</span> first <span class="keyword">and</span> isMatch(text[<span class="number">1</span>:], pattern)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> first <span class="keyword">and</span> isMatch(text[<span class="number">1</span>:], pattern[<span class="number">1</span>:])</span></pre></td></tr></table></figure><h2 id="面试题20-表示数值的字符串"><a href="#面试题20-表示数值的字符串" class="headerlink" title="面试题20. 表示数值的字符串"></a><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/" target="_blank" rel="noopener">面试题20. 表示数值的字符串</a></h2><h3 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”0123”及”-1E-16”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。</p><h3 id="个人思路-17"><a href="#个人思路-17" class="headerlink" title="个人思路"></a>个人思路</h3><p>这道题目看起来很容易，但是其解法却很新奇。</p><h4 id="使用报错"><a href="#使用报错" class="headerlink" title="使用报错"></a>使用报错</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">try</span>: </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            float(s)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">except</span> ValueError: </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span>: </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span></pre></td></tr></table></figure><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    p = re.compile(<span class="string">r'^[+-]?(\.\d+|\d+\.?\d*)([eE][+-]?\d+)?$'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> bool(self.p.match(s.strip()))</span></pre></td></tr></table></figure><h4 id="DFA-deterministic-finite-automaton-确定性有限自动机"><a href="#DFA-deterministic-finite-automaton-确定性有限自动机" class="headerlink" title="DFA(deterministic finite automaton, 确定性有限自动机)"></a>DFA(deterministic finite automaton, 确定性有限自动机)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="string">"""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="string">        :type s: str</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="string">        :rtype: bool</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="string">        """</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">#define DFA state transition tables</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        states = [&#123;&#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                 <span class="comment"># State (1) - initial state (scan ahead thru blanks)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                 &#123;<span class="string">'blank'</span>: <span class="number">1</span>, <span class="string">'sign'</span>: <span class="number">2</span>, <span class="string">'digit'</span>:<span class="number">3</span>, <span class="string">'.'</span>:<span class="number">4</span>&#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                 <span class="comment"># State (2) - found sign (expect digit/dot)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                 &#123;<span class="string">'digit'</span>:<span class="number">3</span>, <span class="string">'.'</span>:<span class="number">4</span>&#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                 <span class="comment"># State (3) - digit consumer (loop until non-digit)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                 &#123;<span class="string">'digit'</span>:<span class="number">3</span>, <span class="string">'.'</span>:<span class="number">5</span>, <span class="string">'e'</span>:<span class="number">6</span>, <span class="string">'blank'</span>:<span class="number">9</span>&#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                 <span class="comment"># State (4) - found dot (only a digit is valid)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                 &#123;<span class="string">'digit'</span>:<span class="number">5</span>&#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                 <span class="comment"># State (5) - after dot (expect digits, e, or end of valid input)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                 &#123;<span class="string">'digit'</span>:<span class="number">5</span>, <span class="string">'e'</span>:<span class="number">6</span>, <span class="string">'blank'</span>:<span class="number">9</span>&#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">                 <span class="comment"># State (6) - found 'e' (only a sign or digit valid)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">                 &#123;<span class="string">'sign'</span>:<span class="number">7</span>, <span class="string">'digit'</span>:<span class="number">8</span>&#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">                 <span class="comment"># State (7) - sign after 'e' (only digit)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">                 &#123;<span class="string">'digit'</span>:<span class="number">8</span>&#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">                 <span class="comment"># State (8) - digit after 'e' (expect digits or end of valid input) </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">                 &#123;<span class="string">'digit'</span>:<span class="number">8</span>, <span class="string">'blank'</span>:<span class="number">9</span>&#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">                 <span class="comment"># State (9) - Terminal state (fail if non-blank found)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">                 &#123;<span class="string">'blank'</span>:<span class="number">9</span>&#125;]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        currentState = <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">            <span class="comment"># If char c is of a known class set it to the class name</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> <span class="string">'0123456789'</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">                c = <span class="string">'digit'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">' \t\n'</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">                c = <span class="string">'blank'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">'+-'</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">                c = <span class="string">'sign'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">            <span class="comment"># If char/class is not in our state transition table it is invalid input</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> states[currentState]:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">            <span class="comment"># State transition</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">            currentState = states[currentState][c]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># The only valid terminal states are end on digit, after dot, digit after e, or white space after valid input    </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> currentState <span class="keyword">not</span> <span class="keyword">in</span> [<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>]:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span></pre></td></tr></table></figure><h3 id="官方题解-14"><a href="#官方题解-14" class="headerlink" title="官方题解"></a>官方题解</h3><p>这里分享一个最暴力最简单易懂的方法，就是一个一个遍历，直到符合规定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        s = s.strip() <span class="comment"># 去掉空格</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        met_dot = met_e = met_digit = <span class="literal">False</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(s):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> char <span class="keyword">in</span> (<span class="string">'+'</span>, <span class="string">'-'</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                <span class="comment"># 符号不是位于开头或者符号前不是科学计数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> s[i<span class="number">-1</span>] != <span class="string">'e'</span> <span class="keyword">and</span> s[i<span class="number">-1</span>] != <span class="string">'E'</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">elif</span> char == <span class="string">'.'</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> met_dot <span class="keyword">or</span> met_e: <span class="comment"># 前面不能有小数点且不能有科学计数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                met_dot = <span class="literal">True</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">elif</span> char == <span class="string">'e'</span> <span class="keyword">or</span> char == <span class="string">'E'</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> met_e <span class="keyword">or</span> <span class="keyword">not</span> met_digit: <span class="comment"># 只能有一个科学计算且必须有数字</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                <span class="comment"># e 后必须接，所以这时重置 met_digit 为 False ,以免 e 为最后一个 char</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                met_e, met_digit = <span class="literal">True</span>, <span class="literal">False</span> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">elif</span> char.isdigit():</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">                met_digit = <span class="literal">True</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> met_digit</span></pre></td></tr></table></figure><h2 id="面试题21-调整数组顺序使奇数位于偶数前面"><a href="#面试题21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="面试题21. 调整数组顺序使奇数位于偶数前面"></a><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/" target="_blank" rel="noopener">面试题21. 调整数组顺序使奇数位于偶数前面</a></h2><h3 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a>题目详解</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：[1,3,2,4] </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">注：[3,1,2,4] 也是正确的答案之一。</span></pre></td></tr></table></figure><h3 id="个人思路-18"><a href="#个人思路-18" class="headerlink" title="个人思路"></a>个人思路</h3><p>这个题目第一个思路有点儿像<strong>快排</strong>，分别要用两个指针，一个快指针找到奇数，一个慢指针表示在其左边的都是奇数，从而交换两者位置。</p><p>第二个思路是前后两个指针，前面的指针查找偶数，后面的指针查找奇数，全部找到后交换两者的位置。</p><h3 id="官方题解-15"><a href="#官方题解-15" class="headerlink" title="官方题解"></a>官方题解</h3><h4 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        slow, fast = <span class="number">0</span>, <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> fast &lt; len(nums):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> nums[fast] &amp; <span class="number">1</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                nums[slow], nums[fast] = nums[fast], nums[slow]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                slow += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            fast += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> nums</span></pre></td></tr></table></figure><h4 id="前后指针"><a href="#前后指针" class="headerlink" title="前后指针"></a>前后指针</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        i, j = <span class="number">0</span>, len(nums) - <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> i &lt; j:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[i] &amp; <span class="number">1</span>: </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                i += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> <span class="keyword">not</span> nums[j] &amp; <span class="number">1</span>: </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                j -= <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> nums</span></pre></td></tr></table></figure><h2 id="面试题22-链表中倒数第k个节点"><a href="#面试题22-链表中倒数第k个节点" class="headerlink" title="面试题22. 链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">面试题22. 链表中倒数第k个节点</a></h2><h3 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">返回链表 4-&gt;5.</span></pre></td></tr></table></figure><h3 id="个人思路-19"><a href="#个人思路-19" class="headerlink" title="个人思路"></a>个人思路</h3><p>这个同样需要快慢指针来解决，先让快指针走 k 次，然后再让慢指针出发。当快指针走到尾端时，慢指针所处的位置就是倒数第 k 个节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># class ListNode:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#     def __init__(self, x):</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.val = x</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.next = None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getKthFromEnd</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        slow, fast = head, head</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k - <span class="number">1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            fast = fast.next</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> fast.next:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            slow, fast = slow.next, fast.next</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> slow</span></pre></td></tr></table></figure><h2 id="面试题24-反转链表"><a href="#面试题24-反转链表" class="headerlink" title="面试题24. 反转链表"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank" rel="noopener">面试题24. 反转链表</a></h2><h3 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h3><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p><strong>示例</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span></pre></td></tr></table></figure><h3 id="个人思路-20"><a href="#个人思路-20" class="headerlink" title="个人思路"></a>个人思路</h3><p>同样比较基础，不再赘述。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># class ListNode:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#     def __init__(self, x):</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.val = x</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.next = None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        cur, rever = head, <span class="literal">None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> cur:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            cur, rever, rever.next = cur.next, cur, rever</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> rever</span></pre></td></tr></table></figure><h2 id="面试题25-合并两个排序的链表"><a href="#面试题25-合并两个排序的链表" class="headerlink" title="面试题25. 合并两个排序的链表"></a><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/" target="_blank" rel="noopener">面试题25. 合并两个排序的链表</a></h2><h3 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p><strong>示例</strong>1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span></pre></td></tr></table></figure><h3 id="个人思路-21"><a href="#个人思路-21" class="headerlink" title="个人思路"></a>个人思路</h3><p>这个整体思路与<strong>归并排序</strong>的合并步骤类似，比较两者的大小，再用一个空链表链接，最后合并剩余的部分。</p><p>在这里新建了一个空链表，这点刚开始有些费解，只要记得这个空的链表是初始化的，其头节点为空，我们需要返回的是下一个节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># class ListNode:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#     def __init__(self, x):</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.val = x</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.next = None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        fake_head = cur = ListNode(<span class="literal">None</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                cur.next = l1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                l1 = l1.next</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                cur.next = l2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                l2 = l2.next</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            cur = cur.next</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        cur.next = l1 <span class="keyword">or</span> l2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> fake_head.next</span></pre></td></tr></table></figure><h2 id="面试题26-树的子结构"><a href="#面试题26-树的子结构" class="headerlink" title="面试题26. 树的子结构"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener">面试题26. 树的子结构</a></h2><h3 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>例如:</p><p>给定的树 A:</p><pre><code>     3    / \   4   5  / \ 1   2</code></pre><p>给定的树 B：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">  4 </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"> &#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">1</span></pre></td></tr></table></figure><p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：A &#x3D; [1,2,3], B &#x3D; [3,1]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：false</span></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：A &#x3D; [3,4,5,1,2], B &#x3D; [4,1]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：true</span></pre></td></tr></table></figure><h3 id="个人思路-22"><a href="#个人思路-22" class="headerlink" title="个人思路"></a>个人思路</h3><p>采用<strong>深度优先搜索遍历</strong>。</p><ul><li>先序遍历树 $A$ 中的每个节点 $n_A$ ；（对应函数 <code>isSubStructure(A, B)</code>）</li><li>判断树 $A$ 中 以 $n_A$ 为根节点的子树 是否包含树 $B$。（对应函数 <code>recur(A, B)</code>）</li></ul><h3 id="官方题解-16"><a href="#官方题解-16" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#     def __init__(self, x):</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.val = x</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.left = None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.right = None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubStructure</span><span class="params">(self, A: TreeNode, B: TreeNode)</span> -&gt; bool:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(A, B)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            <span class="comment"># B 为空，则表示全部符合</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> B: <span class="keyword">return</span> <span class="literal">True</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">or</span> A.val != B.val: <span class="keyword">return</span> <span class="literal">False</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            <span class="comment"># 左右子树是否包含</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> recur(A.left, B.left) <span class="keyword">and</span> recur(A.right, B.right)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># A、B 为空则返回，分别是三种情况：以节点 A 为根节点的子树包含树 B 树；B 是树 A 左子树的子结构；树 B 是树 A 右子树的子结构</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> bool(A <span class="keyword">and</span> B) <span class="keyword">and</span> (recur(A, B) <span class="keyword">or</span> self.isSubStructure(A.left, B) <span class="keyword">or</span> self.isSubStructure(A.right, B))</span></pre></td></tr></table></figure><h2 id="面试题27-二叉树的镜像"><a href="#面试题27-二叉树的镜像" class="headerlink" title="面试题27. 二叉树的镜像"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">面试题27. 二叉树的镜像</a></h2><h3 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h3><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p>例如输入：</p><pre><code>     4   /   \  2     7 / \   / \1   3 6   9</code></pre><p>镜像输出：</p><pre><code>      4   /   \  7     2 / \   / \9   6 3   1</code></pre><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [4,2,7,1,3,6,9]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：[4,7,2,9,6,3,1]</span></pre></td></tr></table></figure><h3 id="个人思路-23"><a href="#个人思路-23" class="headerlink" title="个人思路"></a>个人思路</h3><p>同样是使用递归的方式，当节点为空时返回，其左节点等于右节点的镜像树，右节点为左节点的镜像树。</p><h3 id="官方题解-17"><a href="#官方题解-17" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        root.left, root.right = self.mirrorTree(root.right), self.mirrorTree(root.left)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> root</span></pre></td></tr></table></figure><h2 id="面试题28-对称的二叉树"><a href="#面试题28-对称的二叉树" class="headerlink" title="面试题28. 对称的二叉树"></a><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题28. 对称的二叉树</a></h2><h3 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><pre><code>    1   / \  2   2 / \ / \3  4 4  3</code></pre><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><pre><code>    1   / \  2   2   \   \   3    3</code></pre><h3 id="个人思路-24"><a href="#个人思路-24" class="headerlink" title="个人思路"></a>个人思路</h3><p>判断是否为对称树的条件为，<code>l.left</code> 与 <code>r.right</code> ，<code>r.left</code> 与 <code>l.right</code> 是否相等。</p><h3 id="官方题解-18"><a href="#官方题解-18" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#     def __init__(self, x):</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.val = x</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.left = None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.right = None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(l, r)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> l <span class="keyword">and</span> <span class="keyword">not</span> r:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> l <span class="keyword">or</span> <span class="keyword">not</span> r <span class="keyword">or</span> l.val != r.val:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> helper(l.left, r.right) <span class="keyword">and</span> helper(r.left, l.right)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> root:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> helper(root.left, root.right)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span></pre></td></tr></table></figure><h2 id="面试题29-顺时针打印矩阵"><a href="#面试题29-顺时针打印矩阵" class="headerlink" title="面试题29. 顺时针打印矩阵"></a><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener">面试题29. 顺时针打印矩阵</a></h2><h3 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span></pre></td></tr></table></figure><h3 id="个人思路-25"><a href="#个人思路-25" class="headerlink" title="个人思路"></a>个人思路</h3><p>本题目的关键是确定好上下左右四个边界，然后循环打印：“从左向右、从上向下、从右向左、从下向上” 四个方向循环。最后如果 <code>l == r</code> 时，已经循环结束一圈，还有一行需要打印，则打印那一行；当 <code>t = d</code> 时，还有一列需要打印。</p><div class="table-container"><table><thead><tr><th>打印方向</th><th>根据边界打印</th><th>边界向内收缩</th></tr></thead><tbody><tr><td>从左向右</td><td>左边界<code>l</code> ，右边界<code>r</code></td><td>上边界<code>t += 1</code></td></tr><tr><td>从上向下</td><td>上边界<code>t</code> ，下边界<code>d</code></td><td>右边界<code>r -= 1</code></td></tr><tr><td>从右向左</td><td>右边界<code>r</code> ，左边界<code>l</code></td><td>下边界<code>d -= 1</code></td></tr><tr><td>从下向上</td><td>下边界<code>b</code> ，上边界<code>t</code></td><td>左边界<code>l += 1</code></td></tr></tbody></table></div><h3 id="官方题解-19"><a href="#官方题解-19" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        res = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        l, r, t, d = <span class="number">0</span>, len(matrix[<span class="number">0</span>]) - <span class="number">1</span>, <span class="number">0</span>, len(matrix) - <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> t &lt; d:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(l, r + <span class="number">1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                res += [matrix[i][j]]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            t += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(t, d + <span class="number">1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                res += [matrix[i][j]]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            r -= <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(r, l - <span class="number">1</span>, <span class="number">-1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                res += [matrix[i][j]]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            d -= <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(d, t - <span class="number">1</span>, <span class="number">-1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">                res += [matrix[i][j]]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">            l += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> l == r:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            res += [matrix[i][r] <span class="keyword">for</span> i <span class="keyword">in</span> range(t, d + <span class="number">1</span>)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">elif</span> t == d:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">            res += [matrix[t][j] <span class="keyword">for</span> j <span class="keyword">in</span> range(l, r + <span class="number">1</span>)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> res</span></pre></td></tr></table></figure><h2 id="面试题30-包含min函数的栈"><a href="#面试题30-包含min函数的栈" class="headerlink" title="面试题30. 包含min函数的栈"></a><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/" target="_blank" rel="noopener">面试题30. 包含min函数的栈</a></h2><h3 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">MinStack minStack &#x3D; new MinStack();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">minStack.push(-2);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">minStack.push(0);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">minStack.push(-3);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">minStack.min();   --&gt; 返回 -3.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">minStack.pop();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">minStack.top();      --&gt; 返回 0.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">minStack.min();   --&gt; 返回 -2.</span></pre></td></tr></table></figure><h3 id="个人思路-26"><a href="#个人思路-26" class="headerlink" title="个人思路"></a>个人思路</h3><p>使用辅助栈来记录最小值，同时当最小值弹出后，辅助栈的也要同时弹出。</p><h3 id="官方题解-20"><a href="#官方题解-20" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        self.A, self.B = [], []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        self.A.append(x)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.B <span class="keyword">or</span> self.B[<span class="number">-1</span>] &gt;= x:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            self.B.append(x)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> self.A.pop() == self.B[<span class="number">-1</span>]:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            self.B.pop()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> self.A[<span class="number">-1</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self)</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> self.B[<span class="number">-1</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># obj = MinStack()</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># obj.push(x)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># obj.pop()</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># param_3 = obj.top()</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># param_4 = obj.min()</span></span></pre></td></tr></table></figure><h2 id="面试题31-栈的压入、弹出序列"><a href="#面试题31-栈的压入、弹出序列" class="headerlink" title="面试题31. 栈的压入、弹出序列"></a><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">面试题31. 栈的压入、弹出序列</a></h2><h3 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：true</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">解释：我们可以按以下顺序执行：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,3,5,1,2]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：false</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">解释：1 不能在 2 之前弹出。</span></pre></td></tr></table></figure><h3 id="个人思路-27"><a href="#个人思路-27" class="headerlink" title="个人思路"></a>个人思路</h3><p>我们可以试着模拟一个压入、弹出的过程，每当我们压入一个元素时，要检查他是否等于对应弹出的元素。如果相等，则将其弹出。最后检查栈是否为空。</p><h3 id="官方题解-21"><a href="#官方题解-21" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validateStackSequences</span><span class="params">(self, pushed: List[int], popped: List[int])</span> -&gt; bool:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        stack = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        i = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> pushed:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            stack.append(x)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] == popped[i]:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                i += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                stack.pop()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span></pre></td></tr></table></figure><h2 id="面试题32-I-从上到下打印二叉树"><a href="#面试题32-I-从上到下打印二叉树" class="headerlink" title="面试题32 - I. 从上到下打印二叉树"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题32 - I. 从上到下打印二叉树</a></h2><h3 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h3><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><p>例如:</p><p>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><pre><code>    3   / \  9  20    /  \   15   7</code></pre><p>返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">[3,9,20,15,7]</span></pre></td></tr></table></figure><h3 id="个人思路-28"><a href="#个人思路-28" class="headerlink" title="个人思路"></a>个人思路</h3><p>中序遍历，值得注意的是要判断添加进队列的是否是空节点。</p><h3 id="官方题解-22"><a href="#官方题解-22" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#     def __init__(self, x):</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.val = x</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.left = None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.right = None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        res, queue = [], collections.deque()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        queue.append(root)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> queue:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            node = queue.popleft()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            res.append(node.val)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> node.left:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                queue.append(node.left)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> node.right:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">                queue.append(node.right)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> res</span></pre></td></tr></table></figure><h2 id="面试题32-II-从上到下打印二叉树-II"><a href="#面试题32-II-从上到下打印二叉树-II" class="headerlink" title="面试题32 - II. 从上到下打印二叉树 II"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank" rel="noopener">面试题32 - II. 从上到下打印二叉树 II</a></h2><h3 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h3><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><p>例如:</p><p>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><pre><code>    3   / \  9  20    /  \   15   7</code></pre><p>返回其层次遍历结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">[</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  [3],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  [9,20],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  [15,7]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">]</span></pre></td></tr></table></figure><h3 id="个人思路-29"><a href="#个人思路-29" class="headerlink" title="个人思路"></a>个人思路</h3><p>同样是中序遍历，只不过我们需要一个临时数组 <code>temp</code> ，来记录每层的节点。</p><h3 id="官方题解-23"><a href="#官方题解-23" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#     def __init__(self, x):</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.val = x</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.left = None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.right = None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        ans, level = [], [root]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> level:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            ans.append([node.val <span class="keyword">for</span> node <span class="keyword">in</span> level])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            temp = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> level:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                temp.extend([node.left, node.right])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            level = [leaf <span class="keyword">for</span> leaf <span class="keyword">in</span> temp <span class="keyword">if</span> leaf]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> ans</span></pre></td></tr></table></figure><h2 id="面试题32-III-从上到下打印二叉树-III"><a href="#面试题32-III-从上到下打印二叉树-III" class="headerlink" title="面试题32 - III. 从上到下打印二叉树 III"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener">面试题32 - III. 从上到下打印二叉树 III</a></h2><h3 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><p>例如:</p><p>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><pre><code>    3   / \  9  20    /  \   15   7</code></pre><p>返回其层次遍历结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">[</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  [3],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  [20,9],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  [15,7]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">]</span></pre></td></tr></table></figure><h3 id="个人思路-30"><a href="#个人思路-30" class="headerlink" title="个人思路"></a>个人思路</h3><p>思路同上，需要取一个变量 <code>i</code> 作为行数指示。偶数顺序输出，奇数逆序输出。</p><h3 id="官方题解-24"><a href="#官方题解-24" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#     def __init__(self, x):</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.val = x</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.left = None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.right = None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        res, level, i = [], [root], <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> level:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            queue = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            queue += [node.val <span class="keyword">for</span> node <span class="keyword">in</span> level]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> i &amp; <span class="number">1</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                res.append(queue[::<span class="number">-1</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">                res.append(queue)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">            i += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            temp = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> level:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">                temp += [node.left, node.right]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">            level = [leaf <span class="keyword">for</span> leaf <span class="keyword">in</span> temp <span class="keyword">if</span> leaf]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> res</span></pre></td></tr></table></figure><h2 id="面试题33-二叉搜索树的后序遍历序列"><a href="#面试题33-二叉搜索树的后序遍历序列" class="headerlink" title="面试题33. 二叉搜索树的后序遍历序列"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">面试题33. 二叉搜索树的后序遍历序列</a></h2><h3 id="题目描述-30"><a href="#题目描述-30" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p><p>参考以下这颗二叉搜索树：</p><pre><code>      5    / \   2   6  / \ 1   3</code></pre><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: [1,6,3,2,5]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: false</span></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: [1,3,2,6,5]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: true</span></pre></td></tr></table></figure><h3 id="个人思路-31"><a href="#个人思路-31" class="headerlink" title="个人思路"></a>个人思路</h3><p>总结一个规律：要求返回<strong>布尔值</strong>的算法题目，大概率都要求内联的<strong>回溯函数</strong>。</p><p>对于二叉树的问题，最关键就是要找到左右子树。对于后序遍历而言，其最后一个数为根节点，前半部分比根节点小的是左子树部分，后半部分比根节点大的为右子树部分。因此只需要依次递归左右子树判断是否符合后序遍历条件即可。</p><h3 id="官方题解-25"><a href="#官方题解-25" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span><span class="params">(self, postorder: List[int])</span> -&gt; bool:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(i, j)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> i &gt;= j:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            l = i</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">while</span> postorder[l] &lt; postorder[j]:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                l += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            m = l <span class="comment">#前半部分为左子树，后半部分为右子树</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">while</span> postorder[l] &gt; postorder[j]:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                l += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> l == j <span class="keyword">and</span> recur(i, m - <span class="number">1</span>) <span class="keyword">and</span> recur(m, j - <span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>, len(postorder) - <span class="number">1</span>)</span></pre></td></tr></table></figure><h2 id="面试题34-二叉树中和为某一值的路径"><a href="#面试题34-二叉树中和为某一值的路径" class="headerlink" title="面试题34. 二叉树中和为某一值的路径"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">面试题34. 二叉树中和为某一值的路径</a></h2><h3 id="题目描述-31"><a href="#题目描述-31" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p><p><strong>示例:</strong></p><p>给定如下二叉树，以及目标和 sum = 22，</p><pre><code>          5         / \        4   8       /   / \      11  13  4     /  \    / \    7    2  5   1</code></pre><p>返回:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">[</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   [5,4,11,2],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">   [5,8,4,5]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">]</span></pre></td></tr></table></figure><h3 id="个人思路-32"><a href="#个人思路-32" class="headerlink" title="个人思路"></a>个人思路</h3><p>使用<strong>先序遍历</strong>，采取<strong>根左右</strong>的遍历方式，同时记录当前的节点之和，若等于参数 sum ，则停止遍历；小于则继续遍历；反之则回溯到上一个节点，重新开始遍历。</p><h3 id="官方题解-26"><a href="#官方题解-26" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#     def __init__(self, x):</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.val = x</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.left = None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.right = None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; List[List[int]]:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        path, res = [], []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node, tar)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            path.append(node.val)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            tar -= node.val</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> <span class="keyword">not</span> tar:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                res.append(list(path))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            dfs(node.left, tar)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            dfs(node.right, tar)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">            path.pop() <span class="comment"># 弹出当前节点并回溯</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        dfs(root, sum)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> res</span></pre></td></tr></table></figure><p>在写的过程中遇到了些困扰，在查询资料的过程中有点收获，在这里分享一下：</p><ul><li>一开始图省事儿，第 17 行使用 <code>res += path</code> ，但是由于 <code>res</code> 没有作为参数传入，于是不可以进行赋值操作。</li><li>另外，第 17 行不可以使用 <code>res.append(path)</code> ，<code>append()</code> 传入的是<code>path</code>的对象，因此 <code>path</code> 在<strong>原地址空间</strong>进行的操作也会影响到 <code>res</code>。值得一提的是，<code>extend</code>却没有这样的问题，因为它返回的是在 C 层面的迭代数据。</li></ul><h2 id="面试题35-复杂链表的复制"><a href="#面试题35-复杂链表的复制" class="headerlink" title="面试题35. 复杂链表的复制"></a><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/" target="_blank" rel="noopener">面试题35. 复杂链表的复制</a></h2><h3 id="题目描述-32"><a href="#题目描述-32" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现 <code>copyRandomList</code> 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code>。</p><p><strong>示例 1：</strong></p><img src="/2020/03/30/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87%20Offer/1.png" class=""> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><img src="/2020/03/30/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87%20Offer/2.png" class=""> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [[1,1],[2,1]]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：[[1,1],[2,1]]</span></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><img src="/2020/03/30/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87%20Offer/3.png" class=""> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [[3,null],[3,0],[3,null]]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：[[3,null],[3,0],[3,null]]</span></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：[]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">解释：给定的链表为空（空指针），因此返回 null。</span></pre></td></tr></table></figure><h3 id="个人思路-33"><a href="#个人思路-33" class="headerlink" title="个人思路"></a>个人思路</h3><p>这个题目的重点是<strong>深拷贝</strong>，意味着指针所指的是一个有着新地址的链表，而非指向之前的对象。</p><p>所以，我们要新建一个<strong>哈希表</strong>，其键为旧节点，值为新节点。如果访问的节点已经在字典中，则直接返回，否则我们新建一个新节点，储存到哈希表中，其<code>next</code>和<code>random</code>指针可以通过递归来生成其新的节点。</p><h3 id="官方题解-27"><a href="#官方题解-27" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="string"># Definition for a Node.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="string">class Node:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="string">    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="string">        self.val = int(x)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="string">        self.next = next</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="string">        self.random = random</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        dic = &#123;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">copy</span><span class="params">(node)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> dic:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                new_node = dic[node]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">                new_node = Node(node.val)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">                dic[node] = new_node</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">                dic[node].next = copy(node.next)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">                dic[node].random = copy(node.random)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">                new_node = dic[node]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> new_node</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> copy(head)</span></pre></td></tr></table></figure><p>上一种方法清晰直观。接下来介绍一种方法是来自国际站的高票答案。使用<code>collections.defaultdict(lambda: Node(0))</code>来新建值，并且使用<code>dic[None] = None</code>以防止直到空节点无从下手。</p><p>值得一提的是，这个方法没有新建指针，而是利用哈希表自带的动态存储机制，来随时生成和更新节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="string"># Definition for a Node.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="string">class Node:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="string">    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="string">        self.val = int(x)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="string">        self.next = next</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="string">        self.random = random</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        dic = collections.defaultdict(<span class="keyword">lambda</span>: Node(<span class="number">0</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        curr = head</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        dic[<span class="literal">None</span>] = <span class="literal">None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> curr:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            dic[curr].val = curr.val</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            dic[curr].next = dic[curr.next]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            dic[curr].random = dic[curr.random]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            curr = curr.next</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> dic[head]</span></pre></td></tr></table></figure><h2 id="面试题36-二叉搜索树与双向链表"><a href="#面试题36-二叉搜索树与双向链表" class="headerlink" title="面试题36. 二叉搜索树与双向链表"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" target="_blank" rel="noopener">面试题36. 二叉搜索树与双向链表</a></h2><h3 id="题目描述-33"><a href="#题目描述-33" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p>为了让您更好地理解问题，以下面的二叉搜索树为例：</p><img src="/2020/03/30/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87%20Offer/4.png" class=""> <p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p><p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</p><img src="/2020/03/30/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87%20Offer/5.png" class=""> <p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p><h3 id="个人思路-34"><a href="#个人思路-34" class="headerlink" title="个人思路"></a>个人思路</h3><p>采用<strong>中序遍历</strong>的方式，依次遍历节点。同时构建双向链表<code>pre.right =cur</code> ，也应 <code>cur.left = pre</code> 。最后将尾结点与头结点也依次循环。</p><p>由于递归时，首个节点 <code>cur</code> 没有 <code>pre</code>，因此初始化一个伪头节点， <code>head</code> 和 <code>pre</code> 共同指向它；</p><h3 id="官方题解-28"><a href="#官方题解-28" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">treeToDoublyList</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        head = self.pre = Node(<span class="number">0</span>) <span class="comment"># pre 为全局变量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(cur)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            dfs(cur.left)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            cur.left = self.pre <span class="comment"># 改变节点的引用</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            self.pre.right = cur</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            self.pre = cur</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            dfs(cur.right)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        dfs(root)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        head = head.right</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        head.left, self.pre.right = self.pre, head</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> head</span></pre></td></tr></table></figure><h2 id="面试题37-序列化二叉树"><a href="#面试题37-序列化二叉树" class="headerlink" title="面试题37. 序列化二叉树"></a><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题37. 序列化二叉树</a></h2><h3 id="题目描述-34"><a href="#题目描述-34" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p>示例: </p><p>你可以将以下二叉树：</p><pre><code>    1   / \  2   3     / \    4   5序列化为 &quot;[1,2,3,null,null,4,5]&quot;</code></pre><h3 id="个人思路-35"><a href="#个人思路-35" class="headerlink" title="个人思路"></a>个人思路</h3><p>在序列化的过程中，我们把空节点看作<code>&quot;null&quot;</code>，然后采用广度优先搜索遍历。</p><p>反序列化的过程中，我们则从列表中找到数值，将其作为节点。</p><h3 id="官方题解-29"><a href="#官方题解-29" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># class TreeNode(object):</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#     def __init__(self, x):</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.val = x</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.left = None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.right = None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span><span class="params">(self, root)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="string">"""Encodes a tree to a single string.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="string">        </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="string">        :type root: TreeNode</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="string">        :rtype: str</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="string">        """</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        res, queue = [], collections.deque()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        queue.append(root)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> queue:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            node = queue.popleft()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> node: <span class="comment"># 广度优先遍历</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">                res.append(str(node.val))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">                queue.append(node.left)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">                queue.append(node.right)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span>: <span class="comment"># 空节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">                res.append(<span class="string">"null"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">'['</span> + <span class="string">','</span>.join(res) + <span class="string">']'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span><span class="params">(self, data)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        <span class="string">"""Decodes your encoded data to tree.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="string">        </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"><span class="string">        :type data: str</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"><span class="string">        :rtype: TreeNode</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"><span class="string">        """</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        nums, i = data[<span class="number">1</span>:<span class="number">-1</span>].split(<span class="string">','</span>), <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">        root = TreeNode(int(nums[<span class="number">0</span>]))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        queue = collections.deque()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">        queue.append(root)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> queue:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">            node = queue.popleft()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> nums[i] != <span class="string">"null"</span>: <span class="comment"># 左节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">                node.left = TreeNode(int(nums[i]))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">                queue.append(node.left)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">            i += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> nums[i] != <span class="string">"null"</span>: <span class="comment"># 右节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">                node.right = TreeNode(int(nums[i]))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">                queue.append(node.right)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">            i += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> root</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Your Codec object will be instantiated and called as such:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># codec = Codec()</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># codec.deserialize(codec.serialize(root))</span></span></pre></td></tr></table></figure><h2 id="面试题38-字符串的排列"><a href="#面试题38-字符串的排列" class="headerlink" title="面试题38. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">面试题38. 字符串的排列</a></h2><h3 id="题目描述-35"><a href="#题目描述-35" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abc&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span></pre></td></tr></table></figure><h3 id="个人思路-36"><a href="#个人思路-36" class="headerlink" title="个人思路"></a>个人思路</h3><p>这道题目先固定第一个位置的元素，然后通过递归确定其他位置的元素，通过交换元素来实现固定位置。</p><h3 id="官方题解-30"><a href="#官方题解-30" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        c, res = list(s), []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(x)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> x == len(s) - <span class="number">1</span>: <span class="comment"># 全部遍历完成</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                res.append(<span class="string">''</span>.join(c))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            dic = set() <span class="comment"># 剪枝</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(x, len(c)):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> c[i] <span class="keyword">in</span> dic:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">continue</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                dic.add(c[i])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                c[i], c[x] = c[x], c[i] <span class="comment"># 交换剩余元素</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                recur(x + <span class="number">1</span>) <span class="comment"># 回溯</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                c[i], c[x] = c[x], c[i] <span class="comment"># 恢复原样，以便下次遍历</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        recur(<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> res</span></pre></td></tr></table></figure><h2 id="面试题39-数组中出现次数超过一半的数字"><a href="#面试题39-数组中出现次数超过一半的数字" class="headerlink" title="面试题39. 数组中出现次数超过一半的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题39. 数组中出现次数超过一半的数字</a></h2><h3 id="题目描述-36"><a href="#题目描述-36" class="headerlink" title="题目描述"></a>题目描述</h3><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: 2</span></pre></td></tr></table></figure><h3 id="个人思路-37"><a href="#个人思路-37" class="headerlink" title="个人思路"></a>个人思路</h3><p>这个题目自己想的话就是使用哈希表的<code>Counter()</code>函数，对元素进行计数，找到个数大于一半的数字返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        dic = collections.Counter(nums)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        n = len(nums) // <span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> dic.keys():</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> dic[key] &gt; n:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> key</span></pre></td></tr></table></figure><h3 id="官方题解-31"><a href="#官方题解-31" class="headerlink" title="官方题解"></a>官方题解</h3><p>还有一种非常巧妙的思路是<strong>摩尔投票法</strong>，由于众数的个数超过数组长度的一半，因此遇到和众数一样的票数加一，反之则减一，最终的票数肯定是大于 0 的，那么最后的那个元素一定是众数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        key = <span class="number">0</span> <span class="comment"># 票数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> key: <span class="comment"># 票数为 0，先假设一个众数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                maj = num</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> num != maj: <span class="comment"># 不同减一，相同加一</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                key -= <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                key += <span class="number">1</span>                </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> maj</span></pre></td></tr></table></figure><h2 id="面试题40-最小的k个数"><a href="#面试题40-最小的k个数" class="headerlink" title="面试题40. 最小的k个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">面试题40. 最小的k个数</a></h2><h3 id="题目描述-37"><a href="#题目描述-37" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入整数数组 <code>arr</code> ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [3,2,1], k &#x3D; 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：[1,2] 或者 [2,1]</span></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [0,1,2,1], k &#x3D; 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：[0]</span></pre></td></tr></table></figure><h3 id="个人思路-38"><a href="#个人思路-38" class="headerlink" title="个人思路"></a>个人思路</h3><p>第一个思路是手动维护一个大顶头堆，存储前 k 个最小的元素，依次遍历后序数组，如果小于该大顶堆的堆顶元素，则弹出并压入该元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; List[int]:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> k:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        nums = [-x <span class="keyword">for</span> x <span class="keyword">in</span> arr[:k]] <span class="comment"># 小顶堆初始化</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        heapq.heapify(nums)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, len(arr)):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> -nums[<span class="number">0</span>] &gt; arr[i]:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                heapq.heappop(nums) <span class="comment"># 弹出堆顶元素</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                heapq.heappush(nums, -arr[i]) <span class="comment"># 压入新元素</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> [-x <span class="keyword">for</span> x <span class="keyword">in</span> nums]</span></pre></td></tr></table></figure><h3 id="官方题解-32"><a href="#官方题解-32" class="headerlink" title="官方题解"></a>官方题解</h3><p>还有一种是利用快排的思想，找到分界点 m，如果 <code>m - l + 1 = k</code> 时，意味着前面的为 k 个，即最小的 k 个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, arr, l, r)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        pivot, j = arr[l], l</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l + <span class="number">1</span>, r + <span class="number">1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> pivot &gt;= arr[i]:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                j += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                arr[i], arr[j] = arr[j], arr[i]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        arr[l], arr[j] = arr[j], arr[l]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> j</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(self, arr, l, r, k)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> l &lt; r:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            x = random.randint(l, r)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            arr[x], arr[l] = arr[l], arr[x]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            m = self.partition(arr, l, r)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            num = m - l + <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> num &gt; k:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                self.quickSort(arr, l, m - <span class="number">1</span>, k)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">elif</span> num &lt; k:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">                self.quickSort(arr, m + <span class="number">1</span>, r, k - num) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; List[int]:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> k:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        self.quickSort(arr, <span class="number">0</span>, len(arr) - <span class="number">1</span>, k)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> arr[:k]</span></pre></td></tr></table></figure><h2 id="面试题41-数据流中的中位数"><a href="#面试题41-数据流中的中位数" class="headerlink" title="面试题41. 数据流中的中位数"></a><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">面试题41. 数据流中的中位数</a></h2><h3 id="题目描述-38"><a href="#题目描述-38" class="headerlink" title="题目描述"></a>题目描述</h3><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><ul><li><code>void addNum(int num)</code> - 从数据流中添加一个整数到数据结构中。</li><li><code>double findMedian()</code> - 返回目前所有元素的中位数。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">[[],[1],[2],[],[3],[]]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">输出：[null,null,null,1.50000,null,2.00000]</span></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">[[],[2],[],[3],[]]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">输出：[null,null,2.00000,null,2.50000]</span></pre></td></tr></table></figure><h3 id="个人思路-39"><a href="#个人思路-39" class="headerlink" title="个人思路"></a>个人思路</h3><p>第一个思路就是暴力求解，直接使用排序算法，取中位数即可，但是会造成大量的时间消耗。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="string">"""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="string">        initialize your data structure here.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="string">        """</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        self.nums = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span><span class="params">(self, num: int)</span> -&gt; <span class="keyword">None</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        self.nums.append(num)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span><span class="params">(self)</span> -&gt; float:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        self.nums.sort()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> len(self.nums) &amp; <span class="number">1</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> self.nums[len(self.nums) // <span class="number">2</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> (self.nums[(len(self.nums)) // <span class="number">2</span>] + self.nums[(len(self.nums)) // <span class="number">2</span> - <span class="number">1</span>]) / <span class="number">2</span></span></pre></td></tr></table></figure><h3 id="官方题解-33"><a href="#官方题解-33" class="headerlink" title="官方题解"></a>官方题解</h3><p>由于我们只需要中位数即可，因此可以维护一个大顶堆和小顶堆，分别存放前一半数和后一半数。小顶堆存放的元素会多一个，在数组个数为奇数时，返回小顶堆堆顶元素；反之则返回两者堆顶元素的 $\frac{1}{2}$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="string">"""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="string">        initialize your data structure here.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="string">        """</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        self.max_heap = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        self.min_heap = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span><span class="params">(self, num: int)</span> -&gt; <span class="keyword">None</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> len(self.max_heap) == len(self.min_heap):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            heapq.heappush(self.min_heap, -heapq.heappushpop(self.max_heap, -num)) <span class="comment"># 压入最大堆，并将最大堆的堆顶元素压入最小堆，保持后者比前者多一个元素</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            heapq.heappush(self.max_heap, -heapq.heappushpop(self.min_heap, num)) <span class="comment"># 压入最小堆，并将最小堆堆顶元素压入最大堆，保持两者元素相同</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span><span class="params">(self)</span> -&gt; float:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> len(self.max_heap) == len(self.min_heap):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> (-self.max_heap[<span class="number">0</span>] + self.min_heap[<span class="number">0</span>]) / <span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> self.min_heap[<span class="number">0</span>]</span></pre></td></tr></table></figure><h2 id="面试题42-连续子数组的最大和"><a href="#面试题42-连续子数组的最大和" class="headerlink" title="面试题42. 连续子数组的最大和"></a><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">面试题42. 连续子数组的最大和</a></h2><h3 id="题目描述-39"><a href="#题目描述-39" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p><strong>示例1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: 6</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span></pre></td></tr></table></figure><h3 id="个人思路-40"><a href="#个人思路-40" class="headerlink" title="个人思路"></a>个人思路</h3><p>这个最好的解决方法是<strong>动态规划</strong>， 设动态规划列表<code>dp</code>，<code>dp[i]</code>代表以元素<code>nums[i]</code> 为结尾的连续子数组最大和。当 <code>dp[i−1] &gt; 0</code> 时：执行 <code>dp[i] = dp[i−1] + nums[i]</code>；当 <code>dp[i−1] ≤ 0</code> 时：执行<code>dp[i] = nums[i]</code>。</p><h3 id="官方题解-34"><a href="#官方题解-34" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            nums[i] += max(nums[i - <span class="number">1</span>], <span class="number">0</span>) <span class="comment">#在这里我们直接使用数组存储 dp 列表</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> max(nums)</span></pre></td></tr></table></figure><h2 id="面试题43-1～n整数中1出现的次数"><a href="#面试题43-1～n整数中1出现的次数" class="headerlink" title="面试题43. 1～n整数中1出现的次数"></a><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">面试题43. 1～n整数中1出现的次数</a></h2><h3 id="题目描述-40"><a href="#题目描述-40" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</p><p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 12</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：5</span></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 13</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：6</span></pre></td></tr></table></figure><h3 id="个人思路-41"><a href="#个人思路-41" class="headerlink" title="个人思路"></a>个人思路</h3><p>可以直接使用暴力法，将数字转化为字符串，依次检查其包含的<code>&#39;1&#39;</code>的个数，会超时。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countDigitOne</span><span class="params">(self, n: int)</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        i = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> str(num):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> <span class="string">'1'</span> == x:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                    i += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> i</span></pre></td></tr></table></figure><h3 id="官方题解-35"><a href="#官方题解-35" class="headerlink" title="官方题解"></a>官方题解</h3><p>看不太懂。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countDigitOne</span><span class="params">(self, n)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        ones, m = <span class="number">0</span>, <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> m &lt;= n:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            ones += (n // m + <span class="number">8</span>) // <span class="number">10</span> * m + (n // m % <span class="number">10</span> == <span class="number">1</span>) * (n % m + <span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            m *= <span class="number">10</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> ones</span></pre></td></tr></table></figure><h2 id="面试题44-数字序列中某一位的数字"><a href="#面试题44-数字序列中某一位的数字" class="headerlink" title="面试题44. 数字序列中某一位的数字"></a><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题44. 数字序列中某一位的数字</a></h2><h3 id="题目描述-41"><a href="#题目描述-41" class="headerlink" title="题目描述"></a>题目描述</h3><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p><p>请写一个函数，求任意第n位对应的数字。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：3</span></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 11</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：0</span></pre></td></tr></table></figure><h3 id="个人思路-42"><a href="#个人思路-42" class="headerlink" title="个人思路"></a>个人思路</h3><p>将字符序列分为 1 ~ 9、10 ~ 99、100 ~ 999 等几个区间，其中<code>digits</code>代表这个区间的位数为 1、2、3等，<code>first</code>代表这几个区间的起始数字为 1、10、100等。因此<code>9 * first * digits</code>为这几个区间的所有位数。n 在这个区间时，对于<code>str(first + n // digits)</code>则代表着对于 n 在哪个数字上，<code>[n % digits]</code>则代表在这个数字的第几位上。</p><h3 id="官方题解-36"><a href="#官方题解-36" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNthDigit</span><span class="params">(self, n: int)</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        n -= <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> digits <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            first = <span class="number">10</span> ** (digits - <span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> n &lt; <span class="number">9</span> * first * digits:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> int(str(first + n // digits)[n % digits])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            n -= <span class="number">9</span> * first * digits</span></pre></td></tr></table></figure><h2 id="面试题45-把数组排成最小的数"><a href="#面试题45-把数组排成最小的数" class="headerlink" title="面试题45. 把数组排成最小的数"></a><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/" target="_blank" rel="noopener">面试题45. 把数组排成最小的数</a></h2><h3 id="题目描述-42"><a href="#题目描述-42" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: [10,2]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: &quot;102&quot;</span></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: [3,30,34,5,9]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: &quot;3033459&quot;</span></pre></td></tr></table></figure><h3 id="个人思路-43"><a href="#个人思路-43" class="headerlink" title="个人思路"></a>个人思路</h3><p>可以看成是一个排序问题，在比较两个字符串 S1 和 S2 的大小时，应该比较的是 S1+S2 和 S2+S1 的大小，如果 S1 + S2 &lt; S2 + S1，那么应该把 S1 排在前面，否则应该把 S2 排在前面，确定两者相对位置。</p><h3 id="官方题解-37"><a href="#官方题解-37" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumber</span><span class="params">(self, nums: List[int])</span> -&gt; str:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        nums_s = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            nums_s.append(str(num))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums_s) - <span class="number">1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(nums_s)):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> nums_s[i] + nums_s[j] &gt; nums_s[j] + nums_s[i]:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                    nums_s[i], nums_s[j] = nums_s[j], nums_s[i]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(nums_s)</span></pre></td></tr></table></figure><h2 id="面试题46-把数字翻译成字符串"><a href="#面试题46-把数字翻译成字符串" class="headerlink" title="面试题46. 把数字翻译成字符串"></a><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/" target="_blank" rel="noopener">面试题46. 把数字翻译成字符串</a></h2><h3 id="题目描述-43"><a href="#题目描述-43" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: 12258</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: 5</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span></pre></td></tr></table></figure><h3 id="个人思路-44"><a href="#个人思路-44" class="headerlink" title="个人思路"></a>个人思路</h3><p>定义内联函数<code>recur()</code>，表示输入的字符串有多少种组合情况。当输入字符串为空或只有一个字符时，则返回 1，表示这种情况只有一种组合。当输入字符串前两个元素大于 25 或第一个字符等于 0 时，这意味着前两个元素无法组合，就需要固定第一个元素，来分析接下来的组合；反之，则会多一种前两个元素组合的可能性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">translateNum</span><span class="params">(self, num: int)</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(num_s)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> num_s <span class="keyword">or</span> len(num_s) == <span class="number">1</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> num_s[<span class="number">0</span>:<span class="number">2</span>] &gt; <span class="string">'25'</span> <span class="keyword">or</span> num_s[<span class="number">0</span>] == <span class="string">'0'</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> recur(num_s[<span class="number">1</span>:])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> recur(num_s[<span class="number">1</span>:]) + recur(num_s[<span class="number">2</span>:])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> recur(str(num))</span></pre></td></tr></table></figure><h3 id="官方题解-38"><a href="#官方题解-38" class="headerlink" title="官方题解"></a>官方题解</h3><p>除了使用递归，还可以使用动态规划，思路同上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">translateNum</span><span class="params">(self, num: int)</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        num_s = str(num)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(num_s) + <span class="number">1</span>)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(num_s) + <span class="number">1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> num_s[i<span class="number">-2</span>:i] &gt; <span class="string">'25'</span> <span class="keyword">or</span> num_s[i - <span class="number">2</span>] == <span class="string">'0'</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                dp[i] = dp[i - <span class="number">1</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + dp[i <span class="number">-2</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span></pre></td></tr></table></figure><h2 id="面试题47-礼物的最大价值"><a href="#面试题47-礼物的最大价值" class="headerlink" title="面试题47. 礼物的最大价值"></a><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/" target="_blank" rel="noopener">面试题47. 礼物的最大价值</a></h2><h3 id="题目描述-44"><a href="#题目描述-44" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">[</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  [1,3,1],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  [1,5,1],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  [4,2,1]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">输出: 12</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</span></pre></td></tr></table></figure><h3 id="个人思路-45"><a href="#个人思路-45" class="headerlink" title="个人思路"></a>个人思路</h3><p>动态规划，首先确定上边界<code>grid[0][j]</code>与左边界<code>grid[i][0]</code></p><h3 id="官方题解-39"><a href="#官方题解-39" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxValue</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> i <span class="keyword">and</span> <span class="keyword">not</span> j:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">continue</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">elif</span> <span class="keyword">not</span> i:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                    grid[i][j] += grid[i][j - <span class="number">1</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">elif</span> <span class="keyword">not</span> j:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                    grid[i][j] += grid[i - <span class="number">1</span>][j]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                    grid[i][j] += max(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> grid[<span class="number">-1</span>][<span class="number">-1</span>]</span></pre></td></tr></table></figure><h2 id="面试题48-最长不含重复字符的子字符串"><a href="#面试题48-最长不含重复字符的子字符串" class="headerlink" title="面试题48. 最长不含重复字符的子字符串"></a><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" target="_blank" rel="noopener">面试题48. 最长不含重复字符的子字符串</a></h2><h3 id="题目描述-45"><a href="#题目描述-45" class="headerlink" title="题目描述"></a>题目描述</h3><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: 3 </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: 3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span></pre></td></tr></table></figure><h3 id="个人思路-46"><a href="#个人思路-46" class="headerlink" title="个人思路"></a>个人思路</h3><p>使用<strong>滑动窗口</strong>的方法，窗口内的元素为符合的长度，<code>start</code>为窗口左边界，<code>i</code>为窗口右边界。如果<code>c</code>为重复元素，则它满足已保存在字典且位于窗口内；反之，则确定最大长度。</p><h3 id="官方题解-40"><a href="#官方题解-40" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        dic = &#123;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        start = max_s = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(s):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> dic <span class="keyword">and</span> dic[c] &gt;= start: <span class="comment"># 存在于字典且位于窗口内</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                start = dic[c] + <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                max_s = max(max_s, i - start + <span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            dic[c] = i <span class="comment"># 更新位置</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> max_s</span></pre></td></tr></table></figure><h2 id="面试题49-丑数"><a href="#面试题49-丑数" class="headerlink" title="面试题49. 丑数"></a><a href="https://leetcode-cn.com/problems/chou-shu-lcof/" target="_blank" rel="noopener">面试题49. 丑数</a></h2><h3 id="题目描述-46"><a href="#题目描述-46" class="headerlink" title="题目描述"></a>题目描述</h3><p>我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 10</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: 12</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span></pre></td></tr></table></figure><h3 id="个人思路-47"><a href="#个人思路-47" class="headerlink" title="个人思路"></a>个人思路</h3><p>使用动态规划，先设置三个指针<code>a, b, c</code>，<code>dp[a] * 2, dp[b] * 3, dc = dp[c] * 5</code>分别作为<code>dp[i]</code>即丑数的候选，需要找出其中最小的那一个，并且更新其指针位置。</p><h3 id="官方题解-41"><a href="#官方题解-41" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span><span class="params">(self, n: int)</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        dp = [<span class="number">1</span>] * n</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        a, b, c = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            da = dp[a] * <span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            db = dp[b] * <span class="number">3</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            dc = dp[c] * <span class="number">5</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            dp[i] = min(da, db, dc)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> dp[i] == da:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                a += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> dp[i] == db:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                b += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> dp[i] == dc:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                c += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span></pre></td></tr></table></figure><h2 id="面试题50-第一个只出现一次的字符"><a href="#面试题50-第一个只出现一次的字符" class="headerlink" title="面试题50. 第一个只出现一次的字符"></a><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/" target="_blank" rel="noopener">面试题50. 第一个只出现一次的字符</a></h2><h3 id="题目描述-47"><a href="#题目描述-47" class="headerlink" title="题目描述"></a>题目描述</h3><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">s &#x3D; &quot;abaccdeff&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">返回 &quot;b&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">s &#x3D; &quot;&quot; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">返回 &quot; &quot;</span></pre></td></tr></table></figure><h3 id="个人思路-48"><a href="#个人思路-48" class="headerlink" title="个人思路"></a>个人思路</h3><p>直接使用<code>collections</code>模块的<code>Counter()</code>即可。</p><h3 id="官方题解-42"><a href="#官方题解-42" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstUniqChar</span><span class="params">(self, s: str)</span> -&gt; str:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        dic = collections.Counter(s)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> i, k <span class="keyword">in</span> dic.items():</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> k == <span class="number">1</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> i</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">" "</span></span></pre></td></tr></table></figure><h2 id="面试题51-数组中的逆序对"><a href="#面试题51-数组中的逆序对" class="headerlink" title="面试题51. 数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">面试题51. 数组中的逆序对</a></h2><h3 id="题目描述-48"><a href="#题目描述-48" class="headerlink" title="题目描述"></a>题目描述</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: [7,5,6,4]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: 5</span></pre></td></tr></table></figure><h3 id="个人思路-49"><a href="#个人思路-49" class="headerlink" title="个人思路"></a>个人思路</h3><p>直接使用暴力法，依次遍历数组，会超时。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        n = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(nums) - <span class="number">1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(nums)):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                    n += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> n</span></pre></td></tr></table></figure><h3 id="官方题解-43"><a href="#官方题解-43" class="headerlink" title="官方题解"></a>官方题解</h3><p>使用<strong>归并排序</strong>，比较两边初始元素的大小，如果左边的元素大于右边，则意味着，左边所以元素都大于右边，则存在 <code>mid - i + 1</code> 个逆序数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        self.n = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(nums, low, high)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> low &lt; high:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                mid = (low + high) // <span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                merge_sort(nums, low, mid)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                merge_sort(nums, mid + <span class="number">1</span>, high)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                merge(nums, low, mid, high)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(nums, low, mid, high)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            i, j = low, mid + <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            tmp = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= high:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> nums[i] &lt;= nums[j]:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                    tmp.append(nums[i])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                    i += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">                    tmp.append(nums[j])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">                    j += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">                    self.n += mid - i + <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">            start = i <span class="keyword">if</span> i &lt;= mid <span class="keyword">else</span> j</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">            end = mid <span class="keyword">if</span> i &lt;= mid <span class="keyword">else</span> high</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">            tmp.extend(nums[start:end + <span class="number">1</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            nums[low:high + <span class="number">1</span>] = tmp</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        merge_sort(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> self.n</span></pre></td></tr></table></figure><h2 id="面试题52-两个链表的第一个公共节点"><a href="#面试题52-两个链表的第一个公共节点" class="headerlink" title="面试题52. 两个链表的第一个公共节点"></a><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/" target="_blank" rel="noopener">面试题52. 两个链表的第一个公共节点</a></h2><h3 id="题目描述-49"><a href="#题目描述-49" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个链表，找出它们的第一个公共节点。</p><p>如下面的两个链表：</p><img src="/2020/03/30/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87%20Offer/6.png" class=""> <p>在节点 c1 开始相交。</p><p><strong>示例 1：</strong></p><img src="/2020/03/30/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87%20Offer/7.png" class=""> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：Reference of the node with value &#x3D; 8</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><img src="/2020/03/30/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87%20Offer/8.png" class=""> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：Reference of the node with value &#x3D; 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><img src="/2020/03/30/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87%20Offer/9.png" class=""> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：null</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">解释：这两个链表不相交，因此返回 null。</span></pre></td></tr></table></figure><h3 id="个人思路-50"><a href="#个人思路-50" class="headerlink" title="个人思路"></a>个人思路</h3><p>采用双指针法，依次遍历各自链表，当其中一个链表到头时候，转移到另一个链表，直到两者相遇，返回该节点。</p><h3 id="官方题解-44"><a href="#官方题解-44" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># class ListNode:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#     def __init__(self, x):</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.val = x</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.next = None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA: ListNode, headB: ListNode)</span> -&gt; ListNode:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        ha, hb = headA, headB</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> ha != hb:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> ha:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                ha = ha.next</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                ha = headB</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> hb:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                hb =hb.next</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                hb = headA</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> ha</span></pre></td></tr></table></figure><h2 id="面试题53-I-在排序数组中查找数字-I"><a href="#面试题53-I-在排序数组中查找数字-I" class="headerlink" title="面试题53 - I. 在排序数组中查找数字 I"></a><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/" target="_blank" rel="noopener">面试题53 - I. 在排序数组中查找数字 I</a></h2><h3 id="题目描述-50"><a href="#题目描述-50" class="headerlink" title="题目描述"></a>题目描述</h3><p>统计一个数字在排序数组中出现的次数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: 2</span></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: 0</span></pre></td></tr></table></figure><h3 id="个人思路-51"><a href="#个人思路-51" class="headerlink" title="个人思路"></a>个人思路</h3><p>使用<code>collections</code>模块的<code>Counter()</code>函数。</p><h3 id="官方题解-45"><a href="#官方题解-45" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        dic = collections.Counter(nums)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> dic[target]</span></pre></td></tr></table></figure><h2 id="面试题53-II-0～n-1中缺失的数字"><a href="#面试题53-II-0～n-1中缺失的数字" class="headerlink" title="面试题53 - II. 0～n-1中缺失的数字"></a><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题53 - II. 0～n-1中缺失的数字</a></h2><h3 id="题目描述-51"><a href="#题目描述-51" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: [0,1,3]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: 2</span></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: [0,1,2,3,4,5,6,7,9]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: 8</span></pre></td></tr></table></figure><h3 id="个人思路-52"><a href="#个人思路-52" class="headerlink" title="个人思路"></a>个人思路</h3><p>使用暴力法求解，其下标要与值相同，否则返回下标。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> i != n:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> i</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span></span></pre></td></tr></table></figure><h3 id="官方题解-46"><a href="#官方题解-46" class="headerlink" title="官方题解"></a>官方题解</h3><p>使用二分查找，如果中间数字与下标相同，表明缺失的数字位于后半部分，反之位于左半部分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        l, r, = <span class="number">0</span>, len(nums) - <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> l &lt;= r:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            m = (l + r) // <span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> m == nums[m]:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                l = m + <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                r = m - <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> l</span></pre></td></tr></table></figure><h2 id="面试题54-二叉搜索树的第k大节点"><a href="#面试题54-二叉搜索树的第k大节点" class="headerlink" title="面试题54. 二叉搜索树的第k大节点"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/" target="_blank" rel="noopener">面试题54. 二叉搜索树的第k大节点</a></h2><h3 id="题目描述-52"><a href="#题目描述-52" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  &#x2F; \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"> 1   4</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">   2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">输出: 4</span></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">       5</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">      &#x2F; \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">     3   6</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#x2F; \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">   2   4</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  &#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"> 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">输出: 4</span></pre></td></tr></table></figure><h3 id="个人思路-53"><a href="#个人思路-53" class="headerlink" title="个人思路"></a>个人思路</h3><p>使用中序遍历，输出遍历后的数组，为递增数组，返回倒数第 K 个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span><span class="params">(self, root: TreeNode, k: int)</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        a = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span>  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            dfs(node.left)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            a.append(node.val)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            dfs(node.right)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        dfs(root)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> a[-k]</span></pre></td></tr></table></figure><h3 id="官方题解-47"><a href="#官方题解-47" class="headerlink" title="官方题解"></a>官方题解</h3><p>我们也可以使用特殊的中序遍历，按照<strong>右根左</strong>的顺序遍历，输出的为递减，这样就可以输出第 K 个元素了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span><span class="params">(self, root: TreeNode, k: int)</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        self.res, self.n = <span class="literal">None</span>, k</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            dfs(node.right)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            self.n -= <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.n:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                self.res = node.val</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> self.n &gt; <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                dfs(node.left)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        dfs(root)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> self.res</span></pre></td></tr></table></figure><p>值得一提的是，这里不可以使用传参的方式来设置计数器，因为每次传入的参数不会受外部函数的影响，因此需要设置为全局变量。</p><h2 id="面试题55-I-二叉树的深度"><a href="#面试题55-I-二叉树的深度" class="headerlink" title="面试题55 - I. 二叉树的深度"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/" target="_blank" rel="noopener">面试题55 - I. 二叉树的深度</a></h2><h3 id="题目描述-53"><a href="#题目描述-53" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p><p>例如：</p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><pre><code>    3   / \  9  20    /  \   15   7</code></pre><p>返回它的最大深度 3 。</p><h3 id="个人思路-54"><a href="#个人思路-54" class="headerlink" title="个人思路"></a>个人思路</h3><p>通过<strong>广度优先搜索遍历</strong>，每遍历一层，则计数器 +1+1 ，直到遍历完成，则可得到树的深度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#     def __init__(self, x):</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.val = x</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.left = None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.right = None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        queue, res = [root], <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> queue:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            tmp  = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> queue:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> node.left: tmp.append(node.left)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> node.right: tmp.append(node.right)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            queue = tmp</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            res += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> res</span></pre></td></tr></table></figure><h3 id="官方题解-48"><a href="#官方题解-48" class="headerlink" title="官方题解"></a>官方题解</h3><p>关键在于此树的深度和其左（右）子树的深度之间的关系。显然，<strong>此树的深度</strong> 等于 <strong>左子树的深度</strong> 与 <strong>右子树的深度</strong> 中的 <strong>最大值</strong> + 1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#     def __init__(self, x):</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.val = x</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.left = None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.right = None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> max(self.maxDepth(root.left), self.maxDepth(root.right)) + <span class="number">1</span></span></pre></td></tr></table></figure><h2 id="面试题55-II-平衡二叉树"><a href="#面试题55-II-平衡二叉树" class="headerlink" title="面试题55 - II. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题55 - II. 平衡二叉树</a></h2><h3 id="题目描述-54"><a href="#题目描述-54" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p><p><strong>示例 1:</strong></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p><pre><code>    3   / \  9  20    /  \   15   7</code></pre><p>返回 <code>true</code> 。</p><p><strong>示例 2:</strong></p><p>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p><pre><code>       1      / \     2   2    / \   3   3  / \ 4   4</code></pre><p>返回 <code>false</code> 。</p><h3 id="个人思路-55"><a href="#个人思路-55" class="headerlink" title="个人思路"></a>个人思路</h3><p>所有子树都需要满足平衡树性质，因此以下三者使用与<strong>逻辑与</strong>连接：</p><ul><li><code>abs(self.depth(root.left) - self.depth(root.right)) &lt;= 1</code> ：判断<strong>当前子树</strong>是否是平衡树；</li><li><code>self.isBalanced(root.left)</code> ： 判断当前子树的<strong>左子树</strong>是否是平衡树；</li><li><code>self.isBalanced(root.right)</code> ： 判断当前子树的<strong>右子树</strong>是否是平衡树；</li></ul><h3 id="官方题解-49"><a href="#官方题解-49" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#     def __init__(self, x):</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.val = x</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.left = None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#         self.right = None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> max(dfs(node.left), dfs(node.right)) + <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> abs(dfs(root.left) - dfs(root.right)) &lt;= <span class="number">1</span> <span class="keyword">and</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right)</span></pre></td></tr></table></figure><h2 id="面试题56-I-数组中数字出现的次数"><a href="#面试题56-I-数组中数字出现的次数" class="headerlink" title="面试题56 - I. 数组中数字出现的次数"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">面试题56 - I. 数组中数字出现的次数</a></h2><h3 id="题目描述-55"><a href="#题目描述-55" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [4,1,4,6]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：[1,6] 或 [6,1]</span></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,10,4,1,4,3,3]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：[2,10] 或 [10,2]</span></pre></td></tr></table></figure><h3 id="个人思路-56"><a href="#个人思路-56" class="headerlink" title="个人思路"></a>个人思路</h3><p>同上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumbers</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        dic = collections.Counter(nums)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        res = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> i, k <span class="keyword">in</span> dic.items():</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> k == <span class="number">1</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                res.append(i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> res</span></pre></td></tr></table></figure><h3 id="官方题解-50"><a href="#官方题解-50" class="headerlink" title="官方题解"></a>官方题解</h3><p>使用位运算。任何数和自己<strong>异或</strong>都为零，零与任何数异或都为自己。</p><p>由于为两个数，则 <code>res</code> 为两数的异或值。两数之间必有一位是不相等的，通过这个，将两数分组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumbers</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        res = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            res ^= num</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        tmp = <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> tmp &amp; res:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            tmp &lt;&lt;= <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        a, b = <span class="number">0</span>, <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> num &amp; tmp:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                a ^= num</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                b ^= num</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> [a, b]</span></pre></td></tr></table></figure><h2 id="面试题56-II-数组中数字出现的次数-II"><a href="#面试题56-II-数组中数字出现的次数-II" class="headerlink" title="面试题56 - II. 数组中数字出现的次数 II"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/" target="_blank" rel="noopener">面试题56 - II. 数组中数字出现的次数 II</a></h2><h3 id="题目描述-56"><a href="#题目描述-56" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [3,4,3,3]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：4</span></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [9,1,7,9,7,9,7]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：1</span></pre></td></tr></table></figure><h3 id="个人思路-57"><a href="#个人思路-57" class="headerlink" title="个人思路"></a>个人思路</h3><p>同上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        dic = collections.Counter(nums)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> i, k <span class="keyword">in</span> dic.items():</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> k == <span class="number">1</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> i</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span></pre></td></tr></table></figure><h3 id="官方题解-51"><a href="#官方题解-51" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        res = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            cnt = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            idx = <span class="number">1</span>&lt;&lt;i</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> num &amp;idx != <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                    cnt = cnt+<span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> cnt%<span class="number">3</span>==<span class="number">1</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                res = res|idx</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span>(res)</span></pre></td></tr></table></figure><h2 id="面试题57-和为s的两个数字"><a href="#面试题57-和为s的两个数字" class="headerlink" title="面试题57. 和为s的两个数字"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/" target="_blank" rel="noopener">面试题57. 和为s的两个数字</a></h2><h3 id="题目描述-57"><a href="#题目描述-57" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：[2,7] 或者 [7,2]</span></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [10,26,30,31,47,60], target &#x3D; 40</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：[10,30] 或者 [30,10]</span></pre></td></tr></table></figure><h3 id="个人思路-58"><a href="#个人思路-58" class="headerlink" title="个人思路"></a>个人思路</h3><p>使用哈希表记录数组，依次遍历数组，查看 <code>target - num</code> 是否在哈希表中且不在其相同的位置，会超时。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            div = target - num</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> div <span class="keyword">in</span> nums <span class="keyword">and</span> nums.index(div) != i:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> [div, num]</span></pre></td></tr></table></figure><h3 id="官方题解-52"><a href="#官方题解-52" class="headerlink" title="官方题解"></a>官方题解</h3><p>使用双指针，由于是递增排序的数组，因此可以不断缩短区间找到合适的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        i, j = <span class="number">0</span>, len(nums) - <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> i &lt; j:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> nums[i] + nums[j] &lt; target:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                i += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">elif</span> nums[i] + nums[j] &gt; target:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                j -= <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> [nums[i], nums[j]]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> []</span></pre></td></tr></table></figure><h2 id="面试题57-II-和为s的连续正数序列"><a href="#面试题57-II-和为s的连续正数序列" class="headerlink" title="面试题57 - II. 和为s的连续正数序列"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/" target="_blank" rel="noopener">面试题57 - II. 和为s的连续正数序列</a></h2><h3 id="题目描述-58"><a href="#题目描述-58" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个正整数 <code>target</code> ，输出所有和为 <code>target</code> 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：target &#x3D; 9</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：[[2,3,4],[4,5]]</span></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入：target &#x3D; 15</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出：[[1,2,3,4,5],[4,5,6],[7,8]]</span></pre></td></tr></table></figure><h3 id="个人思路-59"><a href="#个人思路-59" class="headerlink" title="个人思路"></a>个人思路</h3><p>使用<strong>滑动窗口</strong>，<code>i</code> 和<code>j</code> 分别为左边界和右边界，当滑动窗口内的和小于 <code>target</code> 时，右边界右移，反之左边界左移，直到找到目标值。将左边界右移，进行下一次查找。</p><h3 id="官方题解-53"><a href="#官方题解-53" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContinuousSequence</span><span class="params">(self, target: int)</span> -&gt; List[List[int]]:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        i, j = <span class="number">1</span>, <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        sum_num = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        res = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> i &lt;= target // <span class="number">2</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> sum_num &lt; target: <span class="comment"># 右边界</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                sum_num += j</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                j += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">elif</span> sum_num &gt; target: <span class="comment"># 左边界</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                sum_num -= i</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                i += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span>: <span class="comment"># 下次遍历</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                res.append(list(range(i, j)))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                sum_num -= i</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                i += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> res</span></pre></td></tr></table></figure><h2 id="面试题58-I-翻转单词顺序"><a href="#面试题58-I-翻转单词顺序" class="headerlink" title="面试题58 - I. 翻转单词顺序"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/" target="_blank" rel="noopener">面试题58 - I. 翻转单词顺序</a></h2><h3 id="题目描述-59"><a href="#题目描述-59" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: &quot;the sky is blue&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: &quot;blue is sky the&quot;</span></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: &quot;  hello world!  &quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: &quot;world! hello&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: &quot;a good   example&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: &quot;example good a&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span></pre></td></tr></table></figure><h3 id="个人思路-60"><a href="#个人思路-60" class="headerlink" title="个人思路"></a>个人思路</h3><p>使用库函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span><span class="params">(self, s: str)</span> -&gt; str:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        strs = s.split()        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>.join(strs[::<span class="number">-1</span>])</span></pre></td></tr></table></figure><h3 id="官方题解-54"><a href="#官方题解-54" class="headerlink" title="官方题解"></a>官方题解</h3><p>使用双指针，<code>i</code> 为单词左边界，<code>j</code> 为单词右边界，<code>i</code> 不断扫描单词直到遇到空格，跳过空格后更新 <code>j</code> 的值，重复上述步骤。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span><span class="params">(self, s: str)</span> -&gt; str:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        s = s.strip()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        i = j = len(s) - <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        res = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> s[i] != <span class="string">' '</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                i -= <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            res.append(s[i + <span class="number">1</span>:j + <span class="number">1</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">while</span> s[i] == <span class="string">' '</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                i -= <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            j = i</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>.join(res)</span></pre></td></tr></table></figure><h2 id="面试题58-II-左旋转字符串"><a href="#面试题58-II-左旋转字符串" class="headerlink" title="面试题58 - II. 左旋转字符串"></a><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/" target="_blank" rel="noopener">面试题58 - II. 左旋转字符串</a></h2><h3 id="题目描述-60"><a href="#题目描述-60" class="headerlink" title="题目描述"></a>题目描述</h3><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: &quot;cdefgab&quot;</span></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;lrloseumgh&quot;, k &#x3D; 6</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: &quot;umghlrlose&quot;</span></pre></td></tr></table></figure><h3 id="个人思路-61"><a href="#个人思路-61" class="headerlink" title="个人思路"></a>个人思路</h3><p>使用切片。</p><h3 id="官方题解-55"><a href="#官方题解-55" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseLeftWords</span><span class="params">(self, s: str, n: int)</span> -&gt; str:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join([s[n:], s[:n]])</span></pre></td></tr></table></figure><h2 id="面试题59-I-滑动窗口的最大值"><a href="#面试题59-I-滑动窗口的最大值" class="headerlink" title="面试题59 - I. 滑动窗口的最大值"></a><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">面试题59 - I. 滑动窗口的最大值</a></h2><h3 id="题目描述-61"><a href="#题目描述-61" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: [3,3,5,5,6,7] </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">解释: </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  滑动窗口的位置                最大值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">---------------               -----</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">[1  3  -1] -3  5  3  6  7       3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span></pre></td></tr></table></figure><h3 id="个人思路-62"><a href="#个人思路-62" class="headerlink" title="个人思路"></a>个人思路</h3><p>暴力法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> <span class="keyword">not</span> k:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        res = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        i = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> k &lt;= len(nums):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            res.append(max(nums[i:k]))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            i += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            k += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> res</span></pre></td></tr></table></figure><h3 id="官方题解-56"><a href="#官方题解-56" class="headerlink" title="官方题解"></a>官方题解</h3><p>使用双端队列，最左边为当前窗口的最大值下标。当 <code>deque[0] &lt;= i - k</code> 时，则下标超出左边界剔除。当加入的元素大于最后一个元素时，将最后一个元素弹出，并将该元素压入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        deque = collections.deque()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        res = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">while</span> deque <span class="keyword">and</span> deque[<span class="number">0</span>] &lt;= i - k: <span class="comment"># 越界</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                deque.popleft()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">while</span> deque <span class="keyword">and</span> num &gt; nums[deque[<span class="number">-1</span>]]: <span class="comment"># 弹出较小值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                deque.pop()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            deque.append(i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> i &gt;= k - <span class="number">1</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                res.append(nums[deque[<span class="number">0</span>]])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> res</span></pre></td></tr></table></figure><h2 id="面试题59-II-队列的最大值"><a href="#面试题59-II-队列的最大值" class="headerlink" title="面试题59 - II. 队列的最大值"></a><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">面试题59 - II. 队列的最大值</a></h2><h3 id="题目描述-62"><a href="#题目描述-62" class="headerlink" title="题目描述"></a>题目描述</h3><p>请定义一个队列并实现函数 <code>max_value</code> 得到队列里的最大值，要求函数<code>max_value</code>、<code>push_back</code> 和 <code>pop_front</code> 的<strong>均摊</strong>时间复杂度都是O(1)。</p><p>若队列为空，<code>pop_front</code> 和 <code>max_value</code> 需要返回 -1</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">[&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">[[],[1],[2],[],[],[]]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">输出: [null,null,null,2,1,2]</span></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">[&quot;MaxQueue&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">[[],[],[]]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">输出: [null,-1,-1]</span></pre></td></tr></table></figure><h3 id="个人思路-63"><a href="#个人思路-63" class="headerlink" title="个人思路"></a>个人思路</h3><p>使用两个双端队列，一个记录原本的数据，另一个记录最大值。</p><h3 id="官方题解-57"><a href="#官方题解-57" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        self.deque = collections.deque()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        self.max_deque = collections.deque()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">max_value</span><span class="params">(self)</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.max_deque:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> self.max_deque[<span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push_back</span><span class="params">(self, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        self.deque.append(value)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> self.max_deque <span class="keyword">and</span> value &gt; self.max_deque[<span class="number">-1</span>]:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            self.max_deque.pop()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        self.max_deque.append(value)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop_front</span><span class="params">(self)</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.deque:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        res = self.deque.popleft()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> res == self.max_deque[<span class="number">0</span>]:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">            self.max_deque.popleft()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> res</span></pre></td></tr></table></figure><h2 id="面试题60-n个骰子的点数"><a href="#面试题60-n个骰子的点数" class="headerlink" title="面试题60. n个骰子的点数"></a><a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/" target="_blank" rel="noopener">面试题60. n个骰子的点数</a></h2><h3 id="题目描述-63"><a href="#题目描述-63" class="headerlink" title="题目描述"></a>题目描述</h3><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p><p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]</span></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]</span></pre></td></tr></table></figure><h3 id="个人思路-64"><a href="#个人思路-64" class="headerlink" title="个人思路"></a>个人思路</h3><p>使用<strong>动态规划</strong>，最关键的是要找到状态方程。</p><p>题目需要我们求出所有点数出现的概率，根据概率的计算公式，点数 kk 出现概率就算公式为：</p><script type="math/tex; mode=display">P_{(k)} = k{出现的次数} / 总次数</script><p>由于是六面骰，因此总次数为 $6^n$</p><p>通过题目我们知道一共投掷 n 枚骰子，那最后一个阶段很显然就是：当<strong>投掷完 n 枚骰子后，各个点数出现的次数。</strong></p><ul><li>首先用数组的第一维来表示阶段，也就是投掷完了几枚骰子。</li><li>然后用第二维来表示投掷完这些骰子后，可能出现的点数。</li><li>数组的值就表示，该阶段各个点数出现的次数。</li></ul><p>所以状态表示就是这样的：<code>dp[i][j]</code> ，表示投掷完 i 枚骰子后，点数 j 的出现次数。</p><p>单单看第 n 枚骰子，它的点数可能为$1、2、3 … 6$，因此投掷完 n 枚骰子后点数 j 出现的次数，可以由投掷完 n-1 枚骰子后，对应点数 $j-1, j-2, j-3, … , j-6$ 出现的次数之和转化过来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">7</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">        dp[i][j] += dp[i - <span class="number">1</span>][j - m]</span></pre></td></tr></table></figure><p>对于边界状态，我们知道第一阶段的状态：投掷完 1 枚骰子后，它的可能点数分别为 $1, 2, 3, … , 6$ ，并且每个点数出现的次数都是 1 .</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">7</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    dp[<span class="number">1</span>][j] = <span class="number">1</span></span></pre></td></tr></table></figure><h3 id="官方题解-58"><a href="#官方题解-58" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, n: int)</span> -&gt; List[float]:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">6</span> * n + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)] <span class="comment"># 状态矩阵</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">7</span>): <span class="comment"># 只有一个骰子时，每个点数出现次数为 1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            dp[<span class="number">1</span>][j] = <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>): <span class="comment"># 骰子个数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">6</span> * n + <span class="number">1</span>): <span class="comment"># 出现的点数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">1</span>, j): <span class="comment"># 状态方程</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">if</span> m &lt;= <span class="number">6</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                        dp[i][j] += dp[i - <span class="number">1</span>][j - m]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        total = <span class="number">6</span> ** n</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> [dp[n][k]/total <span class="keyword">for</span> k <span class="keyword">in</span> range(n, <span class="number">6</span> * n + <span class="number">1</span>)]</span></pre></td></tr></table></figure><h2 id="面试题61-扑克牌中的顺子"><a href="#面试题61-扑克牌中的顺子" class="headerlink" title="面试题61. 扑克牌中的顺子"></a><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/" target="_blank" rel="noopener">面试题61. 扑克牌中的顺子</a></h2><h3 id="题目描述-64"><a href="#题目描述-64" class="headerlink" title="题目描述"></a>题目描述</h3><p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: True</span></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: [0,0,1,2,5]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: True</span></pre></td></tr></table></figure><h3 id="个人思路-65"><a href="#个人思路-65" class="headerlink" title="个人思路"></a>个人思路</h3><p>如果我们能够知道 5 张扑克牌中的最大值 $maxValue$ 和最小值 $minValue$ ，那我们就知道，要使它为顺子需要 $maxValue - minValue + 1$ 张牌。</p><ul><li>在查找 $maxValue$ 和 $minValue$ 过程中，跳过大小王 $0$ 。</li><li>如果 $maxValue - minValue + 1 &gt; 5$，说明题目给的 5 张牌不足以构成顺子，返回 <code>false</code> .<ul><li>即使里面有大小王，也不够用来填补使它构成顺子。</li></ul></li><li>如果 $maxValue - minValue + 1 &lt;= 5$，说明 5 张牌足以构成顺子，返回 <code>true</code>。<ul><li>里面的大小王填补在合适位置即可。</li></ul></li></ul><p>同时，我们再定义一个标志数组判断是否有重复数字，发现重复数字直接返回 <code>false</code> 即可。</p><h3 id="官方题解-59"><a href="#官方题解-59" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isStraight</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        nums = [num <span class="keyword">for</span> num <span class="keyword">in</span> nums <span class="keyword">if</span> num]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> len(nums) == len(set(nums)) <span class="keyword">and</span> max(nums) - min(nums) &lt; <span class="number">5</span></span></pre></td></tr></table></figure><h2 id="面试题62-圆圈中最后剩下的数字"><a href="#面试题62-圆圈中最后剩下的数字" class="headerlink" title="面试题62. 圆圈中最后剩下的数字"></a><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题62. 圆圈中最后剩下的数字</a></h2><h3 id="题目描述-65"><a href="#题目描述-65" class="headerlink" title="题目描述"></a>题目描述</h3><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 5, m &#x3D; 3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: 3</span></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 10, m &#x3D; 17</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: 2</span></pre></td></tr></table></figure><h3 id="个人思路-66"><a href="#个人思路-66" class="headerlink" title="个人思路"></a>个人思路</h3><p>约瑟夫问题</p><script type="math/tex; mode=display">f(n,m)=\begin{cases}0& \text{n=1} \\\ [f(n-1,m)+m\ ]\%n& \text{n>1}\end{cases}</script><h3 id="官方题解-60"><a href="#官方题解-60" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastRemaining</span><span class="params">(self, n: int, m: int)</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        pos = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            pos = (pos + m) % i</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> pos</span></pre></td></tr></table></figure><h2 id="面试题63-股票的最大利润"><a href="#面试题63-股票的最大利润" class="headerlink" title="面试题63. 股票的最大利润"></a><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/" target="_blank" rel="noopener">面试题63. 股票的最大利润</a></h2><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: 5</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格。</span></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: 0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span></pre></td></tr></table></figure><h3 id="个人思路-67"><a href="#个人思路-67" class="headerlink" title="个人思路"></a>个人思路</h3><p><strong>使用动态规划：</strong></p><ul><li>状态定义： 设动态规划列表 $dp$ ，$dp[i]$ 以 $prices[i]$ 结尾的子数组的最大利润（以下简称为 前 $i$ 日的最大利润 ）。</li><li>转移方程： 由于题目限定 “买卖该股票一次” ，因此前 $i$ 日最大利润  等于前 $i - 1$ 日最大利润 $dp[i-1]$ 和第 $i$ 日卖出的最大利润中的最大值。</li></ul><script type="math/tex; mode=display">dp[i]=max(dp[i−1],prices[i]−min(prices[0:i]))</script><ul><li><strong>初始状态：</strong> $dp[0] =0$ ，即首日利润为 $0$ ；</li></ul><p><strong>效率优化：</strong></p><ul><li>时间复杂度降低： 前 $i$ 日的最低价格 $min(prices[0:i])$ 时间复杂度为 $O(i)$ 。而在遍历 $prices$ 时，可以借助一个变量（记为成本 $cost$ ）每日更新最低价格。优化后的转移方程为：</li></ul><script type="math/tex; mode=display">dp[i]=max(dp[i−1],prices[i]−min(cost,prices[i])</script><ul><li>空间复杂度降低： 由于 $dp[i]$ 只与 $dp[i - 1]$ , $prices[i]$ , $cost$ 相关，因此可使用一个变量（记为利润 $profit$ ）代替 $dp$ 列表。优化后的转移方程为：</li></ul><script type="math/tex; mode=display">profit=max(profit,prices[i]−min(cost,prices[i])</script><h3 id="官方题解-61"><a href="#官方题解-61" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        cost, profit = float(<span class="string">"+inf"</span>), <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            cost = min(cost, price)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            profit = max(profit, price - cost)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> profit</span></pre></td></tr></table></figure><h2 id="面试题68-I-二叉搜索树的最近公共祖先"><a href="#面试题68-I-二叉搜索树的最近公共祖先" class="headerlink" title="面试题68 - I. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">面试题68 - I. 二叉搜索树的最近公共祖先</a></h2><h3 id="题目描述-66"><a href="#题目描述-66" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p><img src="/2020/03/30/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87%20Offer/10.png" class=""> <p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: 6 </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span></pre></td></tr></table></figure><h3 id="个人思路-68"><a href="#个人思路-68" class="headerlink" title="个人思路"></a>个人思路</h3><p>根据以上定义，若 root 是 p, q 的<strong>最近公共祖先</strong> ，则只可能为以下情况之一：</p><ul><li>节点 p 和 q 是节点 root 的子节点，且分列 root 的<strong>异侧</strong>（即分别在左、右子树中）；</li><li>p = root ，且 q 在 root 的左或右子树中；</li><li>q = root ，且 p 在 root 的左或右子树中；</li></ul><p>本题给定了两个重要条件：① 树为<strong>二叉搜索树</strong> ，② 树的所有节点的值都是<strong>唯一</strong>的。根据以上条件，可方便地判断 p,q 与 root 的子树关系，即：</p><ul><li>若 <code>root.val &lt; p.val</code> ，则 p 在 root <strong>右子树</strong>中；</li><li>若 <code>root.val &gt; p.val</code> ，则 p 在 root <strong>左子树</strong>中；</li><li>若 <code>root.val = p.val</code> ，则 p 和 root 指向<strong>同一节点</strong> 。</li></ul><h3 id="官方题解-62"><a href="#官方题解-62" class="headerlink" title="官方题解"></a>官方题解</h3><h4 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> p.val &gt; q.val: <span class="comment"># 保证 p 在 q 的左边</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            p, q = q, p</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> root:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> root.val &lt; p.val: <span class="comment"># 都在右子树</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                root = root.right</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">elif</span> root.val &gt; q.val: <span class="comment"># 都在左子树</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                root = root.left</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">break</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> root</span></pre></td></tr></table></figure><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> p.val &lt; root.val <span class="keyword">and</span> q.val &lt; root.val:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">elif</span> p.val &gt; root.val <span class="keyword">and</span> q.val &gt; root.val:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> root</span></pre></td></tr></table></figure><h2 id="面试题68-II-二叉树的最近公共祖先"><a href="#面试题68-II-二叉树的最近公共祖先" class="headerlink" title="面试题68 - II. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">面试题68 - II. 二叉树的最近公共祖先</a></h2><h3 id="题目描述-67"><a href="#题目描述-67" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p><img src="/2020/03/30/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87%20Offer/11.png" class=""> <p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: 3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">输出: 5</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span></pre></td></tr></table></figure><h3 id="个人思路-69"><a href="#个人思路-69" class="headerlink" title="个人思路"></a>个人思路</h3><p>题目同上，只不过这次我们不是二叉搜索树。</p><p>总共有以下可能的情况：</p><ul><li>p，q分别在左右子树中，返回 <code>root</code>；</li><li>p、q同在一棵树上，则返回其中一个节点。</li></ul><h3 id="官方题解-63"><a href="#官方题解-63" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: TreeNode, p: TreeNode, q: TreeNode)</span> -&gt; TreeNode:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> root == p <span class="keyword">or</span> root == q:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> root</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        left_node = right_node =<span class="literal">None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> root.left: <span class="comment"># 左节点返回左子树的遍历结果</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            left_node = self.lowestCommonAncestor(root.left, p, q)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> root.right: <span class="comment"># 右节点返回右子树的遍历结果</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            right_node = self.lowestCommonAncestor(root.right, p, q)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> left_node <span class="keyword">and</span> right_node: <span class="comment"># 如果同时返回，则意味着分别在左右子树中</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> root</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span>: <span class="comment"># 否则，只遍历到一个节点，意味着另一个节点在同一个子树的下面，无需重复遍历</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> left_node <span class="keyword">or</span> right_node</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是刷「剑指 Offer（第 2 版）」的个人记录，有每道题目的个人解法和思考过程，以及一些比较好的题解和分析过程，使用语言为 Python，主要原因是 Python 的语言非常简洁，初学者可以只关注其具体思考与实现的过程而非代码本身，而且 Python 的语法糖也会让整个代码变得异常简洁。未来会加 Java 代码（因为我Java 学的还是不太行）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指 Offer" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="刷题" scheme="http://yoursite.com/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>材料人转行互联网的春招面经</title>
    <link href="http://yoursite.com/2020/03/28/%E6%9D%82%E8%AE%B0/%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F/"/>
    <id>http://yoursite.com/2020/03/28/%E6%9D%82%E8%AE%B0/%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F/</id>
    <published>2020-03-28T03:54:13.000Z</published>
    <updated>2020-03-29T15:37:42.263Z</updated>
    
    <content type="html"><![CDATA[<p>大家好呀。</p><p>受疫情的影响，今年的「金三银四」总有些和往年的不同，几乎所有的面试都转为视频和电话面试。我也通过过去半年的学习，一边投递互联网开发岗位，一边继续学习新的知识。接下来就说一下最近这一个月的面试过程，也算是对自己学习的复盘。</p><a id="more"></a><p>招聘信息大多来自<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">牛客网</a>，由于有着大三下学期的「夏令营」经验，开启了海投模式。那个时候的简历也是无比粗糙，在「图森未来」的 HR 小姐姐的帮助下，改进了自己的简历，效果也是显著。</p><p>就这样，我收到了一系列笔试和面试。</p><h2 id="阿里搜索推荐中台"><a href="#阿里搜索推荐中台" class="headerlink" title="阿里搜索推荐中台"></a>阿里搜索推荐中台</h2><p>帮我内推的小哥哥相当热情，对我简历也有很正面的评价。即使在飞书面试失利后，也热情地邀请我去他们部门面试。</p><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>一面距离比较久了，很多记得也不是特别清楚，大多都是问了些死锁、三次握手的一些高频知识点。</p><p>那个时候也是比较紧张，而且那天我的嗓子开始发炎，也有低热的症状，很多知识点答的也没有太多的逻辑可言。后来就是喜闻乐见的做题环节。第一道题目是<strong>判断一颗二叉搜索树</strong>，中序遍历判断是否为升序即可；第二道题目是<strong>判断是否有重复元素</strong>，用 Python 的 Set 可以很容易的解出，但是我那个时候用的是散列表查询。</p><p>总体来说，感觉并不是特别理想，包括反问环节，面试官也没有透露太多的信息。</p><p>后来一周由于发炎高烧的缘故，推掉了很多面试笔试。</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>二面的话面试官相当友善，即使我有些问题回答的不大好，面试官也会友善地说没关系，之后你可以下去看看。问的也是很多基础知识，无外乎也是些高频题目，这里不在赘述。</p><p>问的算法题目也不是很难，第一道是<strong>找出第 K 大的数</strong>，我的回答是新建一个散列表存放前 K 大的元素，随后遍历来比较数组中的每一个元素。但是这样的话开辟新的空间，可以通过快排的思想进行排序，Pivot 前面的数比自己大，后面是数比自己小，当 Pivot 为倒数第 K 个的元素时，那么 Pivot 就是我们要找的数。</p><p>在后来的反问环节，面试官也对我的基础有着比较正面的评价，也嘱咐我多去练习一些项目。总体来说是到目前为止最好的面试体验。</p><h2 id="钉钉"><a href="#钉钉" class="headerlink" title="钉钉"></a>钉钉</h2><p>钉钉是我自己投的简历，可能因为阿里的系统只可以投递一个部门，所以把我上一个投递覆盖掉了，所以上一次的面试也没有了后续。钉钉无疑是目前为止最不理想的面试。</p><h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><p>面试官刚上来也没有自我介绍，问了意向的工作地点、实习时间就开始了面试。</p><p>第一道问题是<strong>虚拟内存</strong>，但是那个时候有点儿卡壳，后来才想起来，面试官一直在电话那头说你是不是不知道，也造成了一定干扰。</p><p>面试中问到了<strong>伙伴系统</strong>，恰巧我之前学习过，也说出来其中的原理，但是面试官要求用代码实现，没有答出来。</p><p>后来问到<strong>排序算法</strong>，这部分按照时间复杂度的顺序答了出来。这个时候面试官又问<strong>堆排序</strong>的代码实现，和上道题目一样，只知道原理。</p><p>最后问了一个「剑指 Offer」的<a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/" target="_blank" rel="noopener">第 21 题</a><strong>调整数组顺序使奇数位于偶数前面</strong>，但是那个题目我没有见过（还是刷题太少），要求 O(n) 的时间复杂度和 O(1) 的空间复杂度，一开始我没有理解题目，以为还要求奇数和偶数都要分别排序，和面试官确认题目就浪费了不少时间。但是后来想到了双指针分别查找奇数和偶数的方法，和面试官说了自己的想法后，没想到被否认了，比较可惜。</p><p>后来也没有反问环节，总体还是面试体验不佳。</p><h2 id="飞书"><a href="#飞书" class="headerlink" title="飞书"></a>飞书</h2><h3 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h3><p>飞书的面试是视频面试，用的是牛客网的面试系统。</p><p>一开始就是我们喜闻乐见的做题环节，一道<strong>平分周长</strong>的问题，后来磕磕绊绊写出来了。</p><p>之后就是面试题目，不得不说飞书的面试不怎么考高频的面试题，比如一般 TCP 大家都会问<strong>三次握手</strong>和<strong>四次挥手</strong>，但是面试官问的是<strong>滑动窗口</strong>。当然也问到了数据库的问题，这个是之前面试没有问过的。</p><p>反问环节给我的反馈也是多去练习，代码可复用性不强。</p><h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><p>三天后收到了二面通知，同样是视频面试。</p><p>还是喜闻乐见的做题环节，第一道题目就是要写一个 <strong>Retry 的装饰器</strong>，不会，只写了装饰器的模板。</p><p>第二道是<strong>八皇后</strong>问题，上一次看八皇后是两周之前，当时只记得判断条件是 x - y 和 x + y，只和面试官说了这些，实际上代码的实现还是比较简单的，有点可惜。</p><p>后来就问 <strong>Hashset</strong> ，但是那个时候 Python 是主要语言，Java 的确认了解不多，只和面试官说了 Hashmap，这个明显是不过关的。</p><p>于是，就到了反问环节，面试官也很中肯地给出了建议。总结一下，飞书的面试确实不会问高频的面试题目，反而会问些与之相关的问题，这样可以检验对方是刷面经还是真正的学习。</p><p>一天之后转岗到教育业务。</p><h2 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h2><p>腾讯的状态很早就变了，但是过了几天才发起了面试通知，听声音感觉面试官年纪不小，态度很好，称谓都是「您」，着实让我震惊。</p><h3 id="一面-3"><a href="#一面-3" class="headerlink" title="一面"></a>一面</h3><p>腾讯没有问算法相关的问题。看到我用 Python 就问了<strong>装饰器</strong>的问题，还有 <strong>HTTP</strong> 的问题，还有<strong>数据库</strong>的问题。最后问了一个<strong>银行转账的余额变化</strong>的问题，之前看过用 Python 多线程实现火车余票查询的问题，于是就答了线程和锁，但是面试官不是特别满意，所以就说了<strong>乐观锁</strong>。</p><p>值得一提的是面试官问的问题很泛，并不会问具体的一个问题，所以我回答的也会比较多一些。面试官边听我的回答边会在黑板上记录。而且，有些问题我不知道，面试官也不会深究。</p><hr><p>之前学 TOEFL 的时候，口语老师津津乐道的故事就是一个学生没有报班，而是报了十几次考试，从 20 分考到了 70 分。</p><p>这段经历也是十分有趣，有给予我帮助的朋友们，也有对我提出批评的朋友。总的来说是对我有帮助的，这样我可以更好的查漏补缺，为自己秋招做好完善的准备。</p><p>最后还是要更加努力地去刻意练习算法题，更要去完善自己不熟悉的<strong>数据库</strong>和 <strong>Java</strong> 的知识。</p><hr><p>最后，和大家分享一下我的学习资料：</p><ol><li><p><a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">CS-Notes</a></p><p>这是一名字节跳动拿到 SSP 的前辈总结的知识，每一个知识点都很详细，但是两年过去了，很多新的知识需要自己补充，但是用来查漏补缺也是很不错的。</p></li><li><p><a href="https://time.geekbang.org/column/intro/126" target="_blank" rel="noopener">数据结构与算法之美</a></p><p>如果只能推荐一个 APP 的话，那我只推荐<strong>极客时间</strong>，学生也有半价优惠。其中很多基础知识点都会用在工程中的实例来表现，能够更好地理解。</p></li><li><p><a href="https://time.geekbang.org/column/intro/82" target="_blank" rel="noopener">Java核心技术面试精讲</a></p><p>这个不多说了，太多高频考点了，看这个我感觉甚至有作弊的嫌疑。</p></li><li><p><a href="https://www.shiyanlou.com/" target="_blank" rel="noopener">实验楼</a></p><p>实践项目的利器，不用费心去搭建环境，能够更专注于其本身的实现。</p></li><li><p><a href="https://github.com/labuladong/fucking-algorithm" target="_blank" rel="noopener">fucking-algorithm</a></p><p>作者是 LeetCode 中文站的高票答主，总结了很多同类算法题目的通用解法，非常适合刷很多题目的朋友建立框架。</p></li></ol><hr><script type="math/tex; mode=display">To\ Be\ Continued\ ...</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家好呀。&lt;/p&gt;
&lt;p&gt;受疫情的影响，今年的「金三银四」总有些和往年的不同，几乎所有的面试都转为视频和电话面试。我也通过过去半年的学习，一边投递互联网开发岗位，一边继续学习新的知识。接下来就说一下最近这一个月的面试过程，也算是对自己学习的复盘。&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂记" scheme="http://yoursite.com/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="面经" scheme="http://yoursite.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>面对「疫情」，我们或许可以先做这些事</title>
    <link href="http://yoursite.com/2020/02/19/%E6%9D%82%E8%AE%B0/%E7%96%AB%E6%83%85/"/>
    <id>http://yoursite.com/2020/02/19/%E6%9D%82%E8%AE%B0/%E7%96%AB%E6%83%85/</id>
    <published>2020-02-19T03:54:13.000Z</published>
    <updated>2020-02-19T07:25:36.136Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/02/19/%E6%9D%82%E8%AE%B0/%E7%96%AB%E6%83%85/1.jpg" class=""> <p>大家好呀，好久不见。</p><p>上班的朋友都复工了嘛？无法返校的同学看文献了嘛？</p><a id="more"></a><p>由于我专业方向是计算模拟，再加上学校最近也开放了超算的使用权限，除了在家处理数据之外，闲暇之余也会学习些计算机的相关知识。所以，基本学习还算是有条不紊。</p><p>可是，对于其他朋友来说，影响是比较大的，无法返校不能做实验，对中期审查乃至毕业都可能会有影响。</p><p>那么，对于这次甚至未来的<strong>黑天鹅事件</strong>，我们普通人可以先做哪些事情呢？</p><p>首先，我们来看一下什么是<strong>黑天鹅事件</strong>。</p><p>所谓<strong>黑天鹅</strong>，指的是事前无法预知、但是具有重大影响力的不确定性事件。这次事件就是<strong>黑天鹅事件</strong>。没有人预料到它的到来，<strong><a href="http://www.caixin.com/2020-01-23/101507670.html" target="_blank" rel="noopener">几乎所有人都低估了它的影响力</a></strong>。</p><p>面对黑天鹅，可以很悲观地说，我们既没有办法来预测它，也没有办法去避免它，甚至会低估它。它就像特洛伊木马，一夜之间倾巢而出，警报的拉响也是姗姗来迟。</p><p>那我们换个角度，既然未来无法预测也无法避免，那要做些什么才能<strong>扛得住黑天鹅事件对自己的打击</strong>呢？我从一个应届生的角度给出我的看法：</p><h3 id="1-选择一个合适的城市"><a href="#1-选择一个合适的城市" class="headerlink" title="1. 选择一个合适的城市"></a>1. 选择一个合适的城市</h3><p>全国范围内<strong>第一梯队</strong>的城市的很多，从房价就可见一斑，市场做出了对城市的教育、医疗、公共资源的选择。但是，不同地区应对突发公共事件的能力确实有很大的差异。截至目前，某省确诊病例 1173 例，却无一死亡，这很难说是运气成分。</p><p>这次事件也是对不同地区的公开测验，结果一目了然。</p><h3 id="2-准备风险储备金"><a href="#2-准备风险储备金" class="headerlink" title="2. 准备风险储备金"></a>2. 准备风险储备金</h3><p>我刚开始学习理财的时候，除了买保险之外的第一件事就是要准备 6 个月的<strong>风险储备金</strong>，以备不时之需。面对几个月的空档期，会需要足够的现金周转，解决生计。</p><h3 id="3-控制负面信息的摄入"><a href="#3-控制负面信息的摄入" class="headerlink" title="3. 控制负面信息的摄入"></a>3. 控制负面信息的摄入</h3><p>人常说兼听则明，可过多的信息反而会对我们形成干扰，潜意识里我们会做出错误假设，而我们对于已经形成的认知又很难去改变。尤其是过量的负面信息会让有同理心的我们陷入<strong>感同身受</strong>的境地，情绪也会随之失控。我们需要做的则是控制负面信息的摄入，让自己回到真实的生活中。</p><h3 id="4-建立生活秩序"><a href="#4-建立生活秩序" class="headerlink" title="4. 建立生活秩序"></a>4. 建立生活秩序</h3><p>日常工作和生活都无法正常运行的情况，我们的情绪也会失序，这样我们大部分精力都会花在无意义的事情上。</p><p>而这也是个契机，这段时间里没有工作学习的压力，可以趁这个机会去做一些很久之前想做的事，学习新的技能，重新建立起生活的秩序。储备子弹，抓住契机。</p><hr><p>这段时间里，我们每个人都经历过不安、惶恐、愤怒的情绪。一些事情我们确实无法改变，这会让我们产生无力感。可自身生活的方向盘就在我们手中，这是可以掌控的。目前生活的秩序都是医生恪尽职守、外卖物流有条不紊、科研学者尽心尽力所维护的。没有什么英雄主义，也没有什么运筹帷幄，每个人各司其职，做好了自己应该做的事。</p><p><a href="https://brikarl.github.io/2018/12/31/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/2018%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">2018 年初我经历了一段低谷期</a>，我在那个时候写过一段话：</p><blockquote><p>自己做的一切可能真的很难改变现状，但是不经意间的一个善举就会给身边的人带来莫大的温暖。而这，也许是在这个世界中我们依旧呼吸与共的理由吧。</p></blockquote><p>谢谢你，谢谢每一个认真工作的你。</p><hr><p>题图：2020 年 1 月 20 日摄于 G683 次列车，7 天后，那趟车里确诊了一例新冠肺炎患者。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2020/02/19/%E6%9D%82%E8%AE%B0/%E7%96%AB%E6%83%85/1.jpg&quot; class=&quot;&quot;&gt; 
&lt;p&gt;大家好呀，好久不见。&lt;/p&gt;
&lt;p&gt;上班的朋友都复工了嘛？无法返校的同学看文献了嘛？&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂记" scheme="http://yoursite.com/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="风险管控" scheme="http://yoursite.com/tags/%E9%A3%8E%E9%99%A9%E7%AE%A1%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>4 线程</title>
    <link href="http://yoursite.com/2020/02/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4%20%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/02/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4%20%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-02-17T05:53:53.000Z</published>
    <updated>2020-02-18T14:54:03.738Z</updated>
    
    <content type="html"><![CDATA[<p>上一章我们介绍了<strong>内存管理</strong>的相关知识，了解了操作系统是如何让每个进程「独享」 内存空间的。</p><p>这一章我们来介绍操作系统的<strong>线程</strong>知识，在实际过程中，多个线程可能要共同访问同一段空间，如何让他们彼此协调工作，就是我们这一章讨论的话题。</p><a id="more"></a><h2 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h2><p>通过前面两章的学习，我们了解了操作系统如何将一个物理 CPU 变成多个虚拟 CPU，从而使多个程序「同时」运行；还了解到为每个进程创建「独享」的虚拟内存。</p><p>下面我们来介绍<strong>线程</strong>（thread），线程是进程的一部分，单个线程类似于独立的进程，只不过线程<strong>共享</strong>内存地址，而且线程有各自的寄存器和堆栈。</p><h3 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h3><p>多个线程会共享同一存储空间，下面我们用生活中的例子来描述一下可能发生的情况。</p><p>当家里的冰箱中没有面包时，就需要去采购面包。假设你和你的女朋友是两个线程，冰箱就是内存，面包就是数据。有时候，当你发现没有面包的时候，你就会去买面包，但是在你买面包的途中，你的女朋友也发现没有面包，那么她也会去买面包，最终冰箱中就会有过量的面包，这是我们不希望出现的情况。</p><p>这个时候，我可以在买面包之前留一个便笺，告诉女朋友我已经去买面包了，这样对方也不会去买面包了。伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nobread) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (noNote) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">leave Note;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">buy bread;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">remove</span> Note;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>可是在计算机运行的过程中，会发生<strong>时钟中断</strong>，当一个线程切换到另一个线程的时候，就可能会发生以下情况：</p><img src="/2020/02/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4%20%E7%BA%BF%E7%A8%8B/1.png" class="" title="线程"> <p>当线程 A 执行到第 2 行时，这时发生时钟中断，切换到线程 B，此时线程 B 检查过后发现并没有面包和便笺，于是继续会去买面包，最终也会有过量的面包。</p><p>那我先留便笺，女朋友看到之后就知道我去买面包了，伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">leave Note;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nobread) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (noNote) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        buy bread;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">remove</span> note;</span></pre></td></tr></table></figure><p>我们再来看看实际情况：</p><img src="/2020/02/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4%20%E7%BA%BF%E7%A8%8B/2.png" class="" title="线程"> <p>当我们两个人都留下便笺之后，我们都会认为对方去买面包了，就不会也面包了。</p><p>那我们来看一个更大胆的设想，在使用冰箱前我先加一把锁，只有我可以打开，那么伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">breadlock.Acquire();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nobread) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    buy bread;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">breadlock.Release();</span></pre></td></tr></table></figure><p>这样即使切换到另一个线程，对方也打开不冰箱。</p><p>通过上面这个例子，我们得出几个概念：</p><ul><li><strong>临界区</strong>（critical section）：访问共享资源的一段代码，比如我们买面包就是临界区。</li><li><strong>互斥</strong>（mutual exclusion）：一个进程占用资源，其它进程不能使用。</li><li><strong>死锁</strong>（deadlock）：多个进程各占用部分资源，形成循环等待。</li><li><strong>饥饿</strong>（starvation）：其他进程可能轮流占用资源，一个进程一直得不到资源。</li><li><strong>锁</strong>（lock）：<code>Lock::Acquire()</code>在锁被释放前一直等待，然后得到锁。<code>Lock::Release()</code>释放锁，唤醒任何等待的线程。</li></ul><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p><strong>信号量</strong>（semaphore）由一个整形 (sem)变量和两个原子操作组成：</p><ul><li><strong>P()</strong><ul><li>sem 减 1；</li><li>如果 sem ＜ 0 ，进入等待，否则继续。</li></ul></li><li><strong>V()</strong><ul><li>sem 加 1；</li><li>如果 sem ≥ 0 ，唤醒一个等待线程。</li></ul></li></ul><p>锁（mutex）可以看作是 sem 最大值为 1 的信号量，锁更倾向于使用权，信号量则适用于资源管理。</p><h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h3><p>下面，我们用信号量和锁解决一个经典问题：</p><p>有生产者和消费者，生产者在生成数据后放入一个缓冲区中，单个消费者从缓冲区取出数据，但是任何时刻只有一个生产者或消费者可访问缓冲区。</p><p>在这个情况中，我们可以分析成如下条件：</p><ul><li>任何时刻只能有一个线程操作缓冲区（<strong>互斥访问</strong>）</li><li>缓冲区空时，消费者必须等待生产者；缓冲区满时，生产者必须等待消费者（<strong>条件同步</strong>）</li></ul><p>于是，我们就需要信号量来描述每个约束：</p><ul><li><strong>mutex</strong>：互斥；</li><li><strong>fullBuffers</strong>：充满的缓冲区；</li><li><strong>emptyBuffers</strong>：空闲的缓冲区。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 信号量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Class BoundedBuffer &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    mutex = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    fullBuffers = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    emptyBuffers = <span class="keyword">new</span> Semaphore(n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">BoundedBuffer::Deposit(c) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    emptyBuffers-&gt;P(); </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    mutex-&gt;P(); </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    Add c to the <span class="built_in">buffer</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    mutex-&gt;V();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    fullBuffers-&gt;V();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费者</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">BoundedBuffer::Remove(c) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    fullBuffers-&gt;P();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    mutex-&gt;P();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    Remove c from <span class="built_in">buffer</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    mutex-&gt;V();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    emptyBuffers-&gt;V();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>我们可以看到，消费者先运行，当消费者执行第 17 行时，缓冲区没有数据，fullBuffers 初始值为 0，减为 -1，消费者睡眠。</p><p>假设生产者开始生产，emptyBuffers 初始值为 n ，所以继续执行，到第 13 行时为fullBuffers 增加信号量，唤醒消费者，消费者可以执行。</p><h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><p>下面，我们来讨论一个经典的并发问题，<strong>哲学家就餐问题</strong>。</p><p>假定有 5 位哲学家围着一个圆桌。每两位哲学家之间有一把餐叉（一共 5 把）。哲学家有时要思考一会，不需要餐叉；有时又要就餐。而一位哲学家只有同时拿到了左手边和右手边的两把餐叉，才能吃到东西。</p><img src="/2020/02/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4%20%E7%BA%BF%E7%A8%8B/3.png" class="" title="哲学家就餐问题"> <p>在实际情况中，我们可能会遇到五位哲学家同时拿起左边餐叉的情况，这样就会导致死锁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5<span class="comment">// 哲学家个数</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">semaphore fork[<span class="number">5</span>];<span class="comment">// 信号量初值为1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span><span class="comment">// 哲学家编号：0 － 4</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function">    <span class="title">while</span><span class="params">(TRUE)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function">    </span>&#123;      </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        think( );<span class="comment">// 哲学家在思考</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">P(fork[i]);<span class="comment">// 去拿左边的叉子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">P(fork[(i + <span class="number">1</span>) % N]);<span class="comment">// 去拿右边的叉子     </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        eat( );<span class="comment">// 吃面条中……</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">V(fork[i]);<span class="comment">// 放下左边的叉子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        V(fork[(i + <span class="number">1</span>) % N ]);<span class="comment">// 放下右边的叉子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure><p>于是，我们可以想得极端一些，只允许一个吃饭，这就需要<strong>锁</strong>（mutex）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5<span class="comment">// 哲学家个数</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">semaphore fork[<span class="number">5</span>];<span class="comment">// 信号量初值为1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">semaphore mutex;<span class="comment">// 互斥信号量，初值1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span><span class="comment">// 哲学家编号：0 － 4</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function">    <span class="title">while</span><span class="params">(TRUE)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function">    </span>&#123;      </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        think( );<span class="comment">// 哲学家在思考</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        P(mutex);<span class="comment">// 进入临界区</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">P(fork[i]);<span class="comment">// 去拿左边的叉子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">P(fork[(i + <span class="number">1</span>) % N]);<span class="comment">// 去拿右边的叉子     </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        eat( );<span class="comment">// 吃面条中……</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">V(fork[i]);<span class="comment">// 放下左边的叉子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        V(fork[(i + <span class="number">1</span>) % N ]);<span class="comment">// 放下右边的叉子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        V(mutex);<span class="comment">// 退出临界区</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure><p>这样确实访问正确，但是只允许一个人就餐未免效率也太低了些。我们可以让不同的哲学家拿起不同的餐叉，这样可以让多人同时就餐。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5<span class="comment">// 哲学家个数</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">semaphore fork[<span class="number">5</span>];<span class="comment">// 信号量初值为1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">semaphore mutex;<span class="comment">// 互斥信号量，初值1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span><span class="comment">// 哲学家编号：0 － 4</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function">    <span class="title">while</span><span class="params">(TRUE)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function">    </span>&#123;      </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        think( );<span class="comment">// 哲学家在思考</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i%<span class="number">2</span> == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            P(fork[i]);<span class="comment">// 去拿左边的叉子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            P(fork[(i + <span class="number">1</span>) % N]);<span class="comment">// 去拿右边的叉子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            P(fork[(i + <span class="number">1</span>) % N]);<span class="comment">// 去拿右边的叉子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            P(fork[i]);<span class="comment">// 去拿左边的叉子 </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        &#125;          </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        eat( );<span class="comment">// 吃面条中……</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">V(fork[i]);<span class="comment">// 放下左边的叉子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        V(fork[(i + <span class="number">1</span>) % N ]);<span class="comment">// 放下右边的叉子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure><h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h3><p>另一个经典问题关注的是更加灵活的协同访问，不同类型的访问可能需要不同的锁。例如，一个并发链表有很多插入和查找操作。插入操作会修改链表的状态，而查找操作只是读取该结构，只要没有进行插入操作，我们可以并发的执行多个查找操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写者</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">P(WriteMutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">write</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">V(WriteMutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读者</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">P(CountMutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Rcount == <span class="number">0</span>)<span class="comment">//如果是第一个读者获得写锁</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">P(WriteMutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">++Rcount;<span class="comment">//后续读者无需获得锁</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">V(CountMutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">P(CountMutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">--Rcount;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Rcount == <span class="number">0</span>)<span class="comment">//如果是最后一个读者解除写锁</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">V(WriteMutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">V(CountMutex)</span></pre></td></tr></table></figure><p>可以看到，只要有读者在读的状态，后续的读者就能直接进入，这样，会导致写者饥饿</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁（deadlock）是一种在许多复杂并发系统中出现的经典问题。例如，当线程 1 持有锁 L1，正在等待另外一个锁 L2，而线程 2 持有锁 L2，却在等待锁 L1 释放时，死锁就产生了。</p><img src="/2020/02/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4%20%E7%BA%BF%E7%A8%8B/4.png" class="" title="死锁"><h3 id="产生死锁的条件"><a href="#产生死锁的条件" class="headerlink" title="产生死锁的条件"></a>产生死锁的条件</h3><p>我们来看看死锁需要的条件：</p><ul><li><strong>互斥</strong>：线程对于需要的资源进行互斥的访问（例如一个线程抢到锁）。</li><li><strong>持有并等待</strong>：线程持有了资源（例如已将持有的锁），同时又在等待其他资源（例如，需要获得的锁）。</li><li><strong>非抢占</strong>：线程获得的资源（例如锁），不能被抢占。</li><li><strong>循环等待</strong>：线程之间存在一个环路，环路上每个线程都额外持有一个资源，而这个资源又是下一个线程要申请的。</li></ul><h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>如果上述 4 个条件的任何一个没有满足，死锁就不会发生。因此，我们首先研究一下预防死锁的方法；每个策略都设法阻止某一个条件，从而解决死锁的问题。</p><ul><li>互斥<ul><li>把互斥的共享资源封装成可同时访问</li></ul></li><li>持有并等待<ul><li>进程请求资源时，要求它不持有任何其他资源</li><li>仅允许进程在开始执行时，一次请求所有需要的资源</li></ul></li><li>非抢占<ul><li>如进程请求不能立即分配的资源，则释放已占有资源</li><li>只在能够同时获得所有需要资源时，才执行分配操作</li></ul></li><li>循环等待<ul><li>对资源排序，要求进程按顺序请求资源</li></ul></li></ul><h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p>除了死锁预防，某些场景更适合死锁避免（avoidance）。我们需要了解全局的信息，包括不同线程在运行中对锁的需求情况，从而使得后续的调度能够避免产生死锁。</p><p><strong>银行家算法</strong>也是死锁避免的一种算法，多名客户向银行家贷多种款项，银行家也知道每名客户的<strong>贷款最大值</strong>，而客户在贷款额满足自己要求前是<strong>不会归还款项</strong>的，因此银行家根据自己手头的<strong>余额</strong>和每名客户<strong>剩余贷款金额</strong>来衡量款项分配尤为重要，银行家对待每名客户的贷款请求也会慎重考虑，避免其他用户无款可贷。</p><p>银行家就是我们的操作系统，客户就是多个线程，多种款项就是多种资源，贷款就是向操作系统申请资源。</p><h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><p>最后一种常用的策略就是允许死锁偶尔发生，检查到死锁时再采取行动。举个例子，很多数据库系统使用了死锁检测和恢复技术。死锁检测器会定期运行，通过构建资源图来检查循环。当循环（死锁）发生时，系统需要重启。如果还需要更复杂的数据结构相关的修复，那么需要人工参与。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章我们介绍了<strong>线程</strong>的知识，先介绍了线程的相关概念，重点介绍了<strong>互斥</strong>，由此引出<strong>信号量</strong>的概念，用信号来实现线程之间的互斥与协同，解决了几个经典问题。最后，对于<strong>死锁</strong>问题，我们又介绍了三种解决方案。</p><p>到目前为止，我们的<strong>操作系统</strong>相关知识就告一段落了。下面我们将介绍<strong>计算机网络</strong>的相关知识，这一部分我也刚刚开始接触，所以更新较慢，大家见谅。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://book.douban.com/subject/33463930/" target="_blank" rel="noopener">雷姆兹·H.阿帕希杜塞尔 / 安德莉亚·C.阿帕希杜塞尔 - 操作系统导论</a></li><li><a href="http://www.xuetangx.com/courses/course-v1:TsinghuaX+30240243X+sp/about" target="_blank" rel="noopener">向勇 / 陈渝 - 操作系统</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一章我们介绍了&lt;strong&gt;内存管理&lt;/strong&gt;的相关知识，了解了操作系统是如何让每个进程「独享」 内存空间的。&lt;/p&gt;
&lt;p&gt;这一章我们来介绍操作系统的&lt;strong&gt;线程&lt;/strong&gt;知识，在实际过程中，多个线程可能要共同访问同一段空间，如何让他们彼此协调工作，就是我们这一章讨论的话题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>3 内存管理</title>
    <link href="http://yoursite.com/2020/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2020/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2020-02-14T05:53:53.000Z</published>
    <updated>2020-02-15T14:09:14.269Z</updated>
    
    <content type="html"><![CDATA[<p>上一章我们介绍了<strong>进程</strong>的相关知识，了解了操作系统是如何让每个进程「独享」 CPU  的。</p><p>这一章我们继续操作系统<strong>虚拟性</strong>的介绍，介绍<strong>内存管理</strong>，将会从<strong>物理内存</strong>开始，介绍其<strong>连续</strong>与<strong>非连续</strong>的存储方式，继而介绍<strong>虚拟内存</strong>，看看内存是如何让进程「共享」内存空间的。</p><p>这部分内容与国内的教材顺序有所不同，国内大部分是将这一章作为线程，且对线程与进程的区分比较模糊。个人认为这样不利于初学者区分进程与线程。这里推荐威斯康星大学计算机科学教授雷姆兹和安德莉亚夫妇编写的<a href="https://book.douban.com/subject/33463930/" target="_blank" rel="noopener">「操作系统导论」</a>（Operating Systems: Three Easy Pieces），以及以此书为参考教材的课程：清华大学<a href="http://www.xuetangx.com/courses/course-v1:TsinghuaX+30240243X+sp/about" target="_blank" rel="noopener">「操作系统」</a>。</p><a id="more"></a><h2 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h2><h3 id="地址转化"><a href="#地址转化" class="headerlink" title="地址转化"></a>地址转化</h3><p>早期计算机中程序中出现的地址就是<strong>物理地址</strong>（Physical address），但是这样同一个程序就无法在不同的机器中使用，因此我们引入<strong>逻辑地址</strong>（Logical address）。</p><p>逻辑地址的生成需要通过程序：编译、汇编、链接这三个步骤。之后借助 CPU 的内存管理单元（Memory Management Unit，MMU）中基址和界限寄存器（base and bounds register），进行动态重定位（dynamic relocation），生成物理地址。转换方式如下：</p><script type="math/tex; mode=display">physical \ address = virtual \ address + base</script><p>进程中使用的内存引用都是逻辑地址，硬件接下来将虚拟地址加上基址寄存器中的内容，得到物理地址，再发给内存系统。如果进程需要访问超过这个界限或者为负数的虚拟地址，CPU 将触发异常，进程最终可能被终止。界限寄存器的用处在于，它确保了进程产生的所有地址都在进程的地址“界限”中。</p><img src="/2020/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1.png" class="" title="地址转化过程"> <h3 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h3><p>在进程调用的过程中，不断有进程终止，因此会产生<strong>外部碎片</strong>（external fragmentation），如何去分配这些未使用的内存，就是我们接下要介绍的动态分区分配策略。比如我们要分配一个 400K 的任务。</p><h4 id="最先匹配（First-Fit-Allocation）"><a href="#最先匹配（First-Fit-Allocation）" class="headerlink" title="最先匹配（First Fit Allocation）"></a>最先匹配（First Fit Allocation）</h4><p>最先匹配要找到第一个足够大的空间。最先匹配有速度优势，但是会让空闲列表开头有很多小块。</p><img src="/2020/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.png" class="" title="最先匹配"> <h4 id="最佳匹配（Best-Fit-Allocation）"><a href="#最佳匹配（Best-Fit-Allocation）" class="headerlink" title="最佳匹配（Best Fit Allocation）"></a>最佳匹配（Best Fit Allocation）</h4><p>最佳匹配需要将空闲列表按大小排序，找到满足且最小的空间。最先匹配尽量避免空间浪费，但是会付出较高的性能代价。</p><img src="/2020/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/3.png" class="" title="最佳匹配"> <p>最差匹配（Worst Fit Allocation）</p><p>最差匹配则与最佳匹配恰恰相反，它会找最大的空间，将其分割后，剩下的块加入空闲列表。</p><img src="/2020/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/4.png" class="" title="最差匹配"> <h4 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h4><p>在内存管理中，空闲空间的合并也非常重要，因此人们设计了<strong>伙伴系统</strong>（Buddy System）。</p><p>在这种系统中，空闲空间被看成大小为 $2^N$ 的空间。当有一个内存分配请求时，空间地址会递归地一分为二，直到整个大小恰好可以满足要求。如下图，我们要申请一个 7KB 的空间：</p><img src="/2020/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/5.png" class="" title="伙伴系统"> <p>这种分配策略只允许分配 $2^n$ 的空闲块，因此会存在<strong>内部碎片</strong>（internal fragment）。</p><p>当块被释放时，8KB 的块归还给空闲列表时，分配程序会检查「伙伴」8KB 是否空闲。如果是，则合二为一，变成 16KB 的块。</p><h2 id="非连续内存分配"><a href="#非连续内存分配" class="headerlink" title="非连续内存分配"></a>非连续内存分配</h2><p>之前我们讨论的是连续内存分配，即最小单位为每个程序的内存。每个程序的物理内存必须连续，这样也会产生内部碎片和外部碎片。我们下面介绍非连续内存分配的方式。</p><h3 id="段式存储管理（Segmentation）"><a href="#段式存储管理（Segmentation）" class="headerlink" title="段式存储管理（Segmentation）"></a>段式存储管理（Segmentation）</h3><p>对进程空间而言，可分为程序代码、堆、栈等。我们可以将这些段对应实际内存空间的块。硬件在地址转换时使用段寄存器，如下图所示，$s$ 表示段号，$addr$ 代表段内偏移量。</p><img src="/2020/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/6.png" class="" title="段访问机制"> <h3 id="页式存储管理（Paging）"><a href="#页式存储管理（Paging）" class="headerlink" title="页式存储管理（Paging）"></a>页式存储管理（Paging）</h3><p>对于段式管理机制而言，段内依旧连续，因此我们提出了更加灵活的存储管理机制：<strong>分页</strong>。首先我们要区分几个概念：</p><ul><li><strong>页帧</strong>（Frame）：将物理地址空间划分为大小相同的基本分配单位。</li><li><strong>页面</strong>（Page）：将逻辑地址空间也划分为相同大小的基本分配单位。</li><li><strong>页表</strong>（page table）：页表存储逻辑 - 物理地址的映射关系，从而让系统知道地址空间的每个页实际驻留在物理内存中的哪一帧。由于每个地址空间都需要这种转换，因此一般来说，系统中每个进程都有一个页表。</li></ul><p>如下图所示，页、帧的地址表示如同分段，前几位对应其页（帧）号，后几位对应偏移量。需要注意的是，页号通常不等于帧号，但是两者偏移量相同。</p><img src="/2020/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/7.png" class="" title="分页"> <p>目前我们设计的分页有诸多优势，比如较为灵活，不会产生外部碎片。但是也有缺陷。</p><h4 id="内存访问性能"><a href="#内存访问性能" class="headerlink" title="内存访问性能"></a>内存访问性能</h4><p>我们每一次内存访问，都需要先访问页表，得到对应的帧号才可以再次访问内存，这样会大大增加性能的消耗。</p><h4 id="页表大小"><a href="#页表大小" class="headerlink" title="页表大小"></a>页表大小</h4><p>对于一个 32 位的地址空间，有着 4KB 的页。则这个逻辑地址会分为 20 位的页号和 12 位的偏移量（$页大小 = 2^{12}=4 \ KB$，$页数 = 2^{20}$）。这样就意味着，操作系统要为每个进程管理 $2^{20}$ 个逻辑 - 物理地址的映射关系。如果每个页的条目需要 4 个字节，则每个页表就需要 4MB 内存，如果有 100 个进程同时运行，那么就需要 400MB 内存，而这仅仅是用来存储页表。</p><h3 id="快速地址转换（TLB）"><a href="#快速地址转换（TLB）" class="headerlink" title="快速地址转换（TLB）"></a>快速地址转换（TLB）</h3><p>我们先来解决访问性能的问题，我们之前在组成原理部分讲到过<strong>高速缓存</strong>。利用<strong>局部性原理</strong>将经常访问的部分加载到高速缓存中，以提高访问速度。</p><p>同样的，我们在 CPU 里放了一块缓存芯片。这块缓存芯片我们称之为是<strong>地址变换高速缓冲</strong>（Translation-Lookaside Buffer， TLB）。这块缓存存放了之前已经进行过地址转换的查询结果。这样，当同样的虚拟地址需要进行地址转换的时候，我们可以直接在 TLB 里面查询结果，而不需要多次访问内存来完成一次转换。</p><img src="/2020/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/8.jpeg" class="" title="TLB"> <h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>下面我们来解决页表大小的问题，这里我们引入多级页表（multi-level page<br>table）。</p><p>我们以一个 4 级的多级页表为例，我们把它拆成四段，从高到低，分成 4 级到 1 级这样 4 个页表索引。</p><img src="/2020/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/9.jpeg" class="" title="多级页表"> <p>我们通过上一级找到下一级的页表，最终找到对应的物理帧号，找到地址。这样，多级页表就像一个多叉树的数据结构，所以我们常常称它为页表树（Page Table Tree）。</p><p>在实际情况中，我们用不到所有的页表，对于一个进程而言，除了必须的代码、堆栈，其余空间都是空闲的，这样也不会给该页分配页表，这样就会大大降低页表的大小。</p><h3 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h3><p>段式存储在内存保护方面有优势，页式存储在内存利用和优化转移到后备存储方面有优势。那么将段式存储、页式存储结合，就会得到段页式存储管理。这样设计会很容易做到内存共享。</p><img src="/2020/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/10.png" class="" title="段页式"> <h2 id="虚拟存储"><a href="#虚拟存储" class="headerlink" title="虚拟存储"></a>虚拟存储</h2><p>之前我们讨论的都是物理内存的相关知识，但是物理内存的容量有限，比如现在一台高配个人电脑有 32GB 的内存空间，但是 2013 年发售的 $Grand\ Theft\ Auto\ V$ 就要 90GB。要想把整个游戏进程加载到内存显然是不可能的，这就需要我们扩展磁盘来作为其虚拟内存。 </p><img src="/2020/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/11.png" class="" title="虚拟内存"> <p>在加载程序时，只将当前指令执行需要的部分页面装入内存，在指令执行中需要的指令或数据不在内存（缺页或缺段）时，发出中断指令让处理器通知操作系统将相应的页面或段调入内存中，操作系统也会将内存中暂时不用的页面或段保存到外存中。</p><p>那么，我们该如何选择需要置换的物理帧呢？下面我们就来讨论页面置换算法。</p><h3 id="最优页面置换算法（OPT，optimal）"><a href="#最优页面置换算法（OPT，optimal）" class="headerlink" title="最优页面置换算法（OPT，optimal）"></a>最优页面置换算法（OPT，optimal）</h3><p><strong>最优页面置换算法</strong>在缺页的时候，先去计算内存中每个逻辑页面的下一次访问时间，选择未来最长时间不访问的页面进行置换。这样的算法是缺页最少的，但是在实际系统中是无法实现的，因为我们很难去预测未来。但是这样的算法可以作为置换算法的性能评价依据。</p><p>下面我们来看一个实例，假设缓存可以存 3 个页。</p><div class="table-container"><table><thead><tr><th>访问</th><th>命中/未命中</th><th>踢出</th><th>导致缓存状态</th></tr></thead><tbody><tr><td>0</td><td>未命中</td><td></td><td>0</td></tr><tr><td>1</td><td>未命中</td><td></td><td>0、1</td></tr><tr><td>2</td><td>未命中</td><td></td><td>0、1、2</td></tr><tr><td>0</td><td>命中</td><td></td><td>0、1、2</td></tr><tr><td>1</td><td>命中</td><td></td><td>0、1、2</td></tr><tr><td>3</td><td>未命中</td><td>2</td><td>0、1、3</td></tr><tr><td>0</td><td>命中</td><td></td><td>0、1、3</td></tr><tr><td>3</td><td>命中</td><td></td><td>0、1、3</td></tr><tr><td>1</td><td>命中</td><td></td><td>0、1、3</td></tr><tr><td>2</td><td>未命中</td><td>3</td><td>0、1、2</td></tr><tr><td>1</td><td>命中</td><td></td><td>0、1、2</td></tr></tbody></table></div><p>我们在访问页 3 时未命中，通过分析未来访问情况，我们发现页 2 在最远的未来被访问，于是踢出页 2 。同时我们计算缓存命中率：有 6 次命中和 5 次未命中，那么命中缓存率 $\frac{Hits}{Hits+Misses}$ 为 $\frac{6}{6+5}$ 为 54.5%。如果忽略第一次未命中，那么命中率为 81.8%。​</p><h3 id="先进先出算法（First-In-First-Out-FIFO）"><a href="#先进先出算法（First-In-First-Out-FIFO）" class="headerlink" title="先进先出算法（First-In First-Out, FIFO）"></a>先进先出算法（First-In First-Out, FIFO）</h3><p><strong>FIFO算法</strong>我们使用一个记录所有位于内存中的逻辑页面的链表，<strong>链表元素按驻留内存的时间排序</strong>，链首最长，链尾最短。出现缺页时，选择链首页面进行置换，新页面加到链尾。</p><div class="table-container"><table><thead><tr><th>访问</th><th>命中/未命中</th><th>踢出</th><th>导致缓存状态</th></tr></thead><tbody><tr><td>0</td><td>未命中</td><td></td><td>0</td></tr><tr><td>1</td><td>未命中</td><td></td><td>0、1</td></tr><tr><td>2</td><td>未命中</td><td></td><td>0、1、2</td></tr><tr><td>0</td><td>命中</td><td></td><td>0、1、2</td></tr><tr><td>1</td><td>命中</td><td></td><td>0、1、2</td></tr><tr><td>3</td><td>未命中</td><td>0</td><td>1、2、3</td></tr><tr><td>0</td><td>未命中</td><td>1</td><td>2、3、0</td></tr><tr><td>3</td><td>命中</td><td></td><td>2、3、0</td></tr><tr><td>1</td><td>未命中</td><td>2</td><td>3、0、1</td></tr><tr><td>2</td><td>未命中</td><td>3</td><td>0、1、2</td></tr><tr><td>1</td><td>命中</td><td></td><td>0、1、2</td></tr></tbody></table></div><p>FIFO 和最优策略相比，FIFO 表现显然逊色些，FIFO 的命中率只有 36.4%。</p><h3 id="最近最久未使用算法（Least-Recently-Used，LRU）"><a href="#最近最久未使用算法（Least-Recently-Used，LRU）" class="headerlink" title="最近最久未使用算法（Least Recently Used，LRU）"></a>最近最久未使用算法（Least Recently Used，LRU）</h3><p>既然我们无法预测未来，我们可以根据局部性原理，对程序之前的行为观察，我们可以计算内存中每个逻辑页面的上一次访问时间，选择上一次使用到当前时间最长的页面。</p><div class="table-container"><table><thead><tr><th>访问</th><th>命中/未命中</th><th>踢出</th><th>导致缓存状态</th></tr></thead><tbody><tr><td>0</td><td>未命中</td><td></td><td>0</td></tr><tr><td>1</td><td>未命中</td><td></td><td>0、1</td></tr><tr><td>2</td><td>未命中</td><td></td><td>0、1、2</td></tr><tr><td>0</td><td>命中</td><td></td><td>1、2、0</td></tr><tr><td>1</td><td>命中</td><td></td><td>2、0、1</td></tr><tr><td>3</td><td>未命中</td><td>2</td><td>0、1、3</td></tr><tr><td>0</td><td>命中</td><td></td><td>1、3、0</td></tr><tr><td>3</td><td>命中</td><td></td><td>1、0、3</td></tr><tr><td>1</td><td>命中</td><td></td><td>0、3、1</td></tr><tr><td>2</td><td>未命中</td><td>0</td><td>3、1、2</td></tr><tr><td>1</td><td>命中</td><td></td><td>3、2、1</td></tr></tbody></table></div><p>在这个例子中，当第一次需要替换页时，LRU 会踢出页 2，因为 0 和 1 的访问时间更近。然后它替换页 0，因为 1 和 3 最近被访问过。我们看到，LRU 的性能快要赶上最优策略了。</p><h3 id="时钟置换算法（Clock）"><a href="#时钟置换算法（Clock）" class="headerlink" title="时钟置换算法（Clock）"></a>时钟置换算法（Clock）</h3><p><strong>时钟置换算法</strong>则是在页表项中增加访问位，描述页面过去一段时间的内访问情况。</p><p>在页面装入内存时，访问位初始化为 0。访问页面时，访问位置 1，缺页时。从指针当前位置顺序检查环形链表，访问位为 0，则置换该页；访问位为 1，则将访问位改为 1，并将指针移动到下一个页面，直到找到可置换的页面。</p><p>这样页面组织起来会形成环形链表，指针也像钟表针一样，因此称为时钟置换算法。</p><h3 id="最不常用算法（Least-Frequently-Used，LFU）"><a href="#最不常用算法（Least-Frequently-Used，LFU）" class="headerlink" title="最不常用算法（Least Frequently Used，LFU）"></a>最不常用算法（Least Frequently Used，LFU）</h3><p><strong>最不常用算法</strong>则是在每个页面设置一个访问计数，在访问页面时，访问计数加 1 ，缺页时，置换计数最小的页面。</p><h3 id="Belady现象"><a href="#Belady现象" class="headerlink" title="Belady现象"></a>Belady现象</h3><p>一般来说，当缓存变大时，缓存命中率是会提高的（变好）。但在这个例子，采用 FIFO，命中率反而下降了。这种奇怪的现象被称为 Belady 的异常（Belady’s Anomaly）。其他一些策略，比如 LRU，不会遇到这个问题。LRU 具有所谓的栈特性（stack property）。对于具有这个性质的算法，大小为 N + 1 的缓存自然包括大小为 N 的缓存的内容。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章我们介绍了<strong>内存管理</strong>的知识，先介绍了物理内存的管理方式，分为连续与非连续分配，不连续分配有<strong>分段</strong>和<strong>分页</strong>，我们重点学习了<strong>分页</strong>相关的知识，也解决了<strong>页表</strong>的问题。</p><p>之后，我们介绍了<strong>虚拟存储</strong>的相关知识，也讨论了<strong>置换算法</strong>。</p><p>下一章将为大家带来<strong>线程</strong>的相关知识，一起来看看操作系统的第二个特性<strong>并发</strong>。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://book.douban.com/subject/33463930/" target="_blank" rel="noopener">雷姆兹·H.阿帕希杜塞尔 / 安德莉亚·C.阿帕希杜塞尔 - 操作系统导论</a></li><li><a href="http://www.xuetangx.com/courses/course-v1:TsinghuaX+30240243X+sp/about" target="_blank" rel="noopener">向勇 / 陈渝 - 操作系统</a></li><li><a href="https://book.douban.com/subject/27096665/" target="_blank" rel="noopener">Andrew S. Tanenbaum / Herbert Bos - 现代操作系统（原书第4版）</a></li><li><a href="https://time.geekbang.org/column/intro/170" target="_blank" rel="noopener">徐文浩 - 深入浅出计算机组成原理</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一章我们介绍了&lt;strong&gt;进程&lt;/strong&gt;的相关知识，了解了操作系统是如何让每个进程「独享」 CPU  的。&lt;/p&gt;
&lt;p&gt;这一章我们继续操作系统&lt;strong&gt;虚拟性&lt;/strong&gt;的介绍，介绍&lt;strong&gt;内存管理&lt;/strong&gt;，将会从&lt;strong&gt;物理内存&lt;/strong&gt;开始，介绍其&lt;strong&gt;连续&lt;/strong&gt;与&lt;strong&gt;非连续&lt;/strong&gt;的存储方式，继而介绍&lt;strong&gt;虚拟内存&lt;/strong&gt;，看看内存是如何让进程「共享」内存空间的。&lt;/p&gt;
&lt;p&gt;这部分内容与国内的教材顺序有所不同，国内大部分是将这一章作为线程，且对线程与进程的区分比较模糊。个人认为这样不利于初学者区分进程与线程。这里推荐威斯康星大学计算机科学教授雷姆兹和安德莉亚夫妇编写的&lt;a href=&quot;https://book.douban.com/subject/33463930/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;「操作系统导论」&lt;/a&gt;（Operating Systems: Three Easy Pieces），以及以此书为参考教材的课程：清华大学&lt;a href=&quot;http://www.xuetangx.com/courses/course-v1:TsinghuaX+30240243X+sp/about&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;「操作系统」&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>2 进程</title>
    <link href="http://yoursite.com/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/</id>
    <published>2020-02-07T05:53:53.000Z</published>
    <updated>2020-02-11T05:17:27.472Z</updated>
    
    <content type="html"><![CDATA[<p>上一章我们介绍了操作系统的基本概念以及特性，补充了些在<strong>组成原理</strong>中未涉及的内容。</p><p>接下来两章我们会从<strong>虚拟性</strong>出发，去分别介绍<strong>进程</strong>（ CPU 虚拟）和<strong>内存管理</strong>（内存虚拟）。这一章先介绍进程的基本概念以及进程的<strong>调度算法</strong>。</p><a id="more"></a><h2 id="进程的基本概念"><a href="#进程的基本概念" class="headerlink" title="进程的基本概念"></a>进程的基本概念</h2><p>首先，我们先来明确<strong>进程</strong>这个概念。</p><ul><li><strong>程序</strong>（Program）：就是存放在硬盘中的可执行文件，是一系列的指令集合，是<strong>静态</strong>的。</li><li><strong>进程</strong>（Process）：是程序的一次执行过程，是<strong>动态</strong>的。同一个程序多次执行可对应多个进程。</li></ul><p>对于不同进程，操作系统也会为其创造特定的<strong>PID</strong>（Process ID）。PID与分配的资源、运行的情况等信息，共同保存在一个数据结构，<strong>进程控制块</strong>（ <strong>PCB</strong> Process Control Block）。PCB与<strong>程序段</strong>、<strong>数据段</strong>共同构成进程。</p><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/1.png" class="" title="进程的运行"> <h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><ul><li><strong>创建态</strong>：当进程正在被创建时，它的状态就是<strong>创建态</strong>。操作系统会为其分配资源，初始化 PCB。</li><li><strong>就绪态</strong>：处于<strong>就绪态</strong>的进程已经具备运行条件，但由于没有空闲的 CPU ，就暂时不能运行。</li><li><strong>运行态</strong>：如果一个进程此时在 CPU 上运行，那么这个进程处于<strong>运行态</strong>。</li><li><strong>阻塞态</strong>：在进程运行的过程中，可能会请求等待某个事件的发生，如等待某种资源的分配，或者等待其他进程的响应。在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下 CPU ，并让其进入<strong>阻塞态</strong>。</li><li><strong>终止态</strong>：当一个进程请求操作系统终止该进程时，该进程会进入<strong>终止态</strong>，操作系统会回收其所有资源。</li></ul><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/2.png" class="" title="进程的状态"> <h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>这部分我们将讨论 <strong>Unix 系统</strong>的进程创建，首先先介绍一下三个进程的 API：</p><ul><li><strong>fork()</strong>：用来创建新的进程，原来的进程称为<strong>父进程</strong>，新创建的进程称为<strong>子进程</strong>。这两个进程几乎完全相同，但是其 <strong>PID</strong> 不同。</li><li><strong>wait()</strong>：允许父进程等待子进程执行结束。</li><li><strong>exec()</strong>：允许子进程<strong>「偏离」</strong>父进程，执行新的程序。</li></ul><p>下面我们来看一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world (pid:%d)\n"</span>, (<span class="keyword">int</span>) getpid());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> rc = fork();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#123; <span class="comment">// fork 失败并退出</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"fork failed\n"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#123; <span class="comment">// 子进程</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello, I am child (pid:%d)\n"</span>, (<span class="keyword">int</span>) getpid());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">char</span> * myargs[<span class="number">3</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        myargs[<span class="number">0</span>] = strdup(<span class="string">"wc"</span>); <span class="comment">// 新的程序：计算程序行数、词数、字节数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        myargs[<span class="number">1</span>] = strdup(<span class="string">"p3.c"</span>); <span class="comment">// 需要计算的程序</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        myargs[<span class="number">2</span>] = <span class="literal">NULL</span>; <span class="comment">// 标记结束</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        execvp(myargs[<span class="number">0</span>], myargs); <span class="comment">// 执行程序并退出</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"this shouldn’t print out"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> rc_wait = wait(<span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello, I am parent of %d (rc_wait:%d) (pid:%d)\n"</span>, rc, rc_wait, (<span class="keyword">int</span>) getpid());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>对于这个例子，<code>fork()</code>之后，创建子进程，对于父进程来讲<code>rc = 子进程的PID</code>，对于子进程来讲<code>rc = 0</code>，故在子进程执行时，会跳转至其分支，并通过调用<code>execvp()</code>来执行新的程序。</p><p>对于父进程，先调用<code>wait()</code>，以至于先输出子进程结果，不会因为时间片耗尽而提前执行父进程。</p><p>最后输出结果为：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">prompt&gt; ./p3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">hello world (pid:<span class="number">29383</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">hello, I am child (pid:<span class="number">29384</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="number">29</span> <span class="number">107</span> <span class="number">1030</span> p3.c</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">hello, I am parent of <span class="number">29384</span> (rc_wait:<span class="number">29384</span>) (pid:<span class="number">29383</span>)</span></pre></td></tr></table></figure><h2 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h2><p>在计算机运行过程中，通常会有多个进程同时竞争 CPU。因此，计算机要选择运行的程序。完成这项工作的部分称为<strong>调度程序</strong>（Scheduler），该程序使用的算法称为<strong>调度算法</strong>（Scheduling Algorithm）。</p><h3 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h3><p>首先，我们引入假设，以简化调度过程。</p><ul><li>每个任务运行相同时间。</li><li>所有任务同时到达。</li><li>一旦启动，每个任务运行到结束。</li><li>所有任务只使用 CPU。</li><li>已知每个任务的运行时间。</li></ul><p>之后，我们会逐步消除假设，以探讨调度问题。</p><h3 id="评价标准"><a href="#评价标准" class="headerlink" title="评价标准"></a>评价标准</h3><p>我们引入两个评价指标，以评价调度算法的优劣：</p><ul><li><strong>周转时间</strong>（Turnaround Time）：$ T_{turnaround} = T_{completion}-T_{arrival} $</li><li><strong>响应时间</strong>（Response Time）：$T_{response}=T_{firstrun}-T_{arrival}$</li></ul><h3 id="先来先服务（First-In-First-Out-FIFO）"><a href="#先来先服务（First-In-First-Out-FIFO）" class="headerlink" title="先来先服务（First In, First Out, FIFO）"></a>先来先服务（First In, First Out, FIFO）</h3><p>有三个任务A、B、C几乎同时到达（$T_A&lt;T_B&lt;T_C$）。</p><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/3.png" class="" title="FIFO 简单例子"> <p>从上图我们可以看出，A 于 10 结束，B 于 20 结束，C 于 30 结束。因此其平均周转时间为 $\frac{10+20+30}{3}=20$.</p><p>下面，我们舍弃第一条假设（每个任务运行相同时间），还是刚才那三个任务，只不过 A 运行 100 秒，B、C 分别运行 10 秒。</p><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/4.png" class="" title="FIFO 为什么不是最优解"> <p>由此可见，A 任务要整整运行 100 秒，才可以轮到 B 任务。其平均周转时间也高达 $\frac{100+110+120}{3}=110$.</p><p>这种现象称为<strong>车队效应</strong>（Convey effect），有点类似在现实生活中，你在超市排队时，前面的人买了三车食品的样子。</p><h3 id="最短作业优先（Shortest-Job-First-SJF）"><a href="#最短作业优先（Shortest-Job-First-SJF）" class="headerlink" title="最短作业优先（Shortest Job First, SJF）"></a>最短作业优先（Shortest Job First, SJF）</h3><p>之前在宜家购物的时候，有一个专门的购物通道是为小件商品用户提供的，这也是 SJF 调度算法的策略。</p><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/5.png" class="" title="SJF 简单例子"> <p>同样是 A、B、C 几乎同时到达。但是由于 B 任务较 A 任务较短。因此其平均周转时间为 $\frac{10+20+120}{3}=50$.缩短了很多。</p><p>这时，我们舍弃第二条假设（所有任务同时到达）。此时假设 A 任务于 $t =0$ 时刻到达且运行 100 秒，而 B、C 任务于 $t =10$ 时刻到达且运行 10 秒。</p><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/6.png" class="" title="当 B、C 稍晚到达 SJF 调度算法"> <p>此时的平均周转时间为 $\frac{100+(110-20)+(120-10)}{3}=103.33$.</p><h3 id="最短时间完成优先（Shortest-Time-to-Completion-STC）"><a href="#最短时间完成优先（Shortest-Time-to-Completion-STC）" class="headerlink" title="最短时间完成优先（Shortest Time-to-Completion, STC）"></a>最短时间完成优先（Shortest Time-to-Completion, STC）</h3><p>现在我们舍弃第三条假设（一旦启动，每个任务运行到结束），使调度程序成为<strong>抢占型</strong>（Preemptive），可以切换上下文（Context switch），暂停运行任务，转而运行其他任务。因此 STCF 中会抢占 A 任务以让 B、C 任务运行，直到后者运行结束后才会继续运行 A 任务。</p><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/7.png" class="" title="STCF 简单示例"> <p>此时的平均周转时间为 $\frac{(120-0)+(20-10)+(30-10)}{3}=50$.</p><p>由于现代计算机采用时分技术，用户更希望能够与操作系统发生交互。因此<strong>响应时间</strong>也是衡量调度算法的关键。上述例子中，A 的响应时间为 0，B 为 0，C 为 10，平均响应时间为$\frac{0+0+10}{3}=3.33$.</p><p>但是三个任务同时到达时，那么第三个任务需要等待很长时间才可以得到响应。</p><h3 id="时间片轮转（Round-Robin）"><a href="#时间片轮转（Round-Robin）" class="headerlink" title="时间片轮转（Round Robin）"></a>时间片轮转（Round Robin）</h3><p>不同于之前每个任务都要完成，RR 则只在一个<strong>时间片</strong>（Time slice）中运行任务，然后会切换到下一个任务，如此往复直到任务全部完成。</p><p>假设三个任务同时到达，每个运行 5 秒，时间片为 1 秒。</p><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/8.png" class=""> <p>对于 RR，其平均响应时间为 $\frac{0+1+2}{3}=1$.而 SJF 则为 $\frac{0+5+10}{3}=5$.</p><p>时间片长短对于 RR 来说非常关键，时间片越短，其响应越快；相应的，上下文切换的消耗会主导其整体性能。</p><p>RR 有着很好的响应速度，但是对于平均周转时间来说，表现并不是那么出色。$\frac{13+14+15}{3}=14$.</p><h3 id="I-O交互"><a href="#I-O交互" class="headerlink" title="I/O交互"></a>I/O交互</h3><p>现在，我们舍弃第四个假设（所有任务只使用 CPU）。当一个运行中的任务发起 I/O 请求时，CPU 会处于空转，等待 I/O 完成。因此，调度程序可以在这段时间内将 CPU 交给下一个任务，等待 I/O 完成后，发起中断。</p><p>假设 A、B 任务都在 CPU 上运行 50ms，但 A 任务每运行 10ms 时，会发起一次 I/O 请求。下图为两种不同的调度算法。</p><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/9.png" class=""> <p>A 任务会分成 5 个 10ms 的子任务。我们可以把子任务当作独立的任务，当系统开始运行时，有 10ms A 与 50ms B，采用 STCF 调度，毫无疑问选择 A 任务。当第一个子任务完成时，CPU 上只剩下 B 任务，因此开始运行。当新的子任务提交后，A 会抢占 B运行 10ms。由此会产生交叠（Overlap），使 CPU 利用率最大化。</p><h2 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h2><p>在上一节中，我们还留下了最后一个假设：已知每个任务的运行时间。显然在实际情况中我们并不知道每个任务的具体运行时间。这就带来了我们本节的内容：<strong>多级反馈队列</strong>（Multi-level Feed-back Queue, MLFQ）。</p><h3 id="基本准则"><a href="#基本准则" class="headerlink" title="基本准则"></a>基本准则</h3><p>MLFQ 有很多独立的<strong>队列</strong>（queue），每个队列都有不同的<strong>优先级</strong>（priority level）。每个任务在各自的队列运行，有高优先级的任务优先运行。由此，带来两个准则：</p><ul><li>如果 A 的优先级大于 B，那么只有 A 运行。</li><li>如果 A、B 优先级相同，则 A、B 采取 RR 运行。</li></ul><p>因此，如何确定每个任务的优先级成为关键。</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>每个任务的优先级应当取决于其表现，对于时刻「霸占」 CPU 的长任务，应当降低其优先级，而对于「主动放弃」CPU 的交互任务，我们应当给予它一定特权。由此，得出下面准则：</p><ul><li>当一个任务进入系统时，将其放置在最高优先级（第一队列）。</li><li>如果一个任务耗尽其时间片，降低其优先级；如果一个任务在耗尽时间片前放弃 CPU，保持在当前优先级。</li></ul><h4 id="长任务和短任务"><a href="#长任务和短任务" class="headerlink" title="长任务和短任务"></a>长任务和短任务</h4><p>我们看一个例子：A 任务为长任务，B 任务为短任务。在 A 运行一段时间后，B 任务到达（$T=100$），时间片为 20ms。</p><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/10.png" class=""> <p>由于我们并不知道每个任务的具体运行时间，所以当一个任务到达时，我们先假设它是短任务，于是赋予它最高优先级。如果它真是短任务，那么它会很快结束；如果它不是短任务，那么会降低其优先级。在这个模式下，MLFQ 近似 SJF。</p><h4 id="I-O-交互"><a href="#I-O-交互" class="headerlink" title="I/O 交互"></a>I/O 交互</h4><p>我们再来看看有 I/O 交互的例子。B 任务使用 CPU 1ms 后会进行 I/O 操作。因此在时间片结束之前主动放弃 CPU 的任务会保持在当前优先级。</p><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/11.png" class=""> <h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><p>我们的方案看似完美，但是也存在不少问题：</p><p>首先，可能会导致<strong>饥饿</strong>（starvation），如果系统中有太多交互任务，那么它们会一直「霸占」 CPU，长任务无法获得 CPU。</p><p>其次，一些恶意程序会<strong>钻调用程序的空子</strong>（ game the scheduler）：在时间片结束前，该任务主动放弃 CPU 进行 I/O 请求，因此它会保持在较高优先级，占用大量 CPU 时间。</p><p>最后，如果一个任务总是改变其状态，长任务可能会变为短任务。</p><h3 id="提升优先级"><a href="#提升优先级" class="headerlink" title="提升优先级"></a>提升优先级</h3><p>为解决饥饿问题，我们可以采用<strong>提升优先级</strong>（boost the priority）的方案：</p><ul><li>在一段时间 $S$ 后，将所有任务提升到系统第一队列。</li></ul><p>新准则解决了两个问题，一是所有进程都不会饥饿，每个任务都有机会处于同一优先级。二是解决了任务状态改变的问题。</p><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/12.png" class=""> <p>左图为没有提升优先级的方案，右图中每 50ms 提升一次优先级。</p><h3 id="更好的计时方式"><a href="#更好的计时方式" class="headerlink" title="更好的计时方式"></a>更好的计时方式</h3><p>我们还剩下最后一个问题：如何避免恶意程序的欺骗。解决方式是使用更好的 CPU 时间计算方案。一旦任务运行完它的时间份额，就会降低其优先级，取代运行时间片的方案：</p><ul><li>一旦任务消耗完其时间份额（而非放弃 CPU 的次数），就会降低它的优先级。</li></ul><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/13.png" class=""> <p>在保护机制下，交互任务也会逐步降低其优先级。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章开始介绍操作系统的第一个特性<strong>虚拟化</strong>，先介绍<strong>进程</strong>的相关概念。接着介绍了进程调度的相关知识。</p><p>下一章将为大家带来<strong>内存管理</strong>的相关知识，看看内存是如何虚拟化的。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://book.douban.com/subject/33463930/" target="_blank" rel="noopener">雷姆兹·H.阿帕希杜塞尔 / 安德莉亚·C.阿帕希杜塞尔 - 操作系统导论</a></li><li><a href="https://www.bilibili.com/video/av70156862/" target="_blank" rel="noopener">王道考研 - 操作系统</a></li><li><a href="https://book.douban.com/subject/27096665/" target="_blank" rel="noopener">Andrew S. Tanenbaum / Herbert Bos - 现代操作系统（原书第4版）</a></li><li><a href="https://time.geekbang.org/column/intro/100024701" target="_blank" rel="noopener">刘超 - 趣谈Linux操作系统</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一章我们介绍了操作系统的基本概念以及特性，补充了些在&lt;strong&gt;组成原理&lt;/strong&gt;中未涉及的内容。&lt;/p&gt;
&lt;p&gt;接下来两章我们会从&lt;strong&gt;虚拟性&lt;/strong&gt;出发，去分别介绍&lt;strong&gt;进程&lt;/strong&gt;（ CPU 虚拟）和&lt;strong&gt;内存管理&lt;/strong&gt;（内存虚拟）。这一章先介绍进程的基本概念以及进程的&lt;strong&gt;调度算法&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>1 操作系统概述</title>
    <link href="http://yoursite.com/2020/02/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2020/02/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</id>
    <published>2020-02-06T05:53:53.000Z</published>
    <updated>2020-02-07T06:40:00.483Z</updated>
    
    <content type="html"><![CDATA[<p>之前我们介绍了计算机的<strong>组成原理</strong>，从今天开始，我们要开始介绍计算机的<strong>操作系统</strong>。操作系统作为用户与硬件之间最重要的枢纽，有着非常重要的意义。</p><p>本章将带来操作系统的基本概念、功能特性、发展历史以及体系结构，也会补充些硬件方面的知识，完善知识结构。</p><a id="more"></a><h2 id="操作系统的基本概念"><a href="#操作系统的基本概念" class="headerlink" title="操作系统的基本概念"></a>操作系统的基本概念</h2><p>之前我们了解过、计算机由处理器、内存、磁盘、输入输出等设备组成。而我们现在操作这些硬件以实现某些功能的时候，并不需要去掌握其底层逻辑。这是因为<strong>操作系统</strong>为用户程序提供了一个更简洁、更清晰的计算机模型，并且管理硬件部分。</p><p>目前，计算机有两种运行模式：</p><ul><li><strong>内核态</strong>：操作系统运行于此，在这个模式下，操作系统拥有对所有硬件的完全访问权。</li><li><p><strong>用户态</strong>：软件的其余部分均运行于此。</p><ul><li>用户接口程序：shell（基于文本），图形用户界面（GUI）。</li></ul><img src="/2020/02/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/1.png" class="" title="操作系统所处的位置"> </li></ul><p>下面我们以应用程序的实际例子，来介绍下操作系统对硬件资源管理的功能：</p><ul><li><strong>文件管理</strong>：打开文件夹，找到可执行文件存放的位置。</li><li><strong>存储器管理</strong>：把程序相关数据加载到内存中。</li><li><strong>处理器管理</strong>：CPU处理对应进程。</li><li><strong>设备管理</strong>：将键盘、显示器等设备分配给该程序。</li></ul><p>接下来的几章也会围绕以上功能展开。</p><h2 id="操作系统的发展"><a href="#操作系统的发展" class="headerlink" title="操作系统的发展"></a>操作系统的发展</h2><ul><li><strong>手工操作阶段</strong>：早期的计算机程序要使用打孔卡来运作，需要人工放入打孔卡来交给计算机去执行。</li><li><strong>批处理阶段</strong><ul><li>单道批处理系统：单周期处理器。</li><li>多道批处理系统：流水线处理器。</li></ul></li><li><strong>分时操作系统</strong>：计算机以<strong>时间片</strong>为单位<strong>轮流</strong>为各个用户、作业服务，各个用户可通过终端与计算机进行交互。</li><li><strong>实时操作系统</strong>：在前者的基础上更能优先处理某些紧急任务。</li><li>网络操作系统</li><li>分布式操作系统</li><li>个人计算机操作系统</li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><strong>异常</strong>（Exception）其实是一个硬件和软件组合到一起的处理过程。当处理器检测到有事件发生时，会通过<strong>异常表</strong>(Exception Table)来确定跳转的位置，到一个专门处理这类事件的操作系统子程序（异常处理程序）。当异常处理程序完成处理后，根据引起异常事件的类型，发生以下三种情况中的一种：</p><ul><li>返回当前指令。</li><li>返回下一条指令。</li><li><p>终止。</p> </li></ul><h3 id="异步异常（中断）"><a href="#异步异常（中断）" class="headerlink" title="异步异常（中断）"></a>异步异常（中断）</h3><p><strong>异步异常</strong>(Asynchronous Exception)称之为<strong>中断</strong>(Interrupt)，是由处理器外面发生的事情引起的。对于执行程序来说，这种“中断”的发生完全是异步的，因为不知道什么时候会发生，CPU对其的响应也完全是被动的。例如：</p><ul><li><strong>计时器中断</strong>：计时器中断是由计时器芯片每隔几毫秒触发的，内核用计时器终端来从用户程序手上拿回控制权。</li><li><strong>I/O 中断</strong>：I/O 中断类型比较多样，比方说键盘输入了 ctrl-c，网络中一个包接收完毕，都会触发这样的中断。</li></ul><h3 id="同步异常"><a href="#同步异常" class="headerlink" title="同步异常"></a>同步异常</h3><p><strong>同步异常</strong>(Synchronous Exception)是因为执行某条指令所导致的事件，分为<strong>陷阱</strong>(Trap)、<strong>故障</strong>(Fault)和<strong>终止</strong>(Abort)三种情况。</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">原因</th><th style="text-align:center">示例</th><th style="text-align:center">触发时机</th><th style="text-align:center">处理后操作</th></tr></thead><tbody><tr><td style="text-align:center">中断</td><td style="text-align:center">I/O设备信号</td><td style="text-align:center">用户键盘输入</td><td style="text-align:center">异步</td><td style="text-align:center">下一条指令</td></tr><tr><td style="text-align:center">陷阱</td><td style="text-align:center">程序刻意触发</td><td style="text-align:center">程序进行系统调用</td><td style="text-align:center">同步</td><td style="text-align:center">下一条指令</td></tr><tr><td style="text-align:center">故障</td><td style="text-align:center">程序执行出错</td><td style="text-align:center">程序加载时缺页</td><td style="text-align:center">同步</td><td style="text-align:center">当前指令</td></tr><tr><td style="text-align:center">中止</td><td style="text-align:center">故障无法恢复</td><td style="text-align:center">整数除零</td><td style="text-align:center">同步</td><td style="text-align:center">退出程序</td></tr></tbody></table></div><h2 id="操作系统的基本特征"><a href="#操作系统的基本特征" class="headerlink" title="操作系统的基本特征"></a>操作系统的基本特征</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ul><li><strong>并发</strong>：指的是两个或多个事件在同一时间间隔内发生。这些事件在宏观上是同时发生的，但在微观上是交替发生的。</li><li><strong>并行</strong>：指的是两个或多个事件在同一时刻同时发生。</li></ul><p>例如：我们可以边写作业边听歌，这是并行。也可以写一会儿作业听一会儿歌，只要我们做事情足够快，就会在宏观上看起来同时发生。</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p><strong>异步</strong>：在多通道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p><p>例如：我们有时候会在特定时间间隔内写完作业，以至于我们听歌并不能一贯到底。</p><h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><p><strong>虚拟</strong>：把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p><p>例如：</p><ul><li>CPU 的<strong>时分复用技术</strong>，使得在用户看来有多个 CPU 为自己服务。</li><li>内存的<strong>空分复用技术</strong>，虚拟内存</li></ul><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p><strong>共享</strong>：资源共享，指系统中的资源可供内存中多个并发执行的进程共同使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章由计算机组成过渡到了计算机操作系统，重点为大家介绍了操作系统的特征和异常。接下来几章也会围绕上述内容展开。</p><p>下一章将为大家带来<strong>进程与线程</strong>的知识，带大家看看 CPU 是如何分配和调度自己的资源的。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://www.bilibili.com/video/av70156862/" target="_blank" rel="noopener">王道考研 - 操作系统</a></li><li><a href="https://time.geekbang.org/column/intro/100026001" target="_blank" rel="noopener">徐文浩 - 深入浅出计算机组成原理</a></li><li><a href="https://wdxtub.com/csapp/thin-csapp-5/2016/04/16/" target="_blank" rel="noopener">小土刀 - 【读薄 CSAPP】伍 异常控制流</a></li><li><a href="https://book.douban.com/subject/27096665/" target="_blank" rel="noopener">Andrew S. Tanenbaum / Herbert Bos - 现代操作系统（原书第4版）</a></li><li><a href="https://book.douban.com/subject/26912767/" target="_blank" rel="noopener">Randal E.Bryant / David O’Hallaron - 深入理解计算机系统（原书第3版）</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前我们介绍了计算机的&lt;strong&gt;组成原理&lt;/strong&gt;，从今天开始，我们要开始介绍计算机的&lt;strong&gt;操作系统&lt;/strong&gt;。操作系统作为用户与硬件之间最重要的枢纽，有着非常重要的意义。&lt;/p&gt;
&lt;p&gt;本章将带来操作系统的基本概念、功能特性、发展历史以及体系结构，也会补充些硬件方面的知识，完善知识结构。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>5 存储器</title>
    <link href="http://yoursite.com/2020/02/03/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%20%E5%86%85%E5%AD%98/"/>
    <id>http://yoursite.com/2020/02/03/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%20%E5%86%85%E5%AD%98/</id>
    <published>2020-02-03T05:53:53.000Z</published>
    <updated>2020-02-04T08:35:34.605Z</updated>
    
    <content type="html"><![CDATA[<p>上一章我们介绍计算机中<strong>流水线指令系统设计</strong>，介绍一下计算机如何<strong>「更快」</strong>地执行，也会介绍如何去解决流水线处理器中的<strong>冒险</strong>。</p><p>这一章会为大家介绍计算机中各式各样的<strong>存储器</strong>，重点介绍<strong>高速缓存</strong>的工作原理。</p><a id="more"></a><h2 id="存储层次结构概况"><a href="#存储层次结构概况" class="headerlink" title="存储层次结构概况"></a>存储层次结构概况</h2><p>我们先把计算机的存储器层次结构和我们日常生活里处理信息、阅读书籍做个对照，好让你更容易理解、记忆存储器的层次结构。</p><p>我们常常把 CPU 比喻成计算机的「大脑」。我们思考的东西，就好比 CPU 中的<strong>寄存器</strong>（Register）。寄存器与其说是存储器，其实它更像是 CPU 本身的一部分，只能存放极其有限的信息，但是速度非常快，和 CPU 同步。而我们大脑中的记忆，就好比 <strong>CPU Cache</strong>（CPU 高速缓存，我们常常简称为<strong>缓存</strong>）。<strong>CPU Cache </strong>用的是一种叫作 <strong>SRAM</strong>（Static Random-Access Memory，静态随机存取存储器）的芯片。</p><h3 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h3><p>在 CPU 里，通常会有 L1、L2、L3 这样三层高速缓存。每个 CPU 核心都有一块属于自己的 L1 高速缓存，通常分成<strong>指令缓存</strong>和<strong>数据缓存</strong>，分开存放 CPU 使用的指令和数据。</p><p>L2 的 Cache 同样是每个 CPU 核心都有的，不过它往往不在 CPU 核心的内部。所以，L2 Cache 的访问速度会比 L1 稍微慢一些。而 L3 Cache，则通常是多个 CPU 核心共用的，尺寸会更大一些，访问速度自然也就更慢一些。</p><p>你可以把 CPU 中的 L1 Cache 理解为我们的<strong>短期记忆</strong>，把 L2/L3 Cache 理解成<strong>长期记忆</strong>，把内存当成我们拥有的<strong>书架</strong>。 当我们自己记忆中没有资料的时候，可以从书架上拿书来翻阅。这个过程中就相当于，数据从内存中加载到 CPU 的寄存器和 Cache 中，然后通过「大脑」，也就是 CPU，进行处理和运算。</p><h3 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h3><p>内存用的芯片和 Cache 有所不同，它用的是一种叫作 <strong>DRAM</strong>（Dynamic Random Access Memory，动态随机存取存储器）的芯片，比起 SRAM 来说，它的密度更高，有更大的容量，而且它也比 SRAM 芯片便宜不少。</p><p>因为数据是存储在电容里的，电容会不断漏电，所以需要定时刷新充电，才能保持数据不丢失。DRAM 的数据访问电路和刷新电路都比 SRAM 更复杂，所以访问延时也就更长。</p><img src="/2020/02/03/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%20%E5%86%85%E5%AD%98/1.png" class=""> <p>各个存储器只和相邻的一层存储器打交道，并且随着一层层向下，存储器的容量逐层增大，访问速度逐层变慢，而单位存储成本也逐层下降，也就构成了我们日常所说的存储器层次结构。</p><img src="/2020/02/03/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%20%E5%86%85%E5%AD%98/2.png" class="" title="存储器的层次关系图"> <h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><p>性能和价格的巨大差异，给我们工程师带来了一个挑战：我们能不能既享受 CPU Cache 的速度，又享受内存、硬盘巨大的容量和低廉的价格呢？</p><p>存储器中数据的<strong>局部性原理</strong>（Principle of Locality）。我们可以利用这个局部性原理，来制定管理和访问数据的策略。这个局部性原理包括<strong>时间局部性</strong>（temporal locality）和<strong>空间局部性</strong>（spatial locality）这两种策略。</p><h3 id="时间局部性"><a href="#时间局部性" class="headerlink" title="时间局部性"></a>时间局部性</h3><p>我们先来看时间局部性。这个策略是说，如果一个数据被访问了，那么它在短时间内还会被再次访问。</p><p>比如说，「哈利波特与魔法石」这本小说，我今天读了一会儿，没读完，明天还会继续读。同理，在一个电子商务型系统中，如果一个用户打开了 App，看到了首屏。我们推断他应该很快还会再次访问网站的其他内容或者页面，我们就将这个用户的个人信息，从存储在硬盘的数据库读取到内存的缓存中来。这利用的就是时间局部性。</p><img src="/2020/02/03/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%20%E5%86%85%E5%AD%98/3.png" class="" title="时间局部性"> <h3 id="空间局部性"><a href="#空间局部性" class="headerlink" title="空间局部性"></a>空间局部性</h3><p>我们再来看空间局部性。这个策略是说，如果一个数据被访问了，那么和它相邻的数据也很快会被访问。</p><p>我们还拿刚才读「哈利波特与魔法石」的例子来说。我读完了这本书之后，感觉这书不错，所以就会借阅整套「哈利波特」。这就好比我们的程序，在访问了数组的首项之后，多半会循环访问它的下一项。因为，在存储数据的时候，数组内的多项数据会存储在相邻的位置。这就好比图书馆会把「哈利波特」系列放在一个书架上，摆放在一起，加载的时候，也会一并加载。我们去图书馆借书，往往会一次性把 7 本都借回来。</p><img src="/2020/02/03/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%20%E5%86%85%E5%AD%98/4.png" class="" title="空间局部性"> <h2 id="高速缓存的工作原理"><a href="#高速缓存的工作原理" class="headerlink" title="高速缓存的工作原理"></a>高速缓存的工作原理</h2><p>现代 CPU 进行数据读取的时候，无论数据是否已经存储在 Cache 中，CPU 始终会首先访问 Cache。只有当 CPU 在 Cache 中找不到数据的时候，才会去访问内存，并将读取到的数据写入 Cache 之中。当时间局部性原理起作用后，这个最近刚刚被访问的数据，会很快再次被访问。而 Cache 的访问速度远远快于内存，这样，CPU 花在等待内存访问上的时间就大大变短了。</p><p>我就从最基本的<strong>直接映射</strong> Cache（Direct Mapped Cache）为例，来看看整个 Cache 的数据结构和访问逻辑。</p><p>直接映射 Cache 采用的策略，就是确保任何一个<strong>内存块</strong>（Block）的地址，始终映射到一个固定的 CPU Cache 地址（Cache Line）。而这个映射关系，通常用 mod 运算（求余运算）来实现。</p><img src="/2020/02/03/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%20%E5%86%85%E5%AD%98/5.png" class="" title="Cache 采用 mod 的方式，把内存块映射到对应的 CPU Cache 中"> <p>实际计算中，有一个小小的技巧，通常我们会把缓存块的数量设置成 2 的 N 次方。这样在计算取模的时候，可以直接取地址的低 N 位，也就是二进制里面的后几位。比如这里的 8 个缓存块，就是 2 的 3 次方。那么，在对 21 取模的时候，可以对 21 的 2 进制表示 10101 取地址的低三位，也就是 101，对应的 5，就是对应的缓存块地址。</p><img src="/2020/02/03/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%20%E5%86%85%E5%AD%98/6.png" class=""> <p>因此，当处理器需要访问一个地址时，会先在高速缓冲存储器中进行查找，查找过程中我们首先在概念上把这个地址划分成三个部分：</p><img src="/2020/02/03/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%20%E5%86%85%E5%AD%98/7.jpg" class=""> <h3 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h3><p>在<strong>直接映射</strong>中，因为每个 set 对应 1 个 line，所以 set index 的位数就会较多（和之后的多路映射对比）。具体的检索过程就是先通过 set index 确定哪个 set，然后看是否 valid，然后比较那个 set 里唯一 line 的 tag 和地址的 t bits 是否一致，就可以确定是否缓存命中。命中之后根据 block offset 确定偏移量。如果 tag 不匹配的话，这行会被扔掉并放新的数据进来。</p><img src="/2020/02/03/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%20%E5%86%85%E5%AD%98/8.jpg" class=""> <p>对于 4 位地址，对应 Block = 2，Set = 4，Line = 1 </p><ul><li><code>0 00 0</code>, miss</li><li><code>0 00 1</code>, hit</li><li><code>0 11 1</code>, miss</li><li><code>1 00 0</code>, miss</li><li><code>0 00 0</code>, miss</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">       v  Tag   Block</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Set 0  1   0    M[0-1]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Set 1  x   x      x</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">Set 2  x   x      x</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">Set 3  1   0    M[6-7]</span></pre></td></tr></table></figure><p>缓存的大小如图所示，对应就是有 4 个 set，所以需要 2 位的 set index，所以进行读入的时候，会根据中间两位来确定在哪个 set 中查找，其中 8 和 0，因为中间两位相同，会产生冲突，导致连续 miss，这个问题可以用多路映射来解决。</p><h3 id="多路映射"><a href="#多路映射" class="headerlink" title="多路映射"></a>多路映射</h3><p>当每个 set 有 E 个 line 的时候，称之为 E 路联结缓存。</p><p>假设每个 set 有 2 个 line，所以就没有那么多 set，也就是说 set index 可以少一位（集合数量少一倍），tag 多一位。</p><p>我们再用刚才的例子来看看是否会增加命中率，对应 Block = 2, Set = 2, Line = 2，我们按照如下顺序进行数据读取：</p><ul><li><code>00 0 0</code>, miss</li><li><code>00 0 1</code>, hit</li><li><code>01 1 1</code>, miss</li><li><code>10 0 0</code>, miss</li><li><code>00 0 0</code>, miss</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">       v   Tag   Block</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Set 0  1   00    M[0-1]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Set 0  1   10    M[8-9]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">Set 1  1   01    M[6-7]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">Set 1  0   x     x</span></pre></td></tr></table></figure><p>可以看到因为每个 set 有 2 个 line，所以只有 2 个 set，set index 也只需要 1 位了，这个情况下即使 8 和 0 的 set index 一致，因为一个 set 可以容纳两个数据，所以最后一次访问 0，就不会 miss 了。</p><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>如果发生写入命中的时候（也就是要写入的地址在缓存中有），有两种策略：</p><ul><li><strong>写直达</strong>（Write-through）: 命中后更新缓存，同时写入到内存中</li><li><strong>写回</strong>（Write-back）: 直到这个缓存需要被置换出去，才写入到内存中（需要额外的 dirty bit 来表示缓存中的数据是否和内存中相同，因为可能在其他的时候内存中对应地址的数据已经更新，那么重复写入就会导致原有数据丢失）</li></ul><p>在写入 miss 的时候，同样有两种方式：</p><ul><li><strong>写分配</strong>（Write-allocate）: 载入到缓存中，并更新缓存（如果之后还需要对其操作，这个方式就比较好）</li><li><strong>写不分配</strong>（No-write-allocate）: 直接写入到内存中，不载入到缓存</li></ul><p>这四种策略通常的搭配是：</p><ul><li>Write-through + No-write-allocate</li><li>Write-back + Write-allocate</li></ul><p>其中第一种可以保证绝对的数据一致性，第二种效率会比较高（通常情况下）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章为大家介绍计算机中<strong>存储器框架结构</strong>，重点介绍了<strong>高速缓存的工作原理</strong>。</p><p>到目前为止，计算机组成原理的重点知识就介绍的差不多了，接下来我们就要开始更新操作系统的相关知识了。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://time.geekbang.org/column/intro/100026001" target="_blank" rel="noopener">徐文浩 - 深入浅出计算机组成原理</a></li><li><a href="http://www.chinesemooc.org/mooc/4392" target="_blank" rel="noopener">陆俊林- 计算机组成</a></li><li><a href="https://book.douban.com/subject/26604008/" target="_blank" rel="noopener">戴维 A.帕特森 (David A.Patterson) / 约翰 L.亨尼斯 (John L.Hennessy) - 计算机组成与设计：硬件/软件接口（原书第5版）</a></li><li><a href="https://wdxtub.com/csapp/thin-csapp-3/2016/04/16/" target="_blank" rel="noopener">小土刀 - 【读薄 CSAPP】叁 内存与缓存</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一章我们介绍计算机中&lt;strong&gt;流水线指令系统设计&lt;/strong&gt;，介绍一下计算机如何&lt;strong&gt;「更快」&lt;/strong&gt;地执行，也会介绍如何去解决流水线处理器中的&lt;strong&gt;冒险&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这一章会为大家介绍计算机中各式各样的&lt;strong&gt;存储器&lt;/strong&gt;，重点介绍&lt;strong&gt;高速缓存&lt;/strong&gt;的工作原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="组成原理" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="组成原理" scheme="http://yoursite.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>4 流水线指令设计</title>
    <link href="http://yoursite.com/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
    <id>http://yoursite.com/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/</id>
    <published>2020-02-02T05:53:53.000Z</published>
    <updated>2020-02-04T06:18:06.439Z</updated>
    
    <content type="html"><![CDATA[<p>上一章我们计算机中的指令系统，重点介绍了传送指令、流程控制和过程调用，了解了在高级语言如何转化为汇编语言来指导计算机工作。</p><p>这一章会为大家介绍计算机中<strong>流水线指令系统设计</strong>，介绍一下计算机如何<strong>「更快」</strong>地执行，也会介绍如何去解决流水线处理器中的<strong>冒险</strong>。</p><a id="more"></a><h2 id="单周期处理器"><a href="#单周期处理器" class="headerlink" title="单周期处理器"></a>单周期处理器</h2><p>首先，我们先介绍一下几个概念。</p><h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><ol><li><strong>取指</strong>（Fetch）<ul><li>从 PC 寄存器里找到对应的指令地址，根据指令地址从内存里把具体的指令，加载到指令寄存器中，然后把 PC 寄存器自增，好在未来执行下一条指令。</li></ul></li><li><strong>译码</strong>（Decode）<ul><li>根据指令寄存器里面的指令，解析成要进行什么样的操作，是 R、I、J 中的哪一种指令，具体要操作哪些寄存器、数据或者内存地址。</li></ul></li><li><strong>执行</strong>（Execute）<ul><li>实际运行对应的 R、I、J 这些特定的指令，进行算术逻辑操作、数据传输或者直接的地址跳转。</li></ul></li><li><strong>回写</strong>（Write-back）<ul><li>将运算结果写入通用寄存器或存储器</li></ul></li></ol><img src="/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/1.jpeg" class="" title="不同步骤在不同组件之内完成"> <p>样的步骤，其实就是一个永不停歇的循环，我们把这个循环称之为<strong>指令周期</strong>（Instruction Cycle）。</p><h3 id="机器周期"><a href="#机器周期" class="headerlink" title="机器周期"></a>机器周期</h3><p>例如，取指令、读写存储器等，这每一项工作称为一个基本操作。完成一个基本操作所需要的时间称为<strong>机器周期</strong>（Machine Cycle）或<strong>CPU周期</strong>。</p><h3 id="时钟周期"><a href="#时钟周期" class="headerlink" title="时钟周期"></a>时钟周期</h3><p><strong>时钟周期</strong>也称为振荡周期，定义为时钟频率的倒数。时钟周期是计算机中最基本的、最小的时间单位。在一个时钟周期内，CPU仅完成一个最基本的动作。</p><p>一个 CPU 周期，通常会由几个时钟周期累积起来。一个 CPU 周期的时间，就是这几个时钟周期的总和。对于一个指令周期来说，我们取出一条指令，然后执行它，至少需要两个 CPU 周期。取出指令至少需要一个 CPU 周期，执行至少也需要一个 CPU 周期，复杂的指令则需要更多的 CPU 周期。</p><img src="/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/2.jpeg" class="" title="三个周期（Cycle）之间的关系"> <h2 id="流水线概述"><a href="#流水线概述" class="headerlink" title="流水线概述"></a>流水线概述</h2><h3 id="单周期处理的局限"><a href="#单周期处理的局限" class="headerlink" title="单周期处理的局限"></a>单周期处理的局限</h3><p>对于单指令周期处理器（Single Cycle Processor）而言，在一个时钟周期内，处理器正好能处理一条指令。不过，我们的时钟周期是固定的，但是指令的电路复杂程度是不同的，随着门电路层数的增加，由于门延迟的存在，位数多、计算复杂的指令需要的执行时间会更长，所以<strong>实际一条指令执行的时间是不同的</strong>。</p><p>不同指令的执行时间不同，但是我们需要让所有指令都在一个时钟周期内完成，那就只好把时钟周期和执行时间最长的那个指令设成一样。这就好比学校体育课 1000 米考试，我们要给这场考试预留的时间，肯定得和跑得最慢的那个同学一样。因为就算其他同学先跑完，也要等最慢的同学跑完间，我们才能进行下一项活动。</p><img src="/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/3.jpeg" class="" title="单周期处理器的指令周期"> <h3 id="流水线的基本原理"><a href="#流水线的基本原理" class="headerlink" title="流水线的基本原理"></a>流水线的基本原理</h3><p>我们对于不同的指令步骤，所用的电路模块也是不同。因此我们可以让每一个阶段的电路在完成对应的任务之后，也不需要等待整个指令执行完成，而是可以直接执行下一条指令的对应阶段。这样的协作模式，就是我们所说的<strong>流水线</strong>。这里面每一个独立的步骤，我们就称之为<strong>流水线阶段</strong>或者流水线级（Pipeline Stage）。</p><img src="/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/4.jpeg" class="" title="流水线执行示意图"> <p>流水线中的各个处理部件可并行工作，从而可使<strong>整个程序</strong>的执行时间缩短，但并不会缩短单条指令的执行时间，甚至会增加时间（流水线寄存器），而是提高了<strong>CPU的吞吐率</strong>。</p><h3 id="超长流水线的性能瓶颈"><a href="#超长流水线的性能瓶颈" class="headerlink" title="超长流水线的性能瓶颈"></a>超长流水线的性能瓶颈</h3><p>对于较为复杂的指令，我们可将其拆分成更多的步骤，分为更多的流水线阶段，提高CPU的<strong>吞吐率</strong>。但是增加流水线的深度，会导致性能成本的问题。</p><p>时钟周期的衡量，不再是指令级别的，而是<strong>流水线阶段</strong>级别的。每一级流水线对应的输出，都要放到<strong>流水线寄存器</strong>（Pipeline Register）里面，然后在下一个时钟周期，交给下一个<strong>流水线阶段</strong>去处理。所以，每增加一级的流水线，就要多一级写入到流水线寄存器的操作。虽然流水线寄存器非常快，比如只有 20 ps。</p><p>但是，如果我们不断加深流水线，这些操作占整个指令的执行时间的比例就会不断增加。最后，我们的性能瓶颈就会出现在这些单条指令的延迟上。这也就意味着，单纯地增加流水线级数，不仅不能提升性能，反而会有更多的无谓损失。所以，设计合理的流水线级数也是现代 CPU 中非常重要的一点。</p><img src="/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/5.jpeg" class=""> <h2 id="流水线的「冒险」"><a href="#流水线的「冒险」" class="headerlink" title="流水线的「冒险」"></a>流水线的「冒险」</h2><p>流水线优质这样一种情况，在下一个时钟周期中下一条指令不能执行。这种情况称为<strong>冒险</strong>（Hazard）。下面我们介绍三种流水线冒险。</p><h3 id="结构冒险"><a href="#结构冒险" class="headerlink" title="结构冒险"></a>结构冒险</h3><p><strong>结构冒险</strong>（structural hazard）本质上是一个硬件层面的资源竞争问题。即硬件不支持多条指令在同一时钟周期执行。</p><p>例如流水线结构只有一个存储器，因此只能在一个时钟周期里面读取一条数据，没办法同时执行第 1 条指令的读取内存数据和第 4 条指令的读取指令代码。</p><img src="/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/6.jpeg" class=""> <h4 id="增加资源"><a href="#增加资源" class="headerlink" title="增加资源"></a>增加资源</h4><p>解决方案的本质就是<strong>增加资源</strong>。对于访问内存数据和取指令的冲突，一个直观的解决方案就是把我们的内存分成两部分，让它们各有各的地址译码器。这两部分分别是存放指令的<strong>程序内存</strong>和存放数据的<strong>数据内存</strong>。</p><p>这样把内存拆成两部分的解决方案，在计算机体系结构里叫作<strong>哈佛架构</strong>（Harvard Architecture），来自哈佛大学设计Mark I 型计算机时候的设计。对应的，我们之前说的<strong>冯·诺依曼体系结构</strong>，又叫作普林斯顿架构（Princeton Architecture）。</p><p>不过，我们今天使用的 CPU，仍然是冯·诺依曼体系结构的，并没有把内存拆成程序内存和数据内存这两部分。因为如果那样拆的话，对程序指令和数据需要的内存空间，我们就没有办法根据实际的应用去动态分配了。虽然解决了资源冲突的问题，但是也失去了灵活性。</p><img src="/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/7.jpeg" class=""> <p>不过，借鉴了哈佛结构的思路，现代的 CPU 虽然没有在内存层面进行对应的拆分，却在 CPU 内部的高速缓存部分进行了区分，把高速缓存分成了<strong>指令缓存</strong>（Instruction Cache）和<strong>数据缓存</strong>（Data Cache）两部分。这个我们之后会介绍。</p><h3 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h3><p><strong>数据冒险</strong>（data hazard）发生在由于一条指令必须等待另一条指令的完成而造成流水线暂停的情况。</p><p>下面我们以两条先后发生的 ADD 指令作为例子，来具体阐述一下：</p><h4 id="流水线停顿"><a href="#流水线停顿" class="headerlink" title="流水线停顿"></a>流水线停顿</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">add $t0, $s2,$s1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">add $s2, $s1,$t0</span></pre></td></tr></table></figure><ul><li>把 s1 和 s2 寄存器里面的数据相加，存入到 t0 这个寄存器里面。</li><li>把 s1 和 t0 寄存器里面的数据相加，存入到 s2 这个寄存器里面。</li></ul><p>因为后一条的 add 指令，依赖寄存器 t0 里的值。而 t0 里面的值，又来自于前一条指令的计算结果。所以后一条指令，需要等待前一条指令的数据写回阶段完成之后，才能执行。</p><p>于是，我们可以通过<strong>流水线停顿</strong>（Pipeline Stall）来解决这个冒险问题。我们要在第二条指令的译码阶段之后，插入对应的 NOP 指令，直到前一条指令的数据写回完成之后，才能继续执行。</p><p>这样的方案，虽然解决了数据冒险的问题，但是也浪费了两个时钟周期。</p><img src="/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/8.jpeg" class=""> <h4 id="操作数前推"><a href="#操作数前推" class="headerlink" title="操作数前推"></a>操作数前推</h4><p>插入过多的 NOP 操作，意味着我们的 CPU 总是在空转。那么，我们有没有什么办法，尽量少插入一些 NOP 操作呢？</p><p>其实我们第二条指令的执行，未必要等待第一条指令写回完成，才能进行。我们完全可以在第一条指令的执行阶段完成之后，直接将结果数据传输给到下一条指令的 ALU。作为输入，那我们的第二条指令，就不用再从寄存器里面，把数据再单独读出来一次，才来执行代码。</p><p>在 CPU 的硬件里面，单独拉一根信号传输的线路出来，使得 ALU 的计算结果，能够重新回到 ALU 的输入里来。这样的一条线路，就是我们的<strong>旁路</strong>（Bypassing）。它跳过了写入寄存器，再从寄存器读出的过程，也为我们节省了 2 个时钟周期。</p><img src="/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/9.jpeg" class=""> <h3 id="控制冒险"><a href="#控制冒险" class="headerlink" title="控制冒险"></a>控制冒险</h3><p><strong>控制冒险</strong>（control hazard）由于决策依赖于一条指令的结果，而其他指令正在执行中。</p><p>在遇到了控制冒险之后，我们的 CPU 除了流水线停顿，等待前面的指令执行完成之后，再去取最新的指令，还有什么好办法吗？</p><h4 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h4><p>最简单的分支预测技术，叫作<strong>「假装分支不发生」</strong>。顾名思义，自然就是仍然按照顺序，把指令往下执行。其实就是 CPU 预测，条件跳转一定不发生。这样的预测方法，其实也是一种<strong>静态预测技术</strong>。就好像猜硬币的时候，你一直猜正面，会有 50% 的正确率。</p><h4 id="动态分支预测"><a href="#动态分支预测" class="headerlink" title="动态分支预测"></a>动态分支预测</h4><p>上面的静态预测策略，看起来比较简单，预测的准确率也许有 50%。但是如果运气不好，可能就会特别差。如果根据之前条件跳转的比较结果来预测，是不是会更准一点？</p><p>我们日常生活里，最经常会遇到的预测就是天气预报。如果没有气象台给你天气预报，你想要猜一猜明天是不是下雨，你会怎么办？有一个简单的策略，就是完全根据今天的天气来猜。如果今天下雨，我们就预测明天下雨。如果今天天晴，就预测明天也不会下雨。这是一个很符合我们日常生活经验的预测。</p><p>而同样的策略，我们一样可以放在分支预测上。这种策略，我们叫<strong>一级分支预测</strong>（One Level Branch Prediction），或者叫 <strong>1 比特饱和计数</strong>（1-bit saturating counter）。这个方法，其实就是用一个比特，去记录当前分支的比较情况，直接用当前分支的比较情况，来预测下一次分支时候的比较情况。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章为大家介绍计算机中<strong>流水线指令系统设计</strong>，介绍一下计算机如何加深<strong>流水线深度</strong>，提高<strong>吞吐率</strong>，从而<strong>「更快」</strong>地执行，也介绍了流水线处理器中的<strong>冒险</strong>以及解决方案。</p><p>下一章将为大家带来<strong>存储器</strong>的相关知识，介绍一下计算机是如何高效地读写数据。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://time.geekbang.org/column/intro/100026001" target="_blank" rel="noopener">徐文浩 - 深入浅出计算机组成原理</a></li><li><a href="http://www.chinesemooc.org/mooc/4392" target="_blank" rel="noopener">陆俊林 - 计算机组成</a></li><li><a href="https://book.douban.com/subject/26604008/" target="_blank" rel="noopener">戴维 A.帕特森 (David A.Patterson) / 约翰 L.亨尼斯 (John L.Hennessy) - 计算机组成与设计：硬件/软件接口（原书第5版）</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一章我们计算机中的指令系统，重点介绍了传送指令、流程控制和过程调用，了解了在高级语言如何转化为汇编语言来指导计算机工作。&lt;/p&gt;
&lt;p&gt;这一章会为大家介绍计算机中&lt;strong&gt;流水线指令系统设计&lt;/strong&gt;，介绍一下计算机如何&lt;strong&gt;「更快」&lt;/strong&gt;地执行，也会介绍如何去解决流水线处理器中的&lt;strong&gt;冒险&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="组成原理" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="组成原理" scheme="http://yoursite.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>3 指令系统</title>
    <link href="http://yoursite.com/2020/02/01/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2020/02/01/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-02-01T05:53:53.000Z</published>
    <updated>2020-02-04T06:17:56.775Z</updated>
    
    <content type="html"><![CDATA[<p>上一章我们介绍了计算机中信息的表示，重点介绍了浮点数和补码。</p><p>这一章会为大家介绍计算机中<strong>指令系统</strong>，重点介绍<strong>汇编语言</strong>。</p><a id="more"></a><h2 id="传送指令"><a href="#传送指令" class="headerlink" title="传送指令"></a>传送指令</h2><h3 id="通用数据传送指令"><a href="#通用数据传送指令" class="headerlink" title="通用数据传送指令"></a>通用数据传送指令</h3><p>对于 <code>movq</code> 指令来说，需要源操作数和目标操作数，源操作数可以是立即数、寄存器值或内存值的任意一种，但目标操作数只能是寄存器值或内存值。指令的具体格式可以这样写 <code>movq [Imm|Reg|Mem], [Reg|Mem]</code>，第一个是源操作数，第二个是目标操作数，例如：</p><ul><li><code>movq Imm, Reg</code> $\rightarrow$ <code>mov $0x5, %rax</code> $\rightarrow$ <code>temp = 0x5;</code></li><li><code>movq Imm, Mem</code> $\rightarrow$ <code>mov $0x5, (%rax)</code> $\rightarrow$ <code>*p = 0x5;</code></li><li><code>movq Reg, Reg</code> $\rightarrow$ <code>mov %rax, %rdx</code> $\rightarrow$ <code>temp2 = temp1;</code></li><li><code>movq Reg, Mem</code> $\rightarrow$ <code>mov %rax, (%rdx)</code> $\rightarrow$ <code>*p = temp;</code></li><li><code>movq Mem, Reg</code> $\rightarrow$ <code>mov (%rax), %rdx</code> $\rightarrow$ <code>temp = *p;</code></li></ul><h3 id="地址传送指令"><a href="#地址传送指令" class="headerlink" title="地址传送指令"></a>地址传送指令</h3><p>以 <code>leaq</code> 指令为例子。具体格式为 <code>leaq Src, Dst</code>，其中 <code>Src</code> 是地址的表达式，然后把计算的值存入 <code>Dst</code> 指定的寄存器。</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h3><p>CPU还有一组<strong>条件码</strong>寄存器，它们描述了最近的算术或逻辑操作的属性，来执行条件分支指令。最常用的条件码有：</p><ul><li>CF: 进位标志。用来检查无符号操作的溢出。</li><li>ZF: 零标志。</li><li>SF: 符号标志。最近的操作得到结果为负数。</li><li>OF: 溢出标志。对于有符号数的溢出。</li></ul><p>假设有表达式 <code>t=a+b​</code> ，有如下设置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">CF(<span class="keyword">unsigned</span>) t &lt; (<span class="keyword">unsigned</span>) a无符号溢出</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">ZF(t == <span class="number">0</span>)零</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">SF(t &lt; <span class="number">0</span>)负数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">OF(a &lt; <span class="number">0</span> == b &lt; <span class="number">0</span>) &amp;&amp; (t &lt; <span class="number">0</span> != a&lt; <span class="number">0</span>)有符号溢出</span></pre></td></tr></table></figure><p>假设<code>cmpq Src2(b), Src1(a)</code> ，等同于计算 <code>a-b</code>，然后利用 <code>a-b</code> 的结果来对应进行条件代码的设置：</p><ul><li>如果在最高位还需要进位（也就是溢出了），那么 CF 标识位就会被设置</li><li>a 和 b 相等时，也就是 <code>a-b</code> 等于零时，ZF 标识位会被设置</li><li>如果 a &lt; b，也就是 <code>(a-b)&lt;0</code> 时，那么 SF 标识位会被设置</li><li>如果溢出，那么 OF 标识位会被设置（溢出的情况是 <code>(a&gt;0 &amp;&amp; b &gt; 0 &amp;&amp; t &lt;0) || (a&lt;0 &amp;&amp; b&lt;0 &amp;&amp; t&gt;=0)</code>）</li></ul><h3 id="跳转指令编码"><a href="#跳转指令编码" class="headerlink" title="跳转指令编码"></a>跳转指令编码</h3><p>我们先来看一个比较原始的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">absdiff</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">long</span> result;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (x &gt; y)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        result = x-y;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        result = y-x;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> result;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>对应的汇编代码如下，这里 <code>%rdi</code> 中保存了参数 <code>x</code>，<code>%rsi</code> 中保存了参数 <code>y</code>，而 <code>%rax</code> 一般用来存储返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">absdiff:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    cmpq    %rsi, %rdi# x &gt; y?</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    jle     .L4# if ⩽ goto loop</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    movq    %rdi, %rax# result &#x3D; x</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    subq    %rsi, %rax# result &#x3D; x - y</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    ret</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">.L4:    # x &lt;&#x3D; y</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    movq    %rsi, %rax# result &#x3D; y</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    subq    %rdi, %rax# result &#x3D; y - x</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    ret</span></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>先来看看并不那么常用的 Do-While 语句以及对应使用 goto 语句进行跳转的版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Do While 的 C 语言代码</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fact_do</span><span class="params">(<span class="keyword">long</span> n)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">long</span> result = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">do</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        result *= n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        n = n - <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">while</span> (n &gt; <span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> result;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Goto 版本</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fact_do_goto</span><span class="params">(<span class="keyword">long</span> x)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">long</span> result = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">loop:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    result *= n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    n = n - <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">goto</span> loop;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> result;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这个函数计算阶乘，翻译成汇编如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">fact_do:    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    movl    $1, %eax    # result &#x3D; 0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">.L2:                    # loop:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    imulq   %rdi, %rax# result *&#x3D; n</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    subq    $1, %rdi    # n &#x3D; n - 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    cmpq    %1, %rdi  # n &gt; 1?</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    jg      .L2         # if &gt; goto loop</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    rep; ret</span></pre></td></tr></table></figure><p>其中 <code>%rdi</code> 中存储的是参数 <code>n</code>，<code>%rax</code> 存储的是返回值。换成更通用的形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// C Code</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Body</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (Test);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Goto Version</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">loop:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">Body</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Test)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> loop</span></pre></td></tr></table></figure><p>而对于 While 语句的转换，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// C While version</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (Test)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Body</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Goto Version</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> test;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">loop:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">Body</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">test:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Test)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> loop;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">done:</span></pre></td></tr></table></figure><p>而对于 For 循环语句的转换，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// For</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Init; Test; Update)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Body</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// While Version</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">Init;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (Test) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">Body</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">Update;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>我们在使用 if…else 这样的条件分支，或者 while/for 这样的循环方式，来实现程序运行流程时，回归到计算机可以识别的机器指令级别，其实都只是一个简单的地址跳转而已，也就是一个类似于 goto 的语句。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>所谓的栈，实际上一块内存区域，这个区域的数据进出满足先进后出的原则。越新入栈的数据，地址越低，所以栈顶的地址是最小的。寄存器 %rsp 是栈指针，用来记录栈顶的位置。寄存器 %rbp 是栈帧指针。具体实例如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span> <span class="params">( <span class="keyword">int</span> x, <span class="keyword">int</span> y )</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> x+y;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">caller</span> <span class="params">( )</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> t1 = <span class="number">125</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> t2 = <span class="number">80</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = add (t1, t2);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> sum;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>汇编如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">caller：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">pushl %rbp&#x2F;* 准备阶段 *&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">movl  %rsp, %rbp</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">subl $24, %rsp</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">movl $125, -12(%rbp)&#x2F;* 分配局部变量 *&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">movl $80, -8(%rbp)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">movl -8(%rbp), %rax&#x2F;* 准备入口参数 *&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">movl %rax, 4(%rsp)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">movl -12(%rbp), %rax</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">movl %rax, (%rsp)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">call add&#x2F;* 返回参数在 %rax 中*&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">movl %rax, -4(%rbp)&#x2F;* 准备返回参数 *&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">movl -4(%rbp), %rax</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">leave&#x2F;* 结束 *&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">ret</span></pre></td></tr></table></figure><img src="/2020/02/01/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/1.png" class="" title="过程调用栈示意图"> <h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章介绍了<strong>指令系统</strong>，介绍了传送、流程、过程这几种汇编语言指令，了解了高级语言到较为底层语言的过程。</p><p>下一章将为大家带来<strong>流水线处理器指令设计</strong>，介绍一下CPU是如何<strong>「同时」</strong>进行多项任务的。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://wdxtub.com/csapp/thin-csapp-1/2016/04/16/" target="_blank" rel="noopener">小土刀 - 【读薄 CSAPP】壹 数据表示</a></li><li><a href="https://book.douban.com/subject/26912767/" target="_blank" rel="noopener">Randal E.Bryant / David O’Hallaron - 深入理解计算机系统（原书第3版）</a></li><li><a href="https://www.icourse163.org/course/NJU-1001625001" target="_blank" rel="noopener">袁春风 - 计算机系统基础(一)：程序的表示、转换与链接</a></li><li><a href="https://time.geekbang.org/column/intro/100026001" target="_blank" rel="noopener">徐文浩 - 深入浅出计算机组成原理</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一章我们介绍了计算机中信息的表示，重点介绍了浮点数和补码。&lt;/p&gt;
&lt;p&gt;这一章会为大家介绍计算机中&lt;strong&gt;指令系统&lt;/strong&gt;，重点介绍&lt;strong&gt;汇编语言&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="组成原理" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="组成原理" scheme="http://yoursite.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>2 信息的表示与处理</title>
    <link href="http://yoursite.com/2020/01/31/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA/"/>
    <id>http://yoursite.com/2020/01/31/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA/</id>
    <published>2020-01-31T05:53:53.000Z</published>
    <updated>2020-02-04T06:17:50.703Z</updated>
    
    <content type="html"><![CDATA[<p>上一章我们介绍了计算机的基本硬件组成，让我们对计算机大致有一个了解。</p><p>这一章会为大家介绍计算机中信息的表示，有些也是之前学到的，比如二进制的计算。将重点介绍<strong>无符号</strong>（unsigned）、<strong>带符号</strong>、<strong>浮点数</strong>（floating-point）这三种编码方式。</p><p>当然溢出和浮点数特殊的编码方式也会产生与预期不一样的结果，我们也会介绍。</p><a id="more"></a><h2 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h2><p>一个<strong>字节</strong>（byte）由8位组成。二进制、十进制与十六进制之间的转化如下表：</p><div class="table-container"><table><thead><tr><th style="text-align:center">十六进制</th><th style="text-align:center">十进制</th><th style="text-align:center">二进制</th><th style="text-align:center">十六进制</th><th style="text-align:center">十进制</th><th style="text-align:center">二进制</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0000</td><td style="text-align:center">8</td><td style="text-align:center">8</td><td style="text-align:center">1000</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0001</td><td style="text-align:center">9</td><td style="text-align:center">9</td><td style="text-align:center">1001</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">0010</td><td style="text-align:center">A</td><td style="text-align:center">10</td><td style="text-align:center">1010</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">0011</td><td style="text-align:center">B</td><td style="text-align:center">11</td><td style="text-align:center">1011</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:center">0100</td><td style="text-align:center">C</td><td style="text-align:center">12</td><td style="text-align:center">1100</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">5</td><td style="text-align:center">0101</td><td style="text-align:center">D</td><td style="text-align:center">13</td><td style="text-align:center">1101</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:center">0110</td><td style="text-align:center">E</td><td style="text-align:center">14</td><td style="text-align:center">1110</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">7</td><td style="text-align:center">0111</td><td style="text-align:center">F</td><td style="text-align:center">15</td><td style="text-align:center">1111</td></tr></tbody></table></div><h2 id="字数据大小"><a href="#字数据大小" class="headerlink" title="字数据大小"></a>字数据大小</h2><p>C语言支持的基本数据类型分配的字节数如下表所示：</p><div class="table-container"><table><thead><tr><th style="text-align:center">C语言声明</th><th style="text-align:center">32位 / 字节</th><th style="text-align:center">64位 / 字节</th></tr></thead><tbody><tr><td style="text-align:center">(unsigned) char</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">(unsigned) short</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">(unsigned) int</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">(unsigned) long</td><td style="text-align:center">4</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">char *</td><td style="text-align:center">4</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">8</td><td style="text-align:center">8</td></tr></tbody></table></div><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>对于带符号数而言，其编码方式与无符号数不同，为补码编码（two’ s complement）。最高有效位为符号位，当符号位为1时，值为负；符号位为0时，值为正。正负数之间补码的关系有如下结论：<strong>一个负数的补码等于将对应正数补码各位取反、末位加一</strong>。</p><p>例如：<code>11010110</code>的真值为<code>-0101010 = -(32+8+2) = -42</code></p><h2 id="整数的表示"><a href="#整数的表示" class="headerlink" title="整数的表示"></a>整数的表示</h2><p>下面定义三个整数数据：$Tmin$ - 最小补码值，$TMax$ - 最大补码值，$UMax$ - 最大无符号数。</p><p>假设字长为 <code>w</code>，定义如下的常量：</p><ul><li>$UMin = 0$ 即 <code>000…0</code></li><li>$UMax =  2^w−1 $ 即 <code>111…1</code></li><li>$TMin = −2^w−1 $ 即 <code>100…0</code></li><li>$ TMax = 2^{w−1}−1 $ 即 <code>011…1</code></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">数</th><th style="text-align:center">8</th><th style="text-align:center">16</th><th style="text-align:center">32</th><th style="text-align:center">64</th></tr></thead><tbody><tr><td style="text-align:center">$UMax$</td><td style="text-align:center">255</td><td style="text-align:center">65535</td><td style="text-align:center">4294967295</td><td style="text-align:center">18446744073709551615</td></tr><tr><td style="text-align:center">$TMin$</td><td style="text-align:center">-128</td><td style="text-align:center">-32768</td><td style="text-align:center">-2147483648</td><td style="text-align:center">-9223372036854775808</td></tr><tr><td style="text-align:center">$TMax$</td><td style="text-align:center">127</td><td style="text-align:center">32767</td><td style="text-align:center">2147483647</td><td style="text-align:center">9223372036854775807</td></tr></tbody></table></div><p>其中          $ | Tmin | = |TMax| + 1 $          $ UMax = 2*TMax + 1 $</p><h2 id="位扩展和位截断运算"><a href="#位扩展和位截断运算" class="headerlink" title="位扩展和位截断运算"></a>位扩展和位截断运算</h2><ul><li><strong>扩展：短转长</strong><br>无符号数：0扩展（前面补0）<br>带符号整数：符号扩展（前面补符）</li><li><strong>截断：长转短</strong><br>强行将高位丢弃，故可能发生“溢出”</li></ul><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 扩展操作 */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> si = <span class="number">-32768</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> usi = si;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = si;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">unsingned ui = usi ;</span></pre></td></tr></table></figure><p>输出为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">si = <span class="number">-32768</span> <span class="number">80</span> <span class="number">00</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">usi = <span class="number">32768</span> <span class="number">80</span> <span class="number">00</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">i = <span class="number">-32768</span> FF FF <span class="number">80</span> <span class="number">00</span> <span class="comment">/* 带符号整数：符号扩展 */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">ui = <span class="number">32768</span> <span class="number">00</span> <span class="number">00</span> <span class="number">80</span> <span class="number">00</span> <span class="comment">/* 无符号整数：0扩展 */</span></span></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 截断操作 */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">32768</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> si = (<span class="keyword">short</span>) i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j = si;</span></pre></td></tr></table></figure><p>输出为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">i = <span class="number">32768</span> <span class="number">00</span> <span class="number">00</span> <span class="number">80</span> <span class="number">00</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">si = <span class="number">-32768</span> <span class="number">80</span> <span class="number">00</span> <span class="comment">/* 截断时发生了“溢出” */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">j = <span class="number">-32768</span> FF FF <span class="number">80</span> <span class="number">00</span></span></pre></td></tr></table></figure><h2 id="IEEE-浮点数标准"><a href="#IEEE-浮点数标准" class="headerlink" title="IEEE 浮点数标准"></a>IEEE 浮点数标准</h2><p>IEEE浮点标准用如下公式表示：</p><script type="math/tex; mode=display">V = (-1)^s*M*2^E</script><ul><li><strong>符号</strong>：$s$ 决定其正负号。</li><li><strong>尾数</strong>：$M$ 为二进制小数。对于<strong>规格化的值</strong>而言，$M=1.f_{n-1}…f_1f_0$；对于<strong>非规格化的值</strong>而言，$M=0.f_{n-1}…f_1f_0$。其中$f_{n-1}…f_1f_0$的部分就是 frac 的编码部分。</li><li><strong>阶码</strong>：$E$ 为指数位。对于<strong>规格化的值</strong>而言，$E=Exp−Bias$，对于<strong>非规格化的值</strong>而言，$E=1−Bias$。<ul><li>$Exp$: 是 exp 编码区域的无符号数值</li><li>$Bias$：值为$2^{k−1}−1$的偏移量，其中 $k$ 是 exp 编码的位数。</li></ul></li></ul><p>对于不同的格式，也有不同的编码结构，如下图所示：</p> <img src="/2020/01/31/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA/1.jpg" class="" title="标准浮点格式"> <h3 id="数字示例"><a href="#数字示例" class="headerlink" title="数字示例"></a>数字示例</h3><p>下面假定8位浮点数，其中有 $k=4$ 的阶码位和 $n=3$ 的小数位。偏移量为 $2^{4-1}-1=7$ 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">    s exp  frac   E   值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">------------------------------------------------------------------</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    0 0000 000   -6   0   # 这部分是非规范化数值，下一部分是规范化值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    0 0000 001   -6   1&#x2F;8 * 1&#x2F;64 &#x3D; 1&#x2F;512 # 能表示的最接近零的值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    0 0000 010   -6   2&#x2F;8 * 1&#x2F;64 &#x3D; 2&#x2F;512 </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    0 0000 110   -6   6&#x2F;8 * 1&#x2F;64 &#x3D; 6&#x2F;512</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    0 0000 111   -6   7&#x2F;8 * 1&#x2F;64 &#x3D; 7&#x2F;512 # 能表示的最大非规范化值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">------------------------------------------------------------------</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    0 0001 000   -6   8&#x2F;8 * 1&#x2F;64 &#x3D; 8&#x2F;512 # 能表示的最小规范化值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    0 0001 001   -6   9&#x2F;8 * 1&#x2F;64 &#x3D; 9&#x2F;512</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    0 0110 110   -1   14&#x2F;8 * 1&#x2F;2 &#x3D; 14&#x2F;16</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    0 0110 111   -1   15&#x2F;8 * 1&#x2F;2 &#x3D; 15&#x2F;16 # 最接近且小于 1 的值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    0 0111 000    0   8&#x2F;8 * 1 &#x3D; 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    0 0111 001    0   9&#x2F;8 * 1 &#x3D; 9&#x2F;8      # 最接近且大于 1 的值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    0 0111 010    0   10&#x2F;8 * 1 &#x3D; 10&#x2F;8</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    0 1110 110    7   14&#x2F;8 * 128 &#x3D; 224</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    0 1110 111    7   15&#x2F;8 * 128 &#x3D; 240   # 能表示的最大规范化值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">------------------------------------------------------------------</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    0 1111 000   n&#x2F;a  无穷               # 特殊值</span></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章介绍了不同编码方式表示不同的数据，重点介绍了<strong>补码</strong>、<strong>浮点数</strong>。</p><p>下一章将为大家带来指引计算机工作的<strong>指令系统</strong>，介绍一下<strong>指令系统</strong>的基本概念，涉及少部分<strong>汇编语言</strong>。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://wdxtub.com/csapp/thin-csapp-1/2016/04/16/" target="_blank" rel="noopener">小土刀 - 【读薄 CSAPP】壹 数据表示</a></li><li><a href="https://book.douban.com/subject/26912767/" target="_blank" rel="noopener">Randal E.Bryant / David O’Hallaron - 深入理解计算机系统（原书第3版）</a></li><li><a href="https://time.geekbang.org/column/intro/100026001" target="_blank" rel="noopener">徐文浩 - 深入浅出计算机组成原理</a></li><li><a href="https://www.icourse163.org/course/NJU-1001625001" target="_blank" rel="noopener">袁春风 - 计算机系统基础(一)：程序的表示、转换与链接</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一章我们介绍了计算机的基本硬件组成，让我们对计算机大致有一个了解。&lt;/p&gt;
&lt;p&gt;这一章会为大家介绍计算机中信息的表示，有些也是之前学到的，比如二进制的计算。将重点介绍&lt;strong&gt;无符号&lt;/strong&gt;（unsigned）、&lt;strong&gt;带符号&lt;/strong&gt;、&lt;strong&gt;浮点数&lt;/strong&gt;（floating-point）这三种编码方式。&lt;/p&gt;
&lt;p&gt;当然溢出和浮点数特殊的编码方式也会产生与预期不一样的结果，我们也会介绍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="组成原理" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="组成原理" scheme="http://yoursite.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>1 计算机基本结构</title>
    <link href="http://yoursite.com/2020/01/30/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2020/01/30/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</id>
    <published>2020-01-30T05:53:53.000Z</published>
    <updated>2020-01-31T08:38:01.426Z</updated>
    
    <content type="html"><![CDATA[<p>本章将介绍计算机的基本硬件，以让大家对计算机大致框架有所了解，这些硬件都要完成以下功能：输入数据、输出数据、处理数据和存储数据。</p><a id="more"></a><h2 id="计算机的基本硬件组成"><a href="#计算机的基本硬件组成" class="headerlink" title="计算机的基本硬件组成"></a>计算机的基本硬件组成</h2><ol><li><strong>中央处理器CPU</strong>（Central Processing Unit）：是计算机中最核心的部分。用于执行指令。</li><li><strong>内存</strong>（Memory）：程序读取的数据、计算得到的结果都会存放在内存中，计算机程序也要加载到内存中才可以运行。</li><li><strong>主板</strong>（Motherboard）：将CPU和内存插在主板上，主板中的<strong>芯片组</strong>（Chipset）和<strong>总线</strong>（Bus）解决CPU与内存之间的通信问题。</li><li><strong>I/O设备</strong>：输入/输出设备。</li></ol><h2 id="冯·诺依曼体系结构"><a href="#冯·诺依曼体系结构" class="headerlink" title="冯·诺依曼体系结构"></a>冯·诺依曼体系结构</h2><p>1945年，冯·诺伊曼基于当时在秘密开发的<strong>EDVAC</strong>（Electronic Discrete Variable Automatic Computer），以<a href="https://ieeexplore.ieee.org/document/238389" target="_blank" rel="noopener">「First Draft of a Report on the EDVAC」</a>为题，起草了长达101页的总结报告，发表了全新的「存储程序通用电子计算机方案」。</p><h3 id="冯·诺依曼体系结构的主要思想"><a href="#冯·诺依曼体系结构的主要思想" class="headerlink" title="冯·诺依曼体系结构的主要思想"></a>冯·诺依曼体系结构的主要思想</h3><ol><li><p>计算机应由运算器、控制器、存储器、输入设备和输出设备五个基本部件组成。</p></li><li><p>各基本部件的功能是：</p><ul><li><p><strong>控制器单元</strong>（Control Unit/CU）：控制程序的流程，通常是不同条件下的分支与跳转。可自动地从存储器中取出指令加以执行；</p></li><li><p><strong>处理器单元</strong>（Processing Unit）：包含算术逻辑单元（Arithmetic Logic Unit， ALU）和处理器寄存器（Processor Register）可进行加/减/乘/除四种基本算术运算，并且也能进行一些逻辑运算和附加运算；</p></li><li><p><strong>存储器</strong>：不仅能存放数据（Data），而且也能存放指令（Instruction），形式上两者没有区别，但计算机应能区分数据还是指令；</p></li><li><p>操作人员可以通过<strong>输入/输出设备</strong>和主机进行通信。</p></li></ul></li><li><p>内部以<strong>二进制表示</strong>指令和数据。每条指令由操作码和地址码两部分组成。操作码指出操作类型，地址码指出操作数的地址。由一串指令组成程序。</p></li><li><p>采用<strong>存储程序</strong>工作方式。 </p><img src="/2020/01/30/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/1.jpeg" class="" title="冯·诺依曼体系结构示意图"> </li></ol><h2 id="计算机执行指令的过程"><a href="#计算机执行指令的过程" class="headerlink" title="计算机执行指令的过程"></a>计算机执行指令的过程</h2><ol><li><strong>取指</strong>（Fetch）<ul><li>控制器将指令的地址送往存储器；</li><li>存储器按给定的地址读出指令内容，送回控制器。</li></ul></li><li><strong>译码</strong>（Decode）<ul><li>控制器分析指令的操作性质；</li><li>控制器向有关部件发出指令所需的控制信号。</li></ul></li><li><strong>执行</strong>（Execute）<ul><li>控制器从通用寄存器或存储器取出操作数；</li><li>控制器命令运算器对操作数进行指令规定的运算。</li></ul></li><li><strong>回写</strong>（Write-back）<ul><li>将运算结果写入通用寄存器或存储器</li></ul></li></ol><img src="/2020/01/30/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/2.png" class="" title="计算机结构的简化模型"> <h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章内容相对简单，介绍了计算机的基本硬件组成、冯·诺依曼体系结构、每个基本硬件的主要功能以及计算机执行指令的过程，让大家对计算机基本组成以及功能有所了解。</p><p>下一章将为大家带来指引计算机中<strong>信息的表示与处理</strong>，来看看计算机是如何用0和1来记录信息的。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="http://www.chinesemooc.org/mooc/4392" target="_blank" rel="noopener">陆俊林 - 计算机组成</a></li><li><a href="https://time.geekbang.org/column/intro/100026001" target="_blank" rel="noopener">徐文浩 - 深入浅出计算机组成原理</a></li><li><a href="https://www.icourse163.org/course/NJU-1001625001" target="_blank" rel="noopener">袁春风 - 计算机系统基础(一)：程序的表示、转换与链接</a></li><li><a href="https://ieeexplore.ieee.org/document/238389" target="_blank" rel="noopener">J. von Neumann - First Draft of a Report on the EDVAC</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章将介绍计算机的基本硬件，以让大家对计算机大致框架有所了解，这些硬件都要完成以下功能：输入数据、输出数据、处理数据和存储数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="组成原理" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="组成原理" scheme="http://yoursite.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>我的2019年个人总结</title>
    <link href="http://yoursite.com/2020/01/01/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/%E6%88%91%E7%9A%842019%E5%B9%B4%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/01/01/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/%E6%88%91%E7%9A%842019%E5%B9%B4%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</id>
    <published>2020-01-01T03:36:39.000Z</published>
    <updated>2020-02-19T04:51:52.596Z</updated>
    
    <content type="html"><![CDATA[<p>大家好呀。在此记录一下我的2019年个人总结。</p><a id="more"></a><h2 id="个人管理"><a href="#个人管理" class="headerlink" title="个人管理"></a>个人管理</h2><p>个人管理分为身体管理、精力管理以及财务管理。</p><p>今年年初为自己添置了两份保险，以应对生活中的风险，也算是对家人和自己负责。由于学习工作的缘故，运动时间相对减少（说白了就是懒），这点不足预期。后来在平时通勤的时候尽量选择爬楼梯来增加运动量。同时对自己的饮食习惯进行调整，少盐多果蔬，一年下来也没生什么病。</p><p>年中的时候读了很多管理精力的内容，慢慢调整自己的习惯。利用日程本和计划表来规划每天的日程。期间也会放任自己的「惰性」，发展新的爱好，结识了新朋友，以此放松，恢复精力。</p><p>财务方面个人还是比较满意的，当然入门的时候也交了不少学费，但是现在也做到了每天记账，每月预算，定期投资，也达到了还算不错的收益。</p><h2 id="个人提升"><a href="#个人提升" class="headerlink" title="个人提升"></a>个人提升</h2><p>研一初决定开启「劝退大业」，但正式实施还是在今年，研一下学期选了一门计算机基础课，也取得了还算不错的分数，算是给自己一点信心吧。研二开始系统学习计算机基础知识，到目前为止基本完成了算法、组成原理、操作系统的学习，同时也点了爬虫和网页等技能树。以此搭建了自己了博客，通过Typora + CSS改进了微信排版。</p><p>这一年读了不少非虚构类书籍，并学习了很多网课，这点我是比较满意的，除了专业书籍外，也读了理财管理的书籍，并进行了输出。</p><p>今年也看了不少电影，很多自己喜欢的大作。也渐渐感觉到审查制度愈发严苛，流媒体冲击传统电影行业。</p><h2 id="2020年的计划"><a href="#2020年的计划" class="headerlink" title="2020年的计划"></a>2020年的计划</h2><h3 id="1-坚持生活"><a href="#1-坚持生活" class="headerlink" title="1. 坚持生活"></a>1. 坚持生活</h3><p>做好情绪管理，坚持运动，保持身心健康。</p><h3 id="2-职业发展"><a href="#2-职业发展" class="headerlink" title="2. 职业发展"></a>2. 职业发展</h3><p>距离毕业不到一年，年初寻找机会，为职业发展做好准备。</p><h3 id="3-内容输出"><a href="#3-内容输出" class="headerlink" title="3. 内容输出"></a>3. 内容输出</h3><p>未来一年会继续学习理财投资与专业知识，定期输出优质内容。</p><h3 id="4-内心平静"><a href="#4-内心平静" class="headerlink" title="4. 内心平静"></a>4. 内心平静</h3><p>与家人朋友坦诚沟通。</p><hr><p>「南方周末」的一篇新年祝辞我很喜欢，在此送给看到这里的朋友：</p><blockquote><p>总有一种力量它让我们泪流满面，总有一种力量它让我们抖擞精神，总有一种力量它驱使我们不断寻求「正义、爱心、良知」。这种力量来自于你，来自于你们中间的每一个人。所以，在这样的时候，在新年的第一天，我们要想向你、向你身边的每一个人，说一声，新年好！祝愿阳光打在你的脸上。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家好呀。在此记录一下我的2019年个人总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="我的年度个人总结" scheme="http://yoursite.com/categories/%E6%88%91%E7%9A%84%E5%B9%B4%E5%BA%A6%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="个人总结" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>我的2018年个人总结</title>
    <link href="http://yoursite.com/2018/12/31/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/2018%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/12/31/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/2018%E6%80%BB%E7%BB%93/</id>
    <published>2018-12-31T13:46:12.000Z</published>
    <updated>2019-12-09T06:58:57.804Z</updated>
    
    <content type="html"><![CDATA[<p>在此向朋友们分享一下我的2018年。</p><a id="more"></a><p>上半年处于低谷期。我是个理想主义者，曾坚信一点：这个世界是美好的，每个人都有基本的道德底线。纵使社会有许多不公，我们依然有法律作为最后的武器。但是上半年各种事件的冲击，使我对此产生了怀疑。</p><p>于是产生了许多负面情绪，那个时候唯一坚持的事就是胶片摄影。镜头也开始对准了一些生活小事，每一次按下快门都会给我带来无限期待，胶片记录下来的影像，也带给了我前所未有的喜悦。</p><p>毕业之后，开始为家中老人拍摄一部纪录片，记录他们七十余年的人生经历。这是我第一次拍摄较大题材的视频，前期做了不少准备，自己的摄影后期水平也得到了进一步的提升。在镜头前，老人们表现出了从未有过的状态，我也开始真正理解「家人」这一词的含义。</p><p>自己做的一切可能真的很难改变现状，但是不经意间的一个善举就会给身边的人带来莫大的温暖。而这，也许是在这个世界中我们依旧呼吸与共的理由吧。</p><p>下半年的生活并没有想象中那么符合预期，年初的时候我也调侃过这只不过是给自己的软弱找了3年的缓冲期，想不到一语成谶。我现在唯一能做的就是让自己有更多自由选择的机会。</p><p>今年年底我经历了前所未有的情绪失控。我自诩极度理性，不会轻易由情感左右，很多朋友也这样认为。但我也只是不会「轻易」由情感左右，就像在自己心中下起了雨，慢慢积蓄，最后决堤，冲垮了自己的心理防线。不过现在精神状态好了些，勉强冷静地去处理这件事了。</p><p>在这期间特别感谢几位朋友和长辈的开导与关心。这段期间我也理解「陪伴」的重要性，真正的陪伴并不是生活上细枝末节的关照与物质上的付出，而是发自内心的理解与支持。这种情感是出于双方之间的信任与尊重，并非通过不停的地位互换所带来的管控与满足。否则这种关系是畸形的，是被绑架的，是孤独而又疲惫的。而这却又是约定俗成的，是符合社会要求的，是被外界认为是幸福的。</p><p>个人提升方面依旧是技能树乱点：暑假开始学习做饭，目前勉强能够做到解决温饱；初步了解了经济学相关的知识，开启了通往「财富自由」的道路；在专业的要求下重拾编程，依旧从入门到入土。</p><p>我自己也添置了不少个人用品：「飞利浦HX6730电动牙刷」治愈了困扰多年的口腔溃疡；「iPad Pro」使小屏观影的时代成为历史；「VALIO无乳糖脱脂奶粉」对乳糖不耐受人群极为友好。</p><hr><p>2019年的计划：</p><p><strong>1.依旧不满足于现状</strong></p><p>趁着年轻，出去看看，做改变自己的事。</p><p><strong>2.身体健康</strong></p><p>这一年做的不是很好，新的一年要保持运动。</p><p><strong>3.坚持记录</strong></p><p>影像与文字是时间最忠实的朋友。</p><p><strong>4.陪伴</strong></p><p>这个世界上最美好的词。</p><hr><p>感谢家人与朋友们的陪伴，感谢你们一直都在。</p><p>新年快乐。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在此向朋友们分享一下我的2018年。&lt;/p&gt;
    
    </summary>
    
    
      <category term="我的年度个人总结" scheme="http://yoursite.com/categories/%E6%88%91%E7%9A%84%E5%B9%B4%E5%BA%A6%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="个人总结" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>「重庆森林」简评</title>
    <link href="http://yoursite.com/2018/12/03/%E7%AE%80%E8%AF%84/%E3%80%8C%E9%87%8D%E5%BA%86%E6%A3%AE%E6%9E%97%E3%80%8D%E7%AE%80%E8%AF%84/"/>
    <id>http://yoursite.com/2018/12/03/%E7%AE%80%E8%AF%84/%E3%80%8C%E9%87%8D%E5%BA%86%E6%A3%AE%E6%9E%97%E3%80%8D%E7%AE%80%E8%AF%84/</id>
    <published>2018-12-03T13:46:12.000Z</published>
    <updated>2019-12-09T06:14:25.915Z</updated>
    
    <content type="html"><![CDATA[<p>许久不见，这次聊聊王家卫导演的「重庆森林」后半部分王菲与梁朝伟之间的故事。</p><a id="more"></a><p>王家卫导演的电影中爱情总是一条主线，他电影中的主角总会做一些「不合乎逻辑」的事，这也是我之前不那么中意王家卫导演的原因。在我的电影观里，逻辑才是评判一部电影的标准。</p><p>后来才发现，现实的许多事情是从不合逻辑的。许多看似突然发生的事情过程却异常平静，带给人无穷回味；许多看似平静的事情其下却暗流涌动，积累着情绪准备迸发。而这恐怕也是生活迷人的地方。</p><p>影片中梁朝伟看似有些木讷，后知后觉。但也许他是个很难放下过去的人，喝了许久的咖啡也不愿换一个口味。很多时候无声的安静却显得十分吵闹，因为你很难把情绪排除在外，它们就伴随你左右。就像王菲总把音乐开得很大，试图盖过这无声的喧嚣。</p><p>而影片中另一个意象「房子」正好反映了梁朝伟的内心世界，伤心之人可能在外表上与常人无异，生活仿佛并没有受到什么影响。而他的内心早已下起了雨，在积水淹没自己的时候，才会在那一刻感到窒息般的痛苦。</p><p>王菲则体察到了梁朝伟的内心，这时她充当了一个合格的暗恋者，不声不响地帮梁朝伟打理内心的房间，带他走出阴霾。</p><p>我最喜欢王菲这个角色，她或许是许多对爱情保持克制的缩影。她生性自由，不想心事却有自己的心事；她渴望爱情，不停制造「巧合」来引起对方注意；她害怕爱情，对渴望已久的表白却表现得有些不知所措。</p><p>而「加州」则成了她的精神避难所，或许专注于某一件事情，是排解情绪唯一的办法，即使是不那么有效的办法。</p><p>还好这次王家卫给予了观众希望，让他二人在阔别一年之后重逢。</p><p>于1994年上映的「重庆森林」是王家卫导演在拍摄完「东邪西毒」遇到创作瓶颈，却只花了两个月时间拍摄出来的影片。影片分为上下两个部分，相互独立。它讲述了都市男女之间的情愫，有许多我们可能永远都无法察觉的情感羁绊。</p><p>这也是王家卫之所以为王家卫的原因，将生活中的种种小事拍摄出来，将种种细节埋在画面里，呈现给观众。初次观影时可能会觉得费解又矫情，当自己的阅历逐渐丰满时，才会在这其中或多或少看到自己的影子。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;许久不见，这次聊聊王家卫导演的「重庆森林」后半部分王菲与梁朝伟之间的故事。&lt;/p&gt;
    
    </summary>
    
    
      <category term="简评" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/"/>
    
      <category term="2018" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/2018/"/>
    
    
      <category term="剧情" scheme="http://yoursite.com/tags/%E5%89%A7%E6%83%85/"/>
    
      <category term="简评" scheme="http://yoursite.com/tags/%E7%AE%80%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>「狐步舞」简评</title>
    <link href="http://yoursite.com/2018/07/03/%E7%AE%80%E8%AF%84/%E7%8B%90%E6%AD%A5%E8%88%9E%E7%AE%80%E8%AF%84/"/>
    <id>http://yoursite.com/2018/07/03/%E7%AE%80%E8%AF%84/%E7%8B%90%E6%AD%A5%E8%88%9E%E7%AE%80%E8%AF%84/</id>
    <published>2018-07-03T13:46:12.000Z</published>
    <updated>2019-12-09T06:52:00.575Z</updated>
    
    <content type="html"><![CDATA[<p>有这样一种舞蹈，不论从哪里开始，永远都会回到同样的起点。</p><a id="more"></a><h2 id="第一幕"><a href="#第一幕" class="headerlink" title="第一幕"></a>第一幕</h2><p>在以色列，一个平静的中产家庭迎来几位军人的到访。母亲率先察觉到异样，昏厥倒地。父亲看着他们麻利地拿出注射器，给妻子来了一发镇定剂。接着他们宣布一个消息：在外服役的长子牺牲了。</p><p>父亲强忍悲痛接受了军方的专业「慰问」，并告知自己在精神病院的母亲，在商量儿子葬礼事宜时，却得知儿子并没有死，死的是与自己儿子同名的人。这时父亲慌了神，不惜动用特殊关系，要求儿子回家。</p><h2 id="第二幕"><a href="#第二幕" class="headerlink" title="第二幕"></a>第二幕</h2><p>在边境，不满20岁的儿子与其他三位战友驻扎在一个简陋的房中，他们百无聊赖，听着收音机，抱着M4步枪跳舞，为漫步的骆驼放行，用罐头的滚动速度来论证房子在不断倾斜。儿子则将父亲的床边故事改编成漫画，绘在笔记本上。</p><p>一天晚上，战友错将通行车辆上掉落的啤酒罐认作手雷，神经紧绷的儿子端起机枪杀了车内四名巴勒斯坦青年。</p><p>第二天，一辆推土机掩埋了报废的轿车，处理此事的军官对儿子说：你可以回家了。</p><h2 id="中场：最后的床边故事"><a href="#中场：最后的床边故事" class="headerlink" title="中场：最后的床边故事"></a>中场：最后的床边故事</h2><p>父亲儿时用传家宝希伯来圣经换取了色情杂志，自己的母亲也为此精神崩溃。后来父亲参军，期满退役，以优异成绩从大学毕业，娶妻生子，最后成为优秀的建筑师。在一切荣光背后，只有在无人的夜晚才会拭去眼泪。</p><h2 id="第三幕"><a href="#第三幕" class="headerlink" title="第三幕"></a>第三幕</h2><p>转眼便是儿子二十岁生日，只不过却只有夫妻二人在烛光前独饮。</p><p>想不到父亲极力避免的事情最后成为葬送儿子的原因。母亲控诉了父亲之后，与之吸起了大麻，在烟雾缭绕的烛火前调侃起儿子的葬礼。</p><p>在余晖中，夫妻跳起了狐步舞。</p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>在军车上，儿子画完了最后一幅画，那是一辆高举着轿车的推土机。这时，路面上出现了那只悠闲的骆驼，司机躲闪不及，车辆坠入崖中。</p><hr><p>这是一部战争片。有趣的是这部电影出奇地克制，不同于一般印象中战争电影的固有形象，片中没有对战争的强烈表现或对英雄的过分渲染。</p> <img src="/2018/07/03/%E7%AE%80%E8%AF%84/%E7%8B%90%E6%AD%A5%E8%88%9E%E7%AE%80%E8%AF%84/1.jpg" class=""> <p>驻守边疆的四名年轻士兵，任务就是筛查来往的一切车辆，消遣着每日时光。湛蓝的天空映衬着无垠的荒原，色彩艳丽的涂鸦点缀着独舞士兵的孤寂内心，没有丝毫战争的痕迹。</p><p>直到第一声枪响，观众的思绪才被拽回到现实。宁可错杀一千也不放过一个，即便对方是互有好感的年轻女郎，士兵也会抛下画笔端起机枪，屠尽眼前的一切。</p><p>片中还有另一个描写战争的细节，在军方慰问家属时，其「专业性」令人胆寒。在家国大义面前丧子之痛似乎显得微不足道，悲痛也就见怪不怪了。</p><hr><p>片中有三段狐步舞，分别是第一幕的养老院老人；第二幕的年轻士兵；第三幕的共舞夫妻，分别对应着各自的孤独，宿命的。</p><p>这部电影的主角是父亲。但没有太多对父亲过去的刻画，这也就为观众解读提供发挥空间。父亲像是一个摒弃世俗的利己主义者，会做出任何有利于自己的事情。父亲年轻时也是校园中的风云人物，似乎是这种众星捧月的虚荣会让他去拿传家宝来换取色情杂志。在战役胜利回程的路上，他才会让战友带队引路。</p><img src="/2018/07/03/%E7%AE%80%E8%AF%84/%E7%8B%90%E6%AD%A5%E8%88%9E%E7%AE%80%E8%AF%84/2.jpg" class=""><p>光鲜亮丽的外表，都是掩饰自己脆弱的秘密。</p><p>家人都深知自己的脆弱，他们陪着自己的伤口生活，让自己显得坚强。亲情是他最后的防线。这也是为什么在得知儿子「去世」的第一时间他会选择通知自己的母亲，也是为什么在得知儿子存活的第一时间选择让儿子回到自己身边，而这种对儿子的保护恰恰成为害死他的缘由。</p><p>影片的最后，妻子盯着儿子最后的那幅画说：你是那辆推土机，我是那辆轿车。</p><p>或许同这位父亲一样，极力想掩埋的秘密，最终会成为惩罚自己的恶果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有这样一种舞蹈，不论从哪里开始，永远都会回到同样的起点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="简评" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/"/>
    
      <category term="2018" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/2018/"/>
    
    
      <category term="剧情" scheme="http://yoursite.com/tags/%E5%89%A7%E6%83%85/"/>
    
      <category term="简评" scheme="http://yoursite.com/tags/%E7%AE%80%E8%AF%84/"/>
    
      <category term="战争" scheme="http://yoursite.com/tags/%E6%88%98%E4%BA%89/"/>
    
  </entry>
  
  <entry>
    <title>「血观音」简评</title>
    <link href="http://yoursite.com/2018/05/23/%E7%AE%80%E8%AF%84/%E3%80%8C%E8%A1%80%E8%A7%82%E9%9F%B3%E3%80%8D%E7%AE%80%E8%AF%84/"/>
    <id>http://yoursite.com/2018/05/23/%E7%AE%80%E8%AF%84/%E3%80%8C%E8%A1%80%E8%A7%82%E9%9F%B3%E3%80%8D%E7%AE%80%E8%AF%84/</id>
    <published>2018-05-23T13:46:12.000Z</published>
    <updated>2019-12-09T06:17:27.203Z</updated>
    
    <content type="html"><![CDATA[<p>最近观看了去年台湾金马奖的两大热门：「大佛普拉斯」与「血观音」。两者都是讲述台湾本土故事，如果说前者是道出底层人口的无可奈何，那么后者则是深刻剖析上层权贵的尔虞我诈。</p><a id="more"></a><p>「血观音」最吸引人的地方莫过于散落片中角落的细节拼图，通过对这些细节的拼凑，看清这些拼图的真相。暴力象征的<strong>血</strong>与慈眉善目的<strong>观音</strong>相结合，展现出权术更迭中无尽的修罗场，令人窒息的黑暗。</p><p>「血观音」最胆战心惊的地方是这部电影中没有一个人心存善念，甚至包括开局就领盒饭的林夫人。林夫人表面是个人畜无害的日本少妇，实则一直将马童Marco当作性奴。在问棠真话的时候，开始一直用日语与之交流，随后在问：「Marco为什么没有来帮你」时却用的是国语，为的是让棠真放下戒心，套出实情。</p><p>要说留有人性最后一丝温存的应该是棠宁。在她终于不愿再受母亲棠夫人摆布，执意赴死的时候，听到自己女儿棠真对自己的控诉：「你们不都是一样吗」。她则打开手铐，表达了自己对女儿最后的关切。</p><p>片中刻画最为深刻的角色当属棠真，演员文淇也获得了去年的金马奖最佳女配角。影片以她开头，并以她结尾。一句在外人看来平常无奇的「救救她」，则是她对自己外婆最后的复仇。影片也多次通过细节表现了她内心的变化，例如她多次用日语说「我很孤独」，并在脑海中无数次想象自己理直气壮说出Marco与林翩翩私情的情形，以及从病榻上滚下的「罪恶之果」。而她最后对爱情的追求也在Marco的冲撞下化作泡影。</p><p>以上也只是谈谈我对这部电影的看法，更多细节已经在豆瓣许多影评中阐释，这里不再赘述。</p><p>最后向大家推荐这部值得二刷的「血观音」。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近观看了去年台湾金马奖的两大热门：「大佛普拉斯」与「血观音」。两者都是讲述台湾本土故事，如果说前者是道出底层人口的无可奈何，那么后者则是深刻剖析上层权贵的尔虞我诈。&lt;/p&gt;
    
    </summary>
    
    
      <category term="简评" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/"/>
    
      <category term="2018" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/2018/"/>
    
    
      <category term="剧情" scheme="http://yoursite.com/tags/%E5%89%A7%E6%83%85/"/>
    
      <category term="简评" scheme="http://yoursite.com/tags/%E7%AE%80%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>我的2017年个人总结</title>
    <link href="http://yoursite.com/2017/12/31/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/2017%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/12/31/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/2017%E6%80%BB%E7%BB%93/</id>
    <published>2017-12-31T13:46:12.000Z</published>
    <updated>2019-12-09T06:57:26.410Z</updated>
    
    <content type="html"><![CDATA[<p>年终总结，既是对一年的回顾，又是对未来的展望。</p><a id="more"></a><p>先说一下完成的大事，年初本以为达不成这个目标，没想到最终顺利完成。过程也很曲折，柳暗花明，说好听点是学业上又步入了一个阶段，说难听点就是为自己的胆小怯弱又找到了三年的缓冲期。不过我很期待新的生活。</p><p>年初立志要司考，最终也不了了之，很是惭愧。但依旧收获满满，法律是人类行为的准则，但身边很少人具备基本的法律常识，以致于面对有争议的事件时，大多数人选择了站队，人云亦云。</p><p>暑假在北京呆了一个月，感受了现实北京的残酷。但实习的单位很好，每个人都给予了我足够多的帮助，也发生了不少值得思考的事情。</p><p>年中开始锻炼身体，现在身体得到明显改善，再接再厉。</p><p>我一直相信<strong>「教育是打破阶级固化的唯一途径」</strong>，即使生活再累再苦，步入中产意味着我的后辈实现了阶级上的飞跃。</p><p>但是面对大不公，我们也只能做围观群众，一面撸起袖子加油干，继续把自己累个半死；一面幸灾乐祸，庆幸厄运不是发生在自己头上，继续像蝼蚁一样活下去。</p><p>为众抱薪者，都已死绝。</p><p>这一年看了不少电影，参加了一次影展，去了四座城市，做了4个视频，写了7篇影评。摄影从入门到进阶，Python从入门到放弃，看到许多美好的事情，也发掘了不一样的世界。</p><hr><p>对2018年的一些计划：</p><p><strong>1. 锻炼身体，克服坏习惯</strong></p><p>继续健身，早点睡觉，少去怼人，用爱感化。</p><p><strong>2. 旅行，摄影，学习</strong></p><p>掌握新的技能，记录不一样的世界。</p><p><strong>3. 应对各种糟糕的事情</strong></p><p>糟糕的事情总是毫无征兆，未来应对这些事情时能够更加成熟。</p><p><strong>4. 发掘新事物</strong></p><p>普通的生活如此之难，自己也不希求有大起大落，保持乐观，面对未来，这就是生活的一切。</p><p>感谢所有帮助过我的人，感谢一切美好事物。</p><p>新年快乐。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;年终总结，既是对一年的回顾，又是对未来的展望。&lt;/p&gt;
    
    </summary>
    
    
      <category term="我的年度个人总结" scheme="http://yoursite.com/categories/%E6%88%91%E7%9A%84%E5%B9%B4%E5%BA%A6%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="个人总结" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>「喜丧」简评</title>
    <link href="http://yoursite.com/2017/12/27/%E7%AE%80%E8%AF%84/%E3%80%8C%E5%96%9C%E4%B8%A7%E3%80%8D%E7%AE%80%E8%AF%84/"/>
    <id>http://yoursite.com/2017/12/27/%E7%AE%80%E8%AF%84/%E3%80%8C%E5%96%9C%E4%B8%A7%E3%80%8D%E7%AE%80%E8%AF%84/</id>
    <published>2017-12-27T13:46:12.000Z</published>
    <updated>2019-12-09T06:16:10.151Z</updated>
    
    <content type="html"><![CDATA[<p>「喜丧」获得第10届FIRST青年电影展最佳影片和最佳导演，前几天观看了这部电影。</p><a id="more"></a><p>农村85岁老人含辛茹苦拉扯大六个孩子，到老来却难享天伦之乐，在突发脑血栓后，子女们纷纷想把老人送去敬老院。在子女轮流照看老人期间，发生了许多令人寒心的事情。</p><p>影片分为三个部分，场景分别发生在三个子女家庭中，这其中也有三个关键词。</p><h2 id="三儿子：外面的世界"><a href="#三儿子：外面的世界" class="headerlink" title="三儿子：外面的世界"></a>三儿子：外面的世界</h2><p>影片中有多处细节反映农村青年在外务工的现状，三儿子年轻的时候出来闯荡，生活条件是同辈人中相对较好的，但是在三孙女想去浙江时遭到了父母一致反对，反应最强烈的莫过是三儿媳。她蔑视婆婆，希望自己的女儿留在家中找个条件不错的女婿。</p><p>老人却是相当开明，鼓励三孙女出外闯荡。在三孙女去的车站里放的是黄渤的「我的要求不算高」，也反映了当代青年的心境。</p><h2 id="四女儿：笑病"><a href="#四女儿：笑病" class="headerlink" title="四女儿：笑病"></a>四女儿：笑病</h2><p>四女儿和四女婿开的是一家杂货铺，在二人怀疑老人偷了钱之后，老人精神受到刺激，得了笑病，以至于老人时不时就会突然笑起来。在四外孙外出务工去世后，全家人沉浸在悲痛的气氛中，老人却是突然大笑。</p><p>到后来老人的笑受到了子女的不解，并对其恶语相加，老人依然大笑，但老人内心却是异常痛苦，笑声却像是哭声。</p><h2 id="二儿子：菩萨"><a href="#二儿子：菩萨" class="headerlink" title="二儿子：菩萨"></a>二儿子：菩萨</h2><p>老人随身携带的物件是一尊瓷质菩萨，不管到哪里都要拜一拜，保佑子女平平安安。在遭到三儿媳的谩骂后，老人唯一一次为自己祷告。在遭到二儿媳驱赶住到牛棚里的时候，老人仍在拜菩萨，二儿子面对妻子的嫌弃和老母的怪笑，一怒之下砸碎了菩萨。自那以后老人就一直问敬老院的来信。</p><p>菩萨是老人的精神寄托，丈夫早亡，独自一人乞讨养活了六个孩子，晚年子女不孝，只能寄托于菩萨。在菩萨被砸碎后，老人对这个世界的唯一眷恋也随之破碎，在子女送她去敬老院的前一天，老人吞药自杀。</p><h2 id="喜丧"><a href="#喜丧" class="headerlink" title="喜丧"></a>喜丧</h2><p>老人并非寿寝而终，但子女却为其置办了喜丧，在舞台脱衣舞的表演中，子女的麻木不仁，台下老人的黑白遗照和舞台中央的「祭」字显得极为讽刺。影片的最后二儿媳也同样倒在地上，没有音乐，影片在沉寂中结束。</p><p><strong>我个人认为这是一部聚焦农村人口的电影，并非人性。这部电影英文名叫「Laughing to Die」，无时不刻讽刺着这个笑着死去的中国梦，将她最痛苦的那层伤疤撕开给人看。</strong></p><p>子女们并非都没有孝心，二儿子在老人去世前一晚对老人忏悔。在老人把传家宝送给二儿媳的时候，二儿媳假仁假义地寒暄了几句，便问「还有什么好东西吗？再给我点」。他们都是迫于生计，正如影片中一句台词「有钱走遍天下，没钱寸步难行」。<strong>儿女一多，也会计较个人付出的多少，孝顺的性质也就发生了变化。</strong></p><p>影片的镜头语言非常直白，也大胆启用非专业演员，二儿媳就像是个农村悍妇。真心呼吁大家可以多多关注这些小成本独立电影，不要用制作粗糙绑架他们，年轻导演可以关注到中国农村人口的残酷生活现状，难能可贵。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;「喜丧」获得第10届FIRST青年电影展最佳影片和最佳导演，前几天观看了这部电影。&lt;/p&gt;
    
    </summary>
    
    
      <category term="简评" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/"/>
    
      <category term="2017" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/2017/"/>
    
    
      <category term="剧情" scheme="http://yoursite.com/tags/%E5%89%A7%E6%83%85/"/>
    
      <category term="简评" scheme="http://yoursite.com/tags/%E7%AE%80%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>「芳华」简评</title>
    <link href="http://yoursite.com/2017/12/21/%E7%AE%80%E8%AF%84/%E3%80%8C%E8%8A%B3%E5%8D%8E%E3%80%8D%E7%AE%80%E8%AF%84/"/>
    <id>http://yoursite.com/2017/12/21/%E7%AE%80%E8%AF%84/%E3%80%8C%E8%8A%B3%E5%8D%8E%E3%80%8D%E7%AE%80%E8%AF%84/</id>
    <published>2017-12-21T13:46:12.000Z</published>
    <updated>2019-12-09T06:11:01.726Z</updated>
    
    <content type="html"><![CDATA[<p>简评主要关注其电影本身而非议论揣测。</p><a id="more"></a><p>前几天有幸在平遥国际电影展上观摩了这部电影。虽然在寒风中冻了四个小时，但是整体观影体验不错，最出彩的就是那饱受争议的6分钟长镜头，写实程度在国内战争片中极为罕见。 </p><p>本片重点描写70年代到90年代间中国发生的一系列重大事件中文工团这一群体的变迁，典型的大时代下的纪实人物电影。这其中就不免会涉及一些敏感话题，这也是本片的一大看点。</p><p>但是，冯小刚在这部电影中堆砌的东西实在太多，导致整部电影的主题模糊。文工团是摧残何小萍这类局外人的集权主义代表，而文工团则是那个时代的产物，我大胆猜想冯小刚真实的意思是批判那个时代。就连影片的结尾刘峰、肖穗子、郝淑雯三人重逢的场景中，肖郝二人还是认为当年刘峰确实猥亵的林丁丁，这也加重了刘峰人物的悲剧色彩。但是不知怎么，这种时代批判莫名其妙转化为青春赞歌，最后那个文工团告别仪式堪称影片中最大的败笔，伤害了何小萍和刘峰的集体居然要花大笔墨去写他们的引吭高歌，这也是我最不能理解的。并不是说林丁丁、郝淑雯等人没有资格缅怀青春，只是放在「芳华」整部电影背景下，她们的缅怀显得十分突兀。 </p><p>冯小刚想拍属于自己的史诗，影片中人物的服饰发型和广告牌都在体现着时代的变迁。但是，刻意渲染未免也有些造作，影片完全可以花些时间来讲何刘二人。类似像这种大时代下的人物纪实电影，最重要的一条就是单线叙事，主人公可以是事件的旁观者参与者甚至是缔造者，但是唯独不能有和主线同等地位的故事线存在。这也是为什么某些游戏大作有超越史诗电影的趋势。 </p><p>有些人可能对冯小刚比较反感，坊间也有关于他的流言蜚语。冯小刚近几年拍的这些电影都会涉及一些敏感话题，不断挑战当局的红线，也算是为下一代的电影创作营造一个更好的环境。反观第五代导演的其他几人，早年都有反响不菲的作品，而现在却也是音信杳无，只有冯小刚不甘向庸俗趣味妥协，坚持基本的道德良心，认真拍经得起时间流逝的电影，难能可贵。</p><p>期待未来有更多优秀的国产电影问世。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简评主要关注其电影本身而非议论揣测。&lt;/p&gt;
    
    </summary>
    
    
      <category term="简评" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/"/>
    
      <category term="2017" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/2017/"/>
    
    
      <category term="剧情" scheme="http://yoursite.com/tags/%E5%89%A7%E6%83%85/"/>
    
      <category term="简评" scheme="http://yoursite.com/tags/%E7%AE%80%E8%AF%84/"/>
    
      <category term="战争" scheme="http://yoursite.com/tags/%E6%88%98%E4%BA%89/"/>
    
  </entry>
  
</feed>
