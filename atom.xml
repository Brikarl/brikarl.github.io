<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>吸口好时光</title>
  
  <subtitle>读书观影写字</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-28T10:49:54.715Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Brikarl</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>材料人转行互联网的春招面经</title>
    <link href="http://yoursite.com/2020/03/28/%E6%9D%82%E8%AE%B0/%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F/"/>
    <id>http://yoursite.com/2020/03/28/%E6%9D%82%E8%AE%B0/%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F/</id>
    <published>2020-03-28T03:54:13.000Z</published>
    <updated>2020-03-28T10:49:54.715Z</updated>
    
    <content type="html"><![CDATA[<p>大家好呀。</p><p>受疫情的影响，今年的「金三银四」总有些和往年的不同，几乎所有的面试都转为视频和电话面试。我也通过过去半年的学习，一边投递互联网开发岗位，一边继续学习新的知识。接下来就说一下最近这一个月的面试过程，也算是对自己学习的复盘。</p><a id="more"></a><p>招聘信息大多来自<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">牛客网</a>，由于有着大三下学期的「夏令营」经验，开启了海投模式。那个时候的简历也是无比粗糙，在「图森未来」的 HR 小姐姐的帮助下，改进了自己的简历，效果也是显著。</p><p>就这样，我收到了一系列笔试和面试。</p><h2 id="阿里搜索推荐中台"><a href="#阿里搜索推荐中台" class="headerlink" title="阿里搜索推荐中台"></a>阿里搜索推荐中台</h2><p>帮我内推的小哥哥相当热情，对我简历也有很正面的评价。即使在飞书面试失利后，也热情地邀请我去他们部门面试。</p><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>一面距离比较久了，很多记得也不是特别清楚，大多都是问了些死锁、三次握手的一些高频知识点。</p><p>那个时候也是比较紧张，而且那天我的嗓子开始发炎，也有低热的症状，很多知识点答的也没有太多的逻辑可言。后来就是喜闻乐见的做题环节。第一道题目是<strong>判断一颗二叉搜索树</strong>，中序遍历判断是否为升序即可；第二道题目是<strong>判断是否有重复元素</strong>，用 Python 的 Set 可以很容易的解出，但是我那个时候用的是散列表查询。</p><p>总体来说，感觉并不是特别理想，包括反问环节，面试官也没有透露太多的信息。</p><p>后来一周由于发炎高烧的缘故，推掉了很多面试笔试。</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>二面的话面试官相当友善，即使我有些问题回答的不大好，面试官也会友善地说没关系，之后你可以下去看看。问的也是很多基础知识，无外乎也是些高频题目，这里不在赘述。</p><p>问的算法题目也不是很难，第一道是<strong>找出第 K 大的数</strong>，我的回答是新建一个散列表存放前 K 大的元素，随后遍历来比较数组中的每一个元素。但是这样的话开辟新的空间，可以通过快排的思想进行排序，Pivot 前面的数比自己大，后面是数比自己小，当 Pivot 为倒数第 K 个的元素时，那么 Pivot 就是我们要找的数。</p><p>在后来的反问环节，面试官也对我的基础有着比较正面的评价，也嘱咐我多去练习一些项目。总体来说是到目前为止最好的面试体验。</p><h2 id="钉钉"><a href="#钉钉" class="headerlink" title="钉钉"></a>钉钉</h2><p>钉钉是我自己投的简历，可能因为阿里的系统只可以投递一个部门，所以把我上一个投递覆盖掉了，所以上一次的面试也没有了后续。钉钉无疑是目前为止最不理想的面试。</p><h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><p>面试官刚上来也没有自我介绍，问了意向的工作地点、实习时间就开始了面试。</p><p>第一道问题是<strong>虚拟内存</strong>，但是那个时候有点儿卡壳，后来才想起来，面试官一直在电话那头说你是不是不知道，也造成了一定干扰。</p><p>面试中问到了<strong>伙伴系统</strong>，恰巧我之前学习过，也说出来其中的原理，但是面试官要求用代码实现，没有答出来。</p><p>后来问到<strong>排序算法</strong>，这部分按照时间复杂度的顺序答了出来。这个时候面试官又问<strong>堆排序</strong>的代码实现，和上道题目一样，只知道原理。</p><p>最后问了一个「剑指 Offer」的<a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/" target="_blank" rel="noopener">第 21 题</a><strong>调整数组顺序使奇数位于偶数前面</strong>，但是那个题目我没有见过（还是刷题太少），要求 O(n) 的时间复杂度和 O(1) 的空间复杂度，一开始我没有理解题目，以为还要求奇数和偶数都要分别排序，和面试官确认题目就浪费了不少时间。但是后来想到了双指针分别查找奇数和偶数的方法，和面试官说了自己的想法后，没想到被否认了，比较可惜。</p><p>后来也没有反问环节，总体还是面试体验不佳。</p><h2 id="飞书"><a href="#飞书" class="headerlink" title="飞书"></a>飞书</h2><h3 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h3><p>飞书的面试是视频面试，用的是牛客网的面试系统。</p><p>一开始就是我们喜闻乐见的做题环节，一道<strong>平分周长</strong>的问题，后来磕磕绊绊写出来了。</p><p>之后就是面试题目，不得不说飞书的面试不怎么考高频的面试题，比如一般 TCP 大家都会问<strong>三次握手</strong>和<strong>四次挥手</strong>，但是面试官问的是<strong>滑动窗口</strong>。当然也问到了数据库的问题，这个是之前面试没有问过的。</p><p>反问环节给我的反馈也是多去练习，代码可复用性不强。</p><h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><p>三天后收到了二面通知，同样是视频面试。</p><p>还是喜闻乐见的做题环节，第一道题目就是要写一个 <strong>Retry 的装饰器</strong>，不会，只写了装饰器的模板。</p><p>第二道是<strong>八皇后</strong>问题，上一次看八皇后是两周之前，当时只记得判断条件是 x - y 和 x + y，只和面试官说了这些，实际上代码的实现还是比较简单的，有点可惜。</p><p>后来就问 <strong>Hashset</strong> ，但是那个时候 Python 是主要语言，Java 的确认了解不多，只和面试官说了 Hashmap，这个明显是不过关的。</p><p>于是，就到了反问环节，面试官也很中肯地给出了建议。总结一下，飞书的面试确实不会问高频的面试题目，反而会问些与之相关的问题，这样可以检验对方是刷面经还是真正的学习。</p><p>一天之后转岗到教育业务。</p><h2 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h2><p>腾讯的状态很早就变了，但是过了几天才发起了面试通知，听声音感觉面试官年纪不小，态度很好，称谓都是「您」，着实让我震惊。</p><h3 id="一面-3"><a href="#一面-3" class="headerlink" title="一面"></a>一面</h3><p>腾讯没有问算法相关的问题。看到我用 Python 就问了<strong>装饰器</strong>的问题，还有 <strong>HTTP</strong> 的问题，还有<strong>数据库</strong>的问题。最后问了一个<strong>银行转账的余额变化</strong>的问题，之前看过用 Python 多线程实现火车余票查询的问题，于是就答了线程和锁，但是面试官不是特别满意，所以就说了<strong>乐观锁</strong>。</p><p>值得一提的是面试官问的问题很泛，并不会问具体的一个问题，所以我回答的也会比较多一些。面试官边听我的回答边会在黑板上记录。而且，有些问题我不知道，面试官也不会深究。</p><hr><p>之前学 TOEFL 的时候，口语老师津津乐道的故事就是一个学生没有报班，而是报了十几次考试，从 20 分考到了 70 分。</p><p>这段经历也是十分有趣，有给予我帮助的朋友们，也有对我提出批评的朋友。总的来说是对我有帮助的，这样我可以更好的查漏补缺，为自己秋招做好完善的准备。</p><p>最后还是要更加努力地去刻意练习算法题，更要去完善自己不熟悉的<strong>数据库</strong>和 <strong>Java</strong> 的知识。</p><hr><p>最后，和大家分享一下我的学习资料：</p><ol><li><p><a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">CS-Notes</a></p><p>这是一名字节跳动拿到 SSP 的前辈总结的知识，每一个知识点都很详细，但是两年过去了，很多新的知识需要自己补充，但是用来查漏补缺也是很不错的。</p></li><li><p><a href="https://time.geekbang.org/column/intro/126" target="_blank" rel="noopener">数据结构与算法之美</a></p><p>如果只能推荐一个 APP 的话，那我只推荐<strong>极客时间</strong>，学生也有半价优惠。其中很多基础知识点都会用在工程中的实例来表现，能够更好地理解。</p></li><li><p><a href="https://time.geekbang.org/column/intro/82" target="_blank" rel="noopener">Java核心技术面试精讲</a></p><p>这个不多说了，太多高频考点了，看这个我感觉甚至有作弊的嫌疑。</p></li><li><p><a href="https://www.shiyanlou.com/" target="_blank" rel="noopener">实验楼</a></p><p>实践项目的利器，不用费心去搭建环境，能够更专注于其本身的实现。</p></li><li><p><a href="https://github.com/labuladong/fucking-algorithm" target="_blank" rel="noopener">fucking-algorithm</a></p><p>作者是 LeetCode 中文站的高票答主，总结了很多同类算法题目的通用解法，非常适合刷很多题目的朋友建立框架。</p></li></ol><hr><script type="math/tex; mode=display">To\ Be\ Continued...</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家好呀。&lt;/p&gt;
&lt;p&gt;受疫情的影响，今年的「金三银四」总有些和往年的不同，几乎所有的面试都转为视频和电话面试。我也通过过去半年的学习，一边投递互联网开发岗位，一边继续学习新的知识。接下来就说一下最近这一个月的面试过程，也算是对自己学习的复盘。&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂记" scheme="http://yoursite.com/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="面经" scheme="http://yoursite.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>面对「疫情」，我们或许可以先做这些事</title>
    <link href="http://yoursite.com/2020/02/19/%E6%9D%82%E8%AE%B0/%E7%96%AB%E6%83%85/"/>
    <id>http://yoursite.com/2020/02/19/%E6%9D%82%E8%AE%B0/%E7%96%AB%E6%83%85/</id>
    <published>2020-02-19T03:54:13.000Z</published>
    <updated>2020-02-19T07:25:36.136Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/02/19/%E6%9D%82%E8%AE%B0/%E7%96%AB%E6%83%85/1.jpg" class=""> <p>大家好呀，好久不见。</p><p>上班的朋友都复工了嘛？无法返校的同学看文献了嘛？</p><a id="more"></a><p>由于我专业方向是计算模拟，再加上学校最近也开放了超算的使用权限，除了在家处理数据之外，闲暇之余也会学习些计算机的相关知识。所以，基本学习还算是有条不紊。</p><p>可是，对于其他朋友来说，影响是比较大的，无法返校不能做实验，对中期审查乃至毕业都可能会有影响。</p><p>那么，对于这次甚至未来的<strong>黑天鹅事件</strong>，我们普通人可以先做哪些事情呢？</p><p>首先，我们来看一下什么是<strong>黑天鹅事件</strong>。</p><p>所谓<strong>黑天鹅</strong>，指的是事前无法预知、但是具有重大影响力的不确定性事件。这次事件就是<strong>黑天鹅事件</strong>。没有人预料到它的到来，<strong><a href="http://www.caixin.com/2020-01-23/101507670.html" target="_blank" rel="noopener">几乎所有人都低估了它的影响力</a></strong>。</p><p>面对黑天鹅，可以很悲观地说，我们既没有办法来预测它，也没有办法去避免它，甚至会低估它。它就像特洛伊木马，一夜之间倾巢而出，警报的拉响也是姗姗来迟。</p><p>那我们换个角度，既然未来无法预测也无法避免，那要做些什么才能<strong>扛得住黑天鹅事件对自己的打击</strong>呢？我从一个应届生的角度给出我的看法：</p><h3 id="1-选择一个合适的城市"><a href="#1-选择一个合适的城市" class="headerlink" title="1. 选择一个合适的城市"></a>1. 选择一个合适的城市</h3><p>全国范围内<strong>第一梯队</strong>的城市的很多，从房价就可见一斑，市场做出了对城市的教育、医疗、公共资源的选择。但是，不同地区应对突发公共事件的能力确实有很大的差异。截至目前，某省确诊病例 1173 例，却无一死亡，这很难说是运气成分。</p><p>这次事件也是对不同地区的公开测验，结果一目了然。</p><h3 id="2-准备风险储备金"><a href="#2-准备风险储备金" class="headerlink" title="2. 准备风险储备金"></a>2. 准备风险储备金</h3><p>我刚开始学习理财的时候，除了买保险之外的第一件事就是要准备 6 个月的<strong>风险储备金</strong>，以备不时之需。面对几个月的空档期，会需要足够的现金周转，解决生计。</p><h3 id="3-控制负面信息的摄入"><a href="#3-控制负面信息的摄入" class="headerlink" title="3. 控制负面信息的摄入"></a>3. 控制负面信息的摄入</h3><p>人常说兼听则明，可过多的信息反而会对我们形成干扰，潜意识里我们会做出错误假设，而我们对于已经形成的认知又很难去改变。尤其是过量的负面信息会让有同理心的我们陷入<strong>感同身受</strong>的境地，情绪也会随之失控。我们需要做的则是控制负面信息的摄入，让自己回到真实的生活中。</p><h3 id="4-建立生活秩序"><a href="#4-建立生活秩序" class="headerlink" title="4. 建立生活秩序"></a>4. 建立生活秩序</h3><p>日常工作和生活都无法正常运行的情况，我们的情绪也会失序，这样我们大部分精力都会花在无意义的事情上。</p><p>而这也是个契机，这段时间里没有工作学习的压力，可以趁这个机会去做一些很久之前想做的事，学习新的技能，重新建立起生活的秩序。储备子弹，抓住契机。</p><hr><p>这段时间里，我们每个人都经历过不安、惶恐、愤怒的情绪。一些事情我们确实无法改变，这会让我们产生无力感。可自身生活的方向盘就在我们手中，这是可以掌控的。目前生活的秩序都是医生恪尽职守、外卖物流有条不紊、科研学者尽心尽力所维护的。没有什么英雄主义，也没有什么运筹帷幄，每个人各司其职，做好了自己应该做的事。</p><p><a href="https://brikarl.github.io/2018/12/31/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/2018%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">2018 年初我经历了一段低谷期</a>，我在那个时候写过一段话：</p><blockquote><p>自己做的一切可能真的很难改变现状，但是不经意间的一个善举就会给身边的人带来莫大的温暖。而这，也许是在这个世界中我们依旧呼吸与共的理由吧。</p></blockquote><p>谢谢你，谢谢每一个认真工作的你。</p><hr><p>题图：2020 年 1 月 20 日摄于 G683 次列车，7 天后，那趟车里确诊了一例新冠肺炎患者。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2020/02/19/%E6%9D%82%E8%AE%B0/%E7%96%AB%E6%83%85/1.jpg&quot; class=&quot;&quot;&gt; 
&lt;p&gt;大家好呀，好久不见。&lt;/p&gt;
&lt;p&gt;上班的朋友都复工了嘛？无法返校的同学看文献了嘛？&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂记" scheme="http://yoursite.com/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="风险管控" scheme="http://yoursite.com/tags/%E9%A3%8E%E9%99%A9%E7%AE%A1%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>4 线程</title>
    <link href="http://yoursite.com/2020/02/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4%20%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/02/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4%20%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-02-17T05:53:53.000Z</published>
    <updated>2020-02-18T14:54:03.738Z</updated>
    
    <content type="html"><![CDATA[<p>上一章我们介绍了<strong>内存管理</strong>的相关知识，了解了操作系统是如何让每个进程「独享」 内存空间的。</p><p>这一章我们来介绍操作系统的<strong>线程</strong>知识，在实际过程中，多个线程可能要共同访问同一段空间，如何让他们彼此协调工作，就是我们这一章讨论的话题。</p><a id="more"></a><h2 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h2><p>通过前面两章的学习，我们了解了操作系统如何将一个物理 CPU 变成多个虚拟 CPU，从而使多个程序「同时」运行；还了解到为每个进程创建「独享」的虚拟内存。</p><p>下面我们来介绍<strong>线程</strong>（thread），线程是进程的一部分，单个线程类似于独立的进程，只不过线程<strong>共享</strong>内存地址，而且线程有各自的寄存器和堆栈。</p><h3 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h3><p>多个线程会共享同一存储空间，下面我们用生活中的例子来描述一下可能发生的情况。</p><p>当家里的冰箱中没有面包时，就需要去采购面包。假设你和你的女朋友是两个线程，冰箱就是内存，面包就是数据。有时候，当你发现没有面包的时候，你就会去买面包，但是在你买面包的途中，你的女朋友也发现没有面包，那么她也会去买面包，最终冰箱中就会有过量的面包，这是我们不希望出现的情况。</p><p>这个时候，我可以在买面包之前留一个便笺，告诉女朋友我已经去买面包了，这样对方也不会去买面包了。伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nobread) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (noNote) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">leave Note;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">buy bread;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">remove</span> Note;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>可是在计算机运行的过程中，会发生<strong>时钟中断</strong>，当一个线程切换到另一个线程的时候，就可能会发生以下情况：</p><img src="/2020/02/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4%20%E7%BA%BF%E7%A8%8B/1.png" class="" title="线程"> <p>当线程 A 执行到第 2 行时，这时发生时钟中断，切换到线程 B，此时线程 B 检查过后发现并没有面包和便笺，于是继续会去买面包，最终也会有过量的面包。</p><p>那我先留便笺，女朋友看到之后就知道我去买面包了，伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">leave Note;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nobread) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (noNote) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        buy bread;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">remove</span> note;</span></pre></td></tr></table></figure><p>我们再来看看实际情况：</p><img src="/2020/02/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4%20%E7%BA%BF%E7%A8%8B/2.png" class="" title="线程"> <p>当我们两个人都留下便笺之后，我们都会认为对方去买面包了，就不会也面包了。</p><p>那我们来看一个更大胆的设想，在使用冰箱前我先加一把锁，只有我可以打开，那么伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">breadlock.Acquire();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nobread) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    buy bread;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">breadlock.Release();</span></pre></td></tr></table></figure><p>这样即使切换到另一个线程，对方也打开不冰箱。</p><p>通过上面这个例子，我们得出几个概念：</p><ul><li><strong>临界区</strong>（critical section）：访问共享资源的一段代码，比如我们买面包就是临界区。</li><li><strong>互斥</strong>（mutual exclusion）：一个进程占用资源，其它进程不能使用。</li><li><strong>死锁</strong>（deadlock）：多个进程各占用部分资源，形成循环等待。</li><li><strong>饥饿</strong>（starvation）：其他进程可能轮流占用资源，一个进程一直得不到资源。</li><li><strong>锁</strong>（lock）：<code>Lock::Acquire()</code>在锁被释放前一直等待，然后得到锁。<code>Lock::Release()</code>释放锁，唤醒任何等待的线程。</li></ul><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p><strong>信号量</strong>（semaphore）由一个整形 (sem)变量和两个原子操作组成：</p><ul><li><strong>P()</strong><ul><li>sem 减 1；</li><li>如果 sem ＜ 0 ，进入等待，否则继续。</li></ul></li><li><strong>V()</strong><ul><li>sem 加 1；</li><li>如果 sem ≥ 0 ，唤醒一个等待线程。</li></ul></li></ul><p>锁（mutex）可以看作是 sem 最大值为 1 的信号量，锁更倾向于使用权，信号量则适用于资源管理。</p><h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h3><p>下面，我们用信号量和锁解决一个经典问题：</p><p>有生产者和消费者，生产者在生成数据后放入一个缓冲区中，单个消费者从缓冲区取出数据，但是任何时刻只有一个生产者或消费者可访问缓冲区。</p><p>在这个情况中，我们可以分析成如下条件：</p><ul><li>任何时刻只能有一个线程操作缓冲区（<strong>互斥访问</strong>）</li><li>缓冲区空时，消费者必须等待生产者；缓冲区满时，生产者必须等待消费者（<strong>条件同步</strong>）</li></ul><p>于是，我们就需要信号量来描述每个约束：</p><ul><li><strong>mutex</strong>：互斥；</li><li><strong>fullBuffers</strong>：充满的缓冲区；</li><li><strong>emptyBuffers</strong>：空闲的缓冲区。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 信号量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Class BoundedBuffer &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    mutex = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    fullBuffers = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    emptyBuffers = <span class="keyword">new</span> Semaphore(n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">BoundedBuffer::Deposit(c) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    emptyBuffers-&gt;P(); </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    mutex-&gt;P(); </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    Add c to the <span class="built_in">buffer</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    mutex-&gt;V();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    fullBuffers-&gt;V();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费者</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">BoundedBuffer::Remove(c) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    fullBuffers-&gt;P();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    mutex-&gt;P();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    Remove c from <span class="built_in">buffer</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    mutex-&gt;V();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    emptyBuffers-&gt;V();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>我们可以看到，消费者先运行，当消费者执行第 17 行时，缓冲区没有数据，fullBuffers 初始值为 0，减为 -1，消费者睡眠。</p><p>假设生产者开始生产，emptyBuffers 初始值为 n ，所以继续执行，到第 13 行时为fullBuffers 增加信号量，唤醒消费者，消费者可以执行。</p><h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><p>下面，我们来讨论一个经典的并发问题，<strong>哲学家就餐问题</strong>。</p><p>假定有 5 位哲学家围着一个圆桌。每两位哲学家之间有一把餐叉（一共 5 把）。哲学家有时要思考一会，不需要餐叉；有时又要就餐。而一位哲学家只有同时拿到了左手边和右手边的两把餐叉，才能吃到东西。</p><img src="/2020/02/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4%20%E7%BA%BF%E7%A8%8B/3.png" class="" title="哲学家就餐问题"> <p>在实际情况中，我们可能会遇到五位哲学家同时拿起左边餐叉的情况，这样就会导致死锁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5<span class="comment">// 哲学家个数</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">semaphore fork[<span class="number">5</span>];<span class="comment">// 信号量初值为1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span><span class="comment">// 哲学家编号：0 － 4</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function">    <span class="title">while</span><span class="params">(TRUE)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function">    </span>&#123;      </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        think( );<span class="comment">// 哲学家在思考</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">P(fork[i]);<span class="comment">// 去拿左边的叉子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">P(fork[(i + <span class="number">1</span>) % N]);<span class="comment">// 去拿右边的叉子     </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        eat( );<span class="comment">// 吃面条中……</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">V(fork[i]);<span class="comment">// 放下左边的叉子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        V(fork[(i + <span class="number">1</span>) % N ]);<span class="comment">// 放下右边的叉子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure><p>于是，我们可以想得极端一些，只允许一个吃饭，这就需要<strong>锁</strong>（mutex）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5<span class="comment">// 哲学家个数</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">semaphore fork[<span class="number">5</span>];<span class="comment">// 信号量初值为1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">semaphore mutex;<span class="comment">// 互斥信号量，初值1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span><span class="comment">// 哲学家编号：0 － 4</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function">    <span class="title">while</span><span class="params">(TRUE)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function">    </span>&#123;      </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        think( );<span class="comment">// 哲学家在思考</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        P(mutex);<span class="comment">// 进入临界区</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">P(fork[i]);<span class="comment">// 去拿左边的叉子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">P(fork[(i + <span class="number">1</span>) % N]);<span class="comment">// 去拿右边的叉子     </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        eat( );<span class="comment">// 吃面条中……</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">V(fork[i]);<span class="comment">// 放下左边的叉子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        V(fork[(i + <span class="number">1</span>) % N ]);<span class="comment">// 放下右边的叉子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        V(mutex);<span class="comment">// 退出临界区</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure><p>这样确实访问正确，但是只允许一个人就餐未免效率也太低了些。我们可以让不同的哲学家拿起不同的餐叉，这样可以让多人同时就餐。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5<span class="comment">// 哲学家个数</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">semaphore fork[<span class="number">5</span>];<span class="comment">// 信号量初值为1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">semaphore mutex;<span class="comment">// 互斥信号量，初值1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span><span class="comment">// 哲学家编号：0 － 4</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function">    <span class="title">while</span><span class="params">(TRUE)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function">    </span>&#123;      </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        think( );<span class="comment">// 哲学家在思考</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i%<span class="number">2</span> == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            P(fork[i]);<span class="comment">// 去拿左边的叉子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            P(fork[(i + <span class="number">1</span>) % N]);<span class="comment">// 去拿右边的叉子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            P(fork[(i + <span class="number">1</span>) % N]);<span class="comment">// 去拿右边的叉子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            P(fork[i]);<span class="comment">// 去拿左边的叉子 </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        &#125;          </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        eat( );<span class="comment">// 吃面条中……</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">V(fork[i]);<span class="comment">// 放下左边的叉子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        V(fork[(i + <span class="number">1</span>) % N ]);<span class="comment">// 放下右边的叉子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure><h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h3><p>另一个经典问题关注的是更加灵活的协同访问，不同类型的访问可能需要不同的锁。例如，一个并发链表有很多插入和查找操作。插入操作会修改链表的状态，而查找操作只是读取该结构，只要没有进行插入操作，我们可以并发的执行多个查找操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写者</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">P(WriteMutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">write</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">V(WriteMutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读者</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">P(CountMutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Rcount == <span class="number">0</span>)<span class="comment">//如果是第一个读者获得写锁</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">P(WriteMutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">++Rcount;<span class="comment">//后续读者无需获得锁</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">V(CountMutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">P(CountMutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">--Rcount;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Rcount == <span class="number">0</span>)<span class="comment">//如果是最后一个读者解除写锁</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">V(WriteMutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">V(CountMutex)</span></pre></td></tr></table></figure><p>可以看到，只要有读者在读的状态，后续的读者就能直接进入，这样，会导致写者饥饿</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁（deadlock）是一种在许多复杂并发系统中出现的经典问题。例如，当线程 1 持有锁 L1，正在等待另外一个锁 L2，而线程 2 持有锁 L2，却在等待锁 L1 释放时，死锁就产生了。</p><img src="/2020/02/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4%20%E7%BA%BF%E7%A8%8B/4.png" class="" title="死锁"><h3 id="产生死锁的条件"><a href="#产生死锁的条件" class="headerlink" title="产生死锁的条件"></a>产生死锁的条件</h3><p>我们来看看死锁需要的条件：</p><ul><li><strong>互斥</strong>：线程对于需要的资源进行互斥的访问（例如一个线程抢到锁）。</li><li><strong>持有并等待</strong>：线程持有了资源（例如已将持有的锁），同时又在等待其他资源（例如，需要获得的锁）。</li><li><strong>非抢占</strong>：线程获得的资源（例如锁），不能被抢占。</li><li><strong>循环等待</strong>：线程之间存在一个环路，环路上每个线程都额外持有一个资源，而这个资源又是下一个线程要申请的。</li></ul><h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>如果上述 4 个条件的任何一个没有满足，死锁就不会发生。因此，我们首先研究一下预防死锁的方法；每个策略都设法阻止某一个条件，从而解决死锁的问题。</p><ul><li>互斥<ul><li>把互斥的共享资源封装成可同时访问</li></ul></li><li>持有并等待<ul><li>进程请求资源时，要求它不持有任何其他资源</li><li>仅允许进程在开始执行时，一次请求所有需要的资源</li></ul></li><li>非抢占<ul><li>如进程请求不能立即分配的资源，则释放已占有资源</li><li>只在能够同时获得所有需要资源时，才执行分配操作</li></ul></li><li>循环等待<ul><li>对资源排序，要求进程按顺序请求资源</li></ul></li></ul><h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p>除了死锁预防，某些场景更适合死锁避免（avoidance）。我们需要了解全局的信息，包括不同线程在运行中对锁的需求情况，从而使得后续的调度能够避免产生死锁。</p><p><strong>银行家算法</strong>也是死锁避免的一种算法，多名客户向银行家贷多种款项，银行家也知道每名客户的<strong>贷款最大值</strong>，而客户在贷款额满足自己要求前是<strong>不会归还款项</strong>的，因此银行家根据自己手头的<strong>余额</strong>和每名客户<strong>剩余贷款金额</strong>来衡量款项分配尤为重要，银行家对待每名客户的贷款请求也会慎重考虑，避免其他用户无款可贷。</p><p>银行家就是我们的操作系统，客户就是多个线程，多种款项就是多种资源，贷款就是向操作系统申请资源。</p><h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><p>最后一种常用的策略就是允许死锁偶尔发生，检查到死锁时再采取行动。举个例子，很多数据库系统使用了死锁检测和恢复技术。死锁检测器会定期运行，通过构建资源图来检查循环。当循环（死锁）发生时，系统需要重启。如果还需要更复杂的数据结构相关的修复，那么需要人工参与。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章我们介绍了<strong>线程</strong>的知识，先介绍了线程的相关概念，重点介绍了<strong>互斥</strong>，由此引出<strong>信号量</strong>的概念，用信号来实现线程之间的互斥与协同，解决了几个经典问题。最后，对于<strong>死锁</strong>问题，我们又介绍了三种解决方案。</p><p>到目前为止，我们的<strong>操作系统</strong>相关知识就告一段落了。下面我们将介绍<strong>计算机网络</strong>的相关知识，这一部分我也刚刚开始接触，所以更新较慢，大家见谅。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://book.douban.com/subject/33463930/" target="_blank" rel="noopener">雷姆兹·H.阿帕希杜塞尔 / 安德莉亚·C.阿帕希杜塞尔 - 操作系统导论</a></li><li><a href="http://www.xuetangx.com/courses/course-v1:TsinghuaX+30240243X+sp/about" target="_blank" rel="noopener">向勇 / 陈渝 - 操作系统</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一章我们介绍了&lt;strong&gt;内存管理&lt;/strong&gt;的相关知识，了解了操作系统是如何让每个进程「独享」 内存空间的。&lt;/p&gt;
&lt;p&gt;这一章我们来介绍操作系统的&lt;strong&gt;线程&lt;/strong&gt;知识，在实际过程中，多个线程可能要共同访问同一段空间，如何让他们彼此协调工作，就是我们这一章讨论的话题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>3 内存管理</title>
    <link href="http://yoursite.com/2020/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2020/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2020-02-14T05:53:53.000Z</published>
    <updated>2020-02-15T14:09:14.269Z</updated>
    
    <content type="html"><![CDATA[<p>上一章我们介绍了<strong>进程</strong>的相关知识，了解了操作系统是如何让每个进程「独享」 CPU  的。</p><p>这一章我们继续操作系统<strong>虚拟性</strong>的介绍，介绍<strong>内存管理</strong>，将会从<strong>物理内存</strong>开始，介绍其<strong>连续</strong>与<strong>非连续</strong>的存储方式，继而介绍<strong>虚拟内存</strong>，看看内存是如何让进程「共享」内存空间的。</p><p>这部分内容与国内的教材顺序有所不同，国内大部分是将这一章作为线程，且对线程与进程的区分比较模糊。个人认为这样不利于初学者区分进程与线程。这里推荐威斯康星大学计算机科学教授雷姆兹和安德莉亚夫妇编写的<a href="https://book.douban.com/subject/33463930/" target="_blank" rel="noopener">「操作系统导论」</a>（Operating Systems: Three Easy Pieces），以及以此书为参考教材的课程：清华大学<a href="http://www.xuetangx.com/courses/course-v1:TsinghuaX+30240243X+sp/about" target="_blank" rel="noopener">「操作系统」</a>。</p><a id="more"></a><h2 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h2><h3 id="地址转化"><a href="#地址转化" class="headerlink" title="地址转化"></a>地址转化</h3><p>早期计算机中程序中出现的地址就是<strong>物理地址</strong>（Physical address），但是这样同一个程序就无法在不同的机器中使用，因此我们引入<strong>逻辑地址</strong>（Logical address）。</p><p>逻辑地址的生成需要通过程序：编译、汇编、链接这三个步骤。之后借助 CPU 的内存管理单元（Memory Management Unit，MMU）中基址和界限寄存器（base and bounds register），进行动态重定位（dynamic relocation），生成物理地址。转换方式如下：</p><script type="math/tex; mode=display">physical \ address = virtual \ address + base</script><p>进程中使用的内存引用都是逻辑地址，硬件接下来将虚拟地址加上基址寄存器中的内容，得到物理地址，再发给内存系统。如果进程需要访问超过这个界限或者为负数的虚拟地址，CPU 将触发异常，进程最终可能被终止。界限寄存器的用处在于，它确保了进程产生的所有地址都在进程的地址“界限”中。</p><img src="/2020/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1.png" class="" title="地址转化过程"> <h3 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h3><p>在进程调用的过程中，不断有进程终止，因此会产生<strong>外部碎片</strong>（external fragmentation），如何去分配这些未使用的内存，就是我们接下要介绍的动态分区分配策略。比如我们要分配一个 400K 的任务。</p><h4 id="最先匹配（First-Fit-Allocation）"><a href="#最先匹配（First-Fit-Allocation）" class="headerlink" title="最先匹配（First Fit Allocation）"></a>最先匹配（First Fit Allocation）</h4><p>最先匹配要找到第一个足够大的空间。最先匹配有速度优势，但是会让空闲列表开头有很多小块。</p><img src="/2020/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.png" class="" title="最先匹配"> <h4 id="最佳匹配（Best-Fit-Allocation）"><a href="#最佳匹配（Best-Fit-Allocation）" class="headerlink" title="最佳匹配（Best Fit Allocation）"></a>最佳匹配（Best Fit Allocation）</h4><p>最佳匹配需要将空闲列表按大小排序，找到满足且最小的空间。最先匹配尽量避免空间浪费，但是会付出较高的性能代价。</p><img src="/2020/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/3.png" class="" title="最佳匹配"> <p>最差匹配（Worst Fit Allocation）</p><p>最差匹配则与最佳匹配恰恰相反，它会找最大的空间，将其分割后，剩下的块加入空闲列表。</p><img src="/2020/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/4.png" class="" title="最差匹配"> <h4 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h4><p>在内存管理中，空闲空间的合并也非常重要，因此人们设计了<strong>伙伴系统</strong>（Buddy System）。</p><p>在这种系统中，空闲空间被看成大小为 $2^N$ 的空间。当有一个内存分配请求时，空间地址会递归地一分为二，直到整个大小恰好可以满足要求。如下图，我们要申请一个 7KB 的空间：</p><img src="/2020/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/5.png" class="" title="伙伴系统"> <p>这种分配策略只允许分配 $2^n$ 的空闲块，因此会存在<strong>内部碎片</strong>（internal fragment）。</p><p>当块被释放时，8KB 的块归还给空闲列表时，分配程序会检查「伙伴」8KB 是否空闲。如果是，则合二为一，变成 16KB 的块。</p><h2 id="非连续内存分配"><a href="#非连续内存分配" class="headerlink" title="非连续内存分配"></a>非连续内存分配</h2><p>之前我们讨论的是连续内存分配，即最小单位为每个程序的内存。每个程序的物理内存必须连续，这样也会产生内部碎片和外部碎片。我们下面介绍非连续内存分配的方式。</p><h3 id="段式存储管理（Segmentation）"><a href="#段式存储管理（Segmentation）" class="headerlink" title="段式存储管理（Segmentation）"></a>段式存储管理（Segmentation）</h3><p>对进程空间而言，可分为程序代码、堆、栈等。我们可以将这些段对应实际内存空间的块。硬件在地址转换时使用段寄存器，如下图所示，$s$ 表示段号，$addr$ 代表段内偏移量。</p><img src="/2020/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/6.png" class="" title="段访问机制"> <h3 id="页式存储管理（Paging）"><a href="#页式存储管理（Paging）" class="headerlink" title="页式存储管理（Paging）"></a>页式存储管理（Paging）</h3><p>对于段式管理机制而言，段内依旧连续，因此我们提出了更加灵活的存储管理机制：<strong>分页</strong>。首先我们要区分几个概念：</p><ul><li><strong>页帧</strong>（Frame）：将物理地址空间划分为大小相同的基本分配单位。</li><li><strong>页面</strong>（Page）：将逻辑地址空间也划分为相同大小的基本分配单位。</li><li><strong>页表</strong>（page table）：页表存储逻辑 - 物理地址的映射关系，从而让系统知道地址空间的每个页实际驻留在物理内存中的哪一帧。由于每个地址空间都需要这种转换，因此一般来说，系统中每个进程都有一个页表。</li></ul><p>如下图所示，页、帧的地址表示如同分段，前几位对应其页（帧）号，后几位对应偏移量。需要注意的是，页号通常不等于帧号，但是两者偏移量相同。</p><img src="/2020/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/7.png" class="" title="分页"> <p>目前我们设计的分页有诸多优势，比如较为灵活，不会产生外部碎片。但是也有缺陷。</p><h4 id="内存访问性能"><a href="#内存访问性能" class="headerlink" title="内存访问性能"></a>内存访问性能</h4><p>我们每一次内存访问，都需要先访问页表，得到对应的帧号才可以再次访问内存，这样会大大增加性能的消耗。</p><h4 id="页表大小"><a href="#页表大小" class="headerlink" title="页表大小"></a>页表大小</h4><p>对于一个 32 位的地址空间，有着 4KB 的页。则这个逻辑地址会分为 20 位的页号和 12 位的偏移量（$页大小 = 2^{12}=4 \ KB$，$页数 = 2^{20}$）。这样就意味着，操作系统要为每个进程管理 $2^{20}$ 个逻辑 - 物理地址的映射关系。如果每个页的条目需要 4 个字节，则每个页表就需要 4MB 内存，如果有 100 个进程同时运行，那么就需要 400MB 内存，而这仅仅是用来存储页表。</p><h3 id="快速地址转换（TLB）"><a href="#快速地址转换（TLB）" class="headerlink" title="快速地址转换（TLB）"></a>快速地址转换（TLB）</h3><p>我们先来解决访问性能的问题，我们之前在组成原理部分讲到过<strong>高速缓存</strong>。利用<strong>局部性原理</strong>将经常访问的部分加载到高速缓存中，以提高访问速度。</p><p>同样的，我们在 CPU 里放了一块缓存芯片。这块缓存芯片我们称之为是<strong>地址变换高速缓冲</strong>（Translation-Lookaside Buffer， TLB）。这块缓存存放了之前已经进行过地址转换的查询结果。这样，当同样的虚拟地址需要进行地址转换的时候，我们可以直接在 TLB 里面查询结果，而不需要多次访问内存来完成一次转换。</p><img src="/2020/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/8.jpeg" class="" title="TLB"> <h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>下面我们来解决页表大小的问题，这里我们引入多级页表（multi-level page<br>table）。</p><p>我们以一个 4 级的多级页表为例，我们把它拆成四段，从高到低，分成 4 级到 1 级这样 4 个页表索引。</p><img src="/2020/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/9.jpeg" class="" title="多级页表"> <p>我们通过上一级找到下一级的页表，最终找到对应的物理帧号，找到地址。这样，多级页表就像一个多叉树的数据结构，所以我们常常称它为页表树（Page Table Tree）。</p><p>在实际情况中，我们用不到所有的页表，对于一个进程而言，除了必须的代码、堆栈，其余空间都是空闲的，这样也不会给该页分配页表，这样就会大大降低页表的大小。</p><h3 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h3><p>段式存储在内存保护方面有优势，页式存储在内存利用和优化转移到后备存储方面有优势。那么将段式存储、页式存储结合，就会得到段页式存储管理。这样设计会很容易做到内存共享。</p><img src="/2020/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/10.png" class="" title="段页式"> <h2 id="虚拟存储"><a href="#虚拟存储" class="headerlink" title="虚拟存储"></a>虚拟存储</h2><p>之前我们讨论的都是物理内存的相关知识，但是物理内存的容量有限，比如现在一台高配个人电脑有 32GB 的内存空间，但是 2013 年发售的 $Grand\ Theft\ Auto\ V$ 就要 90GB。要想把整个游戏进程加载到内存显然是不可能的，这就需要我们扩展磁盘来作为其虚拟内存。 </p><img src="/2020/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/11.png" class="" title="虚拟内存"> <p>在加载程序时，只将当前指令执行需要的部分页面装入内存，在指令执行中需要的指令或数据不在内存（缺页或缺段）时，发出中断指令让处理器通知操作系统将相应的页面或段调入内存中，操作系统也会将内存中暂时不用的页面或段保存到外存中。</p><p>那么，我们该如何选择需要置换的物理帧呢？下面我们就来讨论页面置换算法。</p><h3 id="最优页面置换算法（OPT，optimal）"><a href="#最优页面置换算法（OPT，optimal）" class="headerlink" title="最优页面置换算法（OPT，optimal）"></a>最优页面置换算法（OPT，optimal）</h3><p><strong>最优页面置换算法</strong>在缺页的时候，先去计算内存中每个逻辑页面的下一次访问时间，选择未来最长时间不访问的页面进行置换。这样的算法是缺页最少的，但是在实际系统中是无法实现的，因为我们很难去预测未来。但是这样的算法可以作为置换算法的性能评价依据。</p><p>下面我们来看一个实例，假设缓存可以存 3 个页。</p><div class="table-container"><table><thead><tr><th>访问</th><th>命中/未命中</th><th>踢出</th><th>导致缓存状态</th></tr></thead><tbody><tr><td>0</td><td>未命中</td><td></td><td>0</td></tr><tr><td>1</td><td>未命中</td><td></td><td>0、1</td></tr><tr><td>2</td><td>未命中</td><td></td><td>0、1、2</td></tr><tr><td>0</td><td>命中</td><td></td><td>0、1、2</td></tr><tr><td>1</td><td>命中</td><td></td><td>0、1、2</td></tr><tr><td>3</td><td>未命中</td><td>2</td><td>0、1、3</td></tr><tr><td>0</td><td>命中</td><td></td><td>0、1、3</td></tr><tr><td>3</td><td>命中</td><td></td><td>0、1、3</td></tr><tr><td>1</td><td>命中</td><td></td><td>0、1、3</td></tr><tr><td>2</td><td>未命中</td><td>3</td><td>0、1、2</td></tr><tr><td>1</td><td>命中</td><td></td><td>0、1、2</td></tr></tbody></table></div><p>我们在访问页 3 时未命中，通过分析未来访问情况，我们发现页 2 在最远的未来被访问，于是踢出页 2 。同时我们计算缓存命中率：有 6 次命中和 5 次未命中，那么命中缓存率 $\frac{Hits}{Hits+Misses}$ 为 $\frac{6}{6+5}$ 为 54.5%。如果忽略第一次未命中，那么命中率为 81.8%。​</p><h3 id="先进先出算法（First-In-First-Out-FIFO）"><a href="#先进先出算法（First-In-First-Out-FIFO）" class="headerlink" title="先进先出算法（First-In First-Out, FIFO）"></a>先进先出算法（First-In First-Out, FIFO）</h3><p><strong>FIFO算法</strong>我们使用一个记录所有位于内存中的逻辑页面的链表，<strong>链表元素按驻留内存的时间排序</strong>，链首最长，链尾最短。出现缺页时，选择链首页面进行置换，新页面加到链尾。</p><div class="table-container"><table><thead><tr><th>访问</th><th>命中/未命中</th><th>踢出</th><th>导致缓存状态</th></tr></thead><tbody><tr><td>0</td><td>未命中</td><td></td><td>0</td></tr><tr><td>1</td><td>未命中</td><td></td><td>0、1</td></tr><tr><td>2</td><td>未命中</td><td></td><td>0、1、2</td></tr><tr><td>0</td><td>命中</td><td></td><td>0、1、2</td></tr><tr><td>1</td><td>命中</td><td></td><td>0、1、2</td></tr><tr><td>3</td><td>未命中</td><td>0</td><td>1、2、3</td></tr><tr><td>0</td><td>未命中</td><td>1</td><td>2、3、0</td></tr><tr><td>3</td><td>命中</td><td></td><td>2、3、0</td></tr><tr><td>1</td><td>未命中</td><td>2</td><td>3、0、1</td></tr><tr><td>2</td><td>未命中</td><td>3</td><td>0、1、2</td></tr><tr><td>1</td><td>命中</td><td></td><td>0、1、2</td></tr></tbody></table></div><p>FIFO 和最优策略相比，FIFO 表现显然逊色些，FIFO 的命中率只有 36.4%。</p><h3 id="最近最久未使用算法（Least-Recently-Used，LRU）"><a href="#最近最久未使用算法（Least-Recently-Used，LRU）" class="headerlink" title="最近最久未使用算法（Least Recently Used，LRU）"></a>最近最久未使用算法（Least Recently Used，LRU）</h3><p>既然我们无法预测未来，我们可以根据局部性原理，对程序之前的行为观察，我们可以计算内存中每个逻辑页面的上一次访问时间，选择上一次使用到当前时间最长的页面。</p><div class="table-container"><table><thead><tr><th>访问</th><th>命中/未命中</th><th>踢出</th><th>导致缓存状态</th></tr></thead><tbody><tr><td>0</td><td>未命中</td><td></td><td>0</td></tr><tr><td>1</td><td>未命中</td><td></td><td>0、1</td></tr><tr><td>2</td><td>未命中</td><td></td><td>0、1、2</td></tr><tr><td>0</td><td>命中</td><td></td><td>1、2、0</td></tr><tr><td>1</td><td>命中</td><td></td><td>2、0、1</td></tr><tr><td>3</td><td>未命中</td><td>2</td><td>0、1、3</td></tr><tr><td>0</td><td>命中</td><td></td><td>1、3、0</td></tr><tr><td>3</td><td>命中</td><td></td><td>1、0、3</td></tr><tr><td>1</td><td>命中</td><td></td><td>0、3、1</td></tr><tr><td>2</td><td>未命中</td><td>0</td><td>3、1、2</td></tr><tr><td>1</td><td>命中</td><td></td><td>3、2、1</td></tr></tbody></table></div><p>在这个例子中，当第一次需要替换页时，LRU 会踢出页 2，因为 0 和 1 的访问时间更近。然后它替换页 0，因为 1 和 3 最近被访问过。我们看到，LRU 的性能快要赶上最优策略了。</p><h3 id="时钟置换算法（Clock）"><a href="#时钟置换算法（Clock）" class="headerlink" title="时钟置换算法（Clock）"></a>时钟置换算法（Clock）</h3><p><strong>时钟置换算法</strong>则是在页表项中增加访问位，描述页面过去一段时间的内访问情况。</p><p>在页面装入内存时，访问位初始化为 0。访问页面时，访问位置 1，缺页时。从指针当前位置顺序检查环形链表，访问位为 0，则置换该页；访问位为 1，则将访问位改为 1，并将指针移动到下一个页面，直到找到可置换的页面。</p><p>这样页面组织起来会形成环形链表，指针也像钟表针一样，因此称为时钟置换算法。</p><h3 id="最不常用算法（Least-Frequently-Used，LFU）"><a href="#最不常用算法（Least-Frequently-Used，LFU）" class="headerlink" title="最不常用算法（Least Frequently Used，LFU）"></a>最不常用算法（Least Frequently Used，LFU）</h3><p><strong>最不常用算法</strong>则是在每个页面设置一个访问计数，在访问页面时，访问计数加 1 ，缺页时，置换计数最小的页面。</p><h3 id="Belady现象"><a href="#Belady现象" class="headerlink" title="Belady现象"></a>Belady现象</h3><p>一般来说，当缓存变大时，缓存命中率是会提高的（变好）。但在这个例子，采用 FIFO，命中率反而下降了。这种奇怪的现象被称为 Belady 的异常（Belady’s Anomaly）。其他一些策略，比如 LRU，不会遇到这个问题。LRU 具有所谓的栈特性（stack property）。对于具有这个性质的算法，大小为 N + 1 的缓存自然包括大小为 N 的缓存的内容。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章我们介绍了<strong>内存管理</strong>的知识，先介绍了物理内存的管理方式，分为连续与非连续分配，不连续分配有<strong>分段</strong>和<strong>分页</strong>，我们重点学习了<strong>分页</strong>相关的知识，也解决了<strong>页表</strong>的问题。</p><p>之后，我们介绍了<strong>虚拟存储</strong>的相关知识，也讨论了<strong>置换算法</strong>。</p><p>下一章将为大家带来<strong>线程</strong>的相关知识，一起来看看操作系统的第二个特性<strong>并发</strong>。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://book.douban.com/subject/33463930/" target="_blank" rel="noopener">雷姆兹·H.阿帕希杜塞尔 / 安德莉亚·C.阿帕希杜塞尔 - 操作系统导论</a></li><li><a href="http://www.xuetangx.com/courses/course-v1:TsinghuaX+30240243X+sp/about" target="_blank" rel="noopener">向勇 / 陈渝 - 操作系统</a></li><li><a href="https://book.douban.com/subject/27096665/" target="_blank" rel="noopener">Andrew S. Tanenbaum / Herbert Bos - 现代操作系统（原书第4版）</a></li><li><a href="https://time.geekbang.org/column/intro/170" target="_blank" rel="noopener">徐文浩 - 深入浅出计算机组成原理</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一章我们介绍了&lt;strong&gt;进程&lt;/strong&gt;的相关知识，了解了操作系统是如何让每个进程「独享」 CPU  的。&lt;/p&gt;
&lt;p&gt;这一章我们继续操作系统&lt;strong&gt;虚拟性&lt;/strong&gt;的介绍，介绍&lt;strong&gt;内存管理&lt;/strong&gt;，将会从&lt;strong&gt;物理内存&lt;/strong&gt;开始，介绍其&lt;strong&gt;连续&lt;/strong&gt;与&lt;strong&gt;非连续&lt;/strong&gt;的存储方式，继而介绍&lt;strong&gt;虚拟内存&lt;/strong&gt;，看看内存是如何让进程「共享」内存空间的。&lt;/p&gt;
&lt;p&gt;这部分内容与国内的教材顺序有所不同，国内大部分是将这一章作为线程，且对线程与进程的区分比较模糊。个人认为这样不利于初学者区分进程与线程。这里推荐威斯康星大学计算机科学教授雷姆兹和安德莉亚夫妇编写的&lt;a href=&quot;https://book.douban.com/subject/33463930/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;「操作系统导论」&lt;/a&gt;（Operating Systems: Three Easy Pieces），以及以此书为参考教材的课程：清华大学&lt;a href=&quot;http://www.xuetangx.com/courses/course-v1:TsinghuaX+30240243X+sp/about&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;「操作系统」&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>2 进程</title>
    <link href="http://yoursite.com/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/</id>
    <published>2020-02-07T05:53:53.000Z</published>
    <updated>2020-02-11T05:17:27.472Z</updated>
    
    <content type="html"><![CDATA[<p>上一章我们介绍了操作系统的基本概念以及特性，补充了些在<strong>组成原理</strong>中未涉及的内容。</p><p>接下来两章我们会从<strong>虚拟性</strong>出发，去分别介绍<strong>进程</strong>（ CPU 虚拟）和<strong>内存管理</strong>（内存虚拟）。这一章先介绍进程的基本概念以及进程的<strong>调度算法</strong>。</p><a id="more"></a><h2 id="进程的基本概念"><a href="#进程的基本概念" class="headerlink" title="进程的基本概念"></a>进程的基本概念</h2><p>首先，我们先来明确<strong>进程</strong>这个概念。</p><ul><li><strong>程序</strong>（Program）：就是存放在硬盘中的可执行文件，是一系列的指令集合，是<strong>静态</strong>的。</li><li><strong>进程</strong>（Process）：是程序的一次执行过程，是<strong>动态</strong>的。同一个程序多次执行可对应多个进程。</li></ul><p>对于不同进程，操作系统也会为其创造特定的<strong>PID</strong>（Process ID）。PID与分配的资源、运行的情况等信息，共同保存在一个数据结构，<strong>进程控制块</strong>（ <strong>PCB</strong> Process Control Block）。PCB与<strong>程序段</strong>、<strong>数据段</strong>共同构成进程。</p><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/1.png" class="" title="进程的运行"> <h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><ul><li><strong>创建态</strong>：当进程正在被创建时，它的状态就是<strong>创建态</strong>。操作系统会为其分配资源，初始化 PCB。</li><li><strong>就绪态</strong>：处于<strong>就绪态</strong>的进程已经具备运行条件，但由于没有空闲的 CPU ，就暂时不能运行。</li><li><strong>运行态</strong>：如果一个进程此时在 CPU 上运行，那么这个进程处于<strong>运行态</strong>。</li><li><strong>阻塞态</strong>：在进程运行的过程中，可能会请求等待某个事件的发生，如等待某种资源的分配，或者等待其他进程的响应。在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下 CPU ，并让其进入<strong>阻塞态</strong>。</li><li><strong>终止态</strong>：当一个进程请求操作系统终止该进程时，该进程会进入<strong>终止态</strong>，操作系统会回收其所有资源。</li></ul><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/2.png" class="" title="进程的状态"> <h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>这部分我们将讨论 <strong>Unix 系统</strong>的进程创建，首先先介绍一下三个进程的 API：</p><ul><li><strong>fork()</strong>：用来创建新的进程，原来的进程称为<strong>父进程</strong>，新创建的进程称为<strong>子进程</strong>。这两个进程几乎完全相同，但是其 <strong>PID</strong> 不同。</li><li><strong>wait()</strong>：允许父进程等待子进程执行结束。</li><li><strong>exec()</strong>：允许子进程<strong>「偏离」</strong>父进程，执行新的程序。</li></ul><p>下面我们来看一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world (pid:%d)\n"</span>, (<span class="keyword">int</span>) getpid());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> rc = fork();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#123; <span class="comment">// fork 失败并退出</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"fork failed\n"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#123; <span class="comment">// 子进程</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello, I am child (pid:%d)\n"</span>, (<span class="keyword">int</span>) getpid());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">char</span> * myargs[<span class="number">3</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        myargs[<span class="number">0</span>] = strdup(<span class="string">"wc"</span>); <span class="comment">// 新的程序：计算程序行数、词数、字节数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        myargs[<span class="number">1</span>] = strdup(<span class="string">"p3.c"</span>); <span class="comment">// 需要计算的程序</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        myargs[<span class="number">2</span>] = <span class="literal">NULL</span>; <span class="comment">// 标记结束</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        execvp(myargs[<span class="number">0</span>], myargs); <span class="comment">// 执行程序并退出</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"this shouldn’t print out"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> rc_wait = wait(<span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello, I am parent of %d (rc_wait:%d) (pid:%d)\n"</span>, rc, rc_wait, (<span class="keyword">int</span>) getpid());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>对于这个例子，<code>fork()</code>之后，创建子进程，对于父进程来讲<code>rc = 子进程的PID</code>，对于子进程来讲<code>rc = 0</code>，故在子进程执行时，会跳转至其分支，并通过调用<code>execvp()</code>来执行新的程序。</p><p>对于父进程，先调用<code>wait()</code>，以至于先输出子进程结果，不会因为时间片耗尽而提前执行父进程。</p><p>最后输出结果为：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">prompt&gt; ./p3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">hello world (pid:<span class="number">29383</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">hello, I am child (pid:<span class="number">29384</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="number">29</span> <span class="number">107</span> <span class="number">1030</span> p3.c</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">hello, I am parent of <span class="number">29384</span> (rc_wait:<span class="number">29384</span>) (pid:<span class="number">29383</span>)</span></pre></td></tr></table></figure><h2 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h2><p>在计算机运行过程中，通常会有多个进程同时竞争 CPU。因此，计算机要选择运行的程序。完成这项工作的部分称为<strong>调度程序</strong>（Scheduler），该程序使用的算法称为<strong>调度算法</strong>（Scheduling Algorithm）。</p><h3 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h3><p>首先，我们引入假设，以简化调度过程。</p><ul><li>每个任务运行相同时间。</li><li>所有任务同时到达。</li><li>一旦启动，每个任务运行到结束。</li><li>所有任务只使用 CPU。</li><li>已知每个任务的运行时间。</li></ul><p>之后，我们会逐步消除假设，以探讨调度问题。</p><h3 id="评价标准"><a href="#评价标准" class="headerlink" title="评价标准"></a>评价标准</h3><p>我们引入两个评价指标，以评价调度算法的优劣：</p><ul><li><strong>周转时间</strong>（Turnaround Time）：$ T_{turnaround} = T_{completion}-T_{arrival} $</li><li><strong>响应时间</strong>（Response Time）：$T_{response}=T_{firstrun}-T_{arrival}$</li></ul><h3 id="先来先服务（First-In-First-Out-FIFO）"><a href="#先来先服务（First-In-First-Out-FIFO）" class="headerlink" title="先来先服务（First In, First Out, FIFO）"></a>先来先服务（First In, First Out, FIFO）</h3><p>有三个任务A、B、C几乎同时到达（$T_A&lt;T_B&lt;T_C$）。</p><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/3.png" class="" title="FIFO 简单例子"> <p>从上图我们可以看出，A 于 10 结束，B 于 20 结束，C 于 30 结束。因此其平均周转时间为 $\frac{10+20+30}{3}=20$.</p><p>下面，我们舍弃第一条假设（每个任务运行相同时间），还是刚才那三个任务，只不过 A 运行 100 秒，B、C 分别运行 10 秒。</p><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/4.png" class="" title="FIFO 为什么不是最优解"> <p>由此可见，A 任务要整整运行 100 秒，才可以轮到 B 任务。其平均周转时间也高达 $\frac{100+110+120}{3}=110$.</p><p>这种现象称为<strong>车队效应</strong>（Convey effect），有点类似在现实生活中，你在超市排队时，前面的人买了三车食品的样子。</p><h3 id="最短作业优先（Shortest-Job-First-SJF）"><a href="#最短作业优先（Shortest-Job-First-SJF）" class="headerlink" title="最短作业优先（Shortest Job First, SJF）"></a>最短作业优先（Shortest Job First, SJF）</h3><p>之前在宜家购物的时候，有一个专门的购物通道是为小件商品用户提供的，这也是 SJF 调度算法的策略。</p><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/5.png" class="" title="SJF 简单例子"> <p>同样是 A、B、C 几乎同时到达。但是由于 B 任务较 A 任务较短。因此其平均周转时间为 $\frac{10+20+120}{3}=50$.缩短了很多。</p><p>这时，我们舍弃第二条假设（所有任务同时到达）。此时假设 A 任务于 $t =0$ 时刻到达且运行 100 秒，而 B、C 任务于 $t =10$ 时刻到达且运行 10 秒。</p><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/6.png" class="" title="当 B、C 稍晚到达 SJF 调度算法"> <p>此时的平均周转时间为 $\frac{100+(110-20)+(120-10)}{3}=103.33$.</p><h3 id="最短时间完成优先（Shortest-Time-to-Completion-STC）"><a href="#最短时间完成优先（Shortest-Time-to-Completion-STC）" class="headerlink" title="最短时间完成优先（Shortest Time-to-Completion, STC）"></a>最短时间完成优先（Shortest Time-to-Completion, STC）</h3><p>现在我们舍弃第三条假设（一旦启动，每个任务运行到结束），使调度程序成为<strong>抢占型</strong>（Preemptive），可以切换上下文（Context switch），暂停运行任务，转而运行其他任务。因此 STCF 中会抢占 A 任务以让 B、C 任务运行，直到后者运行结束后才会继续运行 A 任务。</p><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/7.png" class="" title="STCF 简单示例"> <p>此时的平均周转时间为 $\frac{(120-0)+(20-10)+(30-10)}{3}=50$.</p><p>由于现代计算机采用时分技术，用户更希望能够与操作系统发生交互。因此<strong>响应时间</strong>也是衡量调度算法的关键。上述例子中，A 的响应时间为 0，B 为 0，C 为 10，平均响应时间为$\frac{0+0+10}{3}=3.33$.</p><p>但是三个任务同时到达时，那么第三个任务需要等待很长时间才可以得到响应。</p><h3 id="时间片轮转（Round-Robin）"><a href="#时间片轮转（Round-Robin）" class="headerlink" title="时间片轮转（Round Robin）"></a>时间片轮转（Round Robin）</h3><p>不同于之前每个任务都要完成，RR 则只在一个<strong>时间片</strong>（Time slice）中运行任务，然后会切换到下一个任务，如此往复直到任务全部完成。</p><p>假设三个任务同时到达，每个运行 5 秒，时间片为 1 秒。</p><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/8.png" class=""> <p>对于 RR，其平均响应时间为 $\frac{0+1+2}{3}=1$.而 SJF 则为 $\frac{0+5+10}{3}=5$.</p><p>时间片长短对于 RR 来说非常关键，时间片越短，其响应越快；相应的，上下文切换的消耗会主导其整体性能。</p><p>RR 有着很好的响应速度，但是对于平均周转时间来说，表现并不是那么出色。$\frac{13+14+15}{3}=14$.</p><h3 id="I-O交互"><a href="#I-O交互" class="headerlink" title="I/O交互"></a>I/O交互</h3><p>现在，我们舍弃第四个假设（所有任务只使用 CPU）。当一个运行中的任务发起 I/O 请求时，CPU 会处于空转，等待 I/O 完成。因此，调度程序可以在这段时间内将 CPU 交给下一个任务，等待 I/O 完成后，发起中断。</p><p>假设 A、B 任务都在 CPU 上运行 50ms，但 A 任务每运行 10ms 时，会发起一次 I/O 请求。下图为两种不同的调度算法。</p><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/9.png" class=""> <p>A 任务会分成 5 个 10ms 的子任务。我们可以把子任务当作独立的任务，当系统开始运行时，有 10ms A 与 50ms B，采用 STCF 调度，毫无疑问选择 A 任务。当第一个子任务完成时，CPU 上只剩下 B 任务，因此开始运行。当新的子任务提交后，A 会抢占 B运行 10ms。由此会产生交叠（Overlap），使 CPU 利用率最大化。</p><h2 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h2><p>在上一节中，我们还留下了最后一个假设：已知每个任务的运行时间。显然在实际情况中我们并不知道每个任务的具体运行时间。这就带来了我们本节的内容：<strong>多级反馈队列</strong>（Multi-level Feed-back Queue, MLFQ）。</p><h3 id="基本准则"><a href="#基本准则" class="headerlink" title="基本准则"></a>基本准则</h3><p>MLFQ 有很多独立的<strong>队列</strong>（queue），每个队列都有不同的<strong>优先级</strong>（priority level）。每个任务在各自的队列运行，有高优先级的任务优先运行。由此，带来两个准则：</p><ul><li>如果 A 的优先级大于 B，那么只有 A 运行。</li><li>如果 A、B 优先级相同，则 A、B 采取 RR 运行。</li></ul><p>因此，如何确定每个任务的优先级成为关键。</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>每个任务的优先级应当取决于其表现，对于时刻「霸占」 CPU 的长任务，应当降低其优先级，而对于「主动放弃」CPU 的交互任务，我们应当给予它一定特权。由此，得出下面准则：</p><ul><li>当一个任务进入系统时，将其放置在最高优先级（第一队列）。</li><li>如果一个任务耗尽其时间片，降低其优先级；如果一个任务在耗尽时间片前放弃 CPU，保持在当前优先级。</li></ul><h4 id="长任务和短任务"><a href="#长任务和短任务" class="headerlink" title="长任务和短任务"></a>长任务和短任务</h4><p>我们看一个例子：A 任务为长任务，B 任务为短任务。在 A 运行一段时间后，B 任务到达（$T=100$），时间片为 20ms。</p><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/10.png" class=""> <p>由于我们并不知道每个任务的具体运行时间，所以当一个任务到达时，我们先假设它是短任务，于是赋予它最高优先级。如果它真是短任务，那么它会很快结束；如果它不是短任务，那么会降低其优先级。在这个模式下，MLFQ 近似 SJF。</p><h4 id="I-O-交互"><a href="#I-O-交互" class="headerlink" title="I/O 交互"></a>I/O 交互</h4><p>我们再来看看有 I/O 交互的例子。B 任务使用 CPU 1ms 后会进行 I/O 操作。因此在时间片结束之前主动放弃 CPU 的任务会保持在当前优先级。</p><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/11.png" class=""> <h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><p>我们的方案看似完美，但是也存在不少问题：</p><p>首先，可能会导致<strong>饥饿</strong>（starvation），如果系统中有太多交互任务，那么它们会一直「霸占」 CPU，长任务无法获得 CPU。</p><p>其次，一些恶意程序会<strong>钻调用程序的空子</strong>（ game the scheduler）：在时间片结束前，该任务主动放弃 CPU 进行 I/O 请求，因此它会保持在较高优先级，占用大量 CPU 时间。</p><p>最后，如果一个任务总是改变其状态，长任务可能会变为短任务。</p><h3 id="提升优先级"><a href="#提升优先级" class="headerlink" title="提升优先级"></a>提升优先级</h3><p>为解决饥饿问题，我们可以采用<strong>提升优先级</strong>（boost the priority）的方案：</p><ul><li>在一段时间 $S$ 后，将所有任务提升到系统第一队列。</li></ul><p>新准则解决了两个问题，一是所有进程都不会饥饿，每个任务都有机会处于同一优先级。二是解决了任务状态改变的问题。</p><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/12.png" class=""> <p>左图为没有提升优先级的方案，右图中每 50ms 提升一次优先级。</p><h3 id="更好的计时方式"><a href="#更好的计时方式" class="headerlink" title="更好的计时方式"></a>更好的计时方式</h3><p>我们还剩下最后一个问题：如何避免恶意程序的欺骗。解决方式是使用更好的 CPU 时间计算方案。一旦任务运行完它的时间份额，就会降低其优先级，取代运行时间片的方案：</p><ul><li>一旦任务消耗完其时间份额（而非放弃 CPU 的次数），就会降低它的优先级。</li></ul><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/13.png" class=""> <p>在保护机制下，交互任务也会逐步降低其优先级。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章开始介绍操作系统的第一个特性<strong>虚拟化</strong>，先介绍<strong>进程</strong>的相关概念。接着介绍了进程调度的相关知识。</p><p>下一章将为大家带来<strong>内存管理</strong>的相关知识，看看内存是如何虚拟化的。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://book.douban.com/subject/33463930/" target="_blank" rel="noopener">雷姆兹·H.阿帕希杜塞尔 / 安德莉亚·C.阿帕希杜塞尔 - 操作系统导论</a></li><li><a href="https://www.bilibili.com/video/av70156862/" target="_blank" rel="noopener">王道考研 - 操作系统</a></li><li><a href="https://book.douban.com/subject/27096665/" target="_blank" rel="noopener">Andrew S. Tanenbaum / Herbert Bos - 现代操作系统（原书第4版）</a></li><li><a href="https://time.geekbang.org/column/intro/100024701" target="_blank" rel="noopener">刘超 - 趣谈Linux操作系统</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一章我们介绍了操作系统的基本概念以及特性，补充了些在&lt;strong&gt;组成原理&lt;/strong&gt;中未涉及的内容。&lt;/p&gt;
&lt;p&gt;接下来两章我们会从&lt;strong&gt;虚拟性&lt;/strong&gt;出发，去分别介绍&lt;strong&gt;进程&lt;/strong&gt;（ CPU 虚拟）和&lt;strong&gt;内存管理&lt;/strong&gt;（内存虚拟）。这一章先介绍进程的基本概念以及进程的&lt;strong&gt;调度算法&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>1 操作系统概述</title>
    <link href="http://yoursite.com/2020/02/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2020/02/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</id>
    <published>2020-02-06T05:53:53.000Z</published>
    <updated>2020-02-07T06:40:00.483Z</updated>
    
    <content type="html"><![CDATA[<p>之前我们介绍了计算机的<strong>组成原理</strong>，从今天开始，我们要开始介绍计算机的<strong>操作系统</strong>。操作系统作为用户与硬件之间最重要的枢纽，有着非常重要的意义。</p><p>本章将带来操作系统的基本概念、功能特性、发展历史以及体系结构，也会补充些硬件方面的知识，完善知识结构。</p><a id="more"></a><h2 id="操作系统的基本概念"><a href="#操作系统的基本概念" class="headerlink" title="操作系统的基本概念"></a>操作系统的基本概念</h2><p>之前我们了解过、计算机由处理器、内存、磁盘、输入输出等设备组成。而我们现在操作这些硬件以实现某些功能的时候，并不需要去掌握其底层逻辑。这是因为<strong>操作系统</strong>为用户程序提供了一个更简洁、更清晰的计算机模型，并且管理硬件部分。</p><p>目前，计算机有两种运行模式：</p><ul><li><strong>内核态</strong>：操作系统运行于此，在这个模式下，操作系统拥有对所有硬件的完全访问权。</li><li><p><strong>用户态</strong>：软件的其余部分均运行于此。</p><ul><li>用户接口程序：shell（基于文本），图形用户界面（GUI）。</li></ul><img src="/2020/02/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/1.png" class="" title="操作系统所处的位置"> </li></ul><p>下面我们以应用程序的实际例子，来介绍下操作系统对硬件资源管理的功能：</p><ul><li><strong>文件管理</strong>：打开文件夹，找到可执行文件存放的位置。</li><li><strong>存储器管理</strong>：把程序相关数据加载到内存中。</li><li><strong>处理器管理</strong>：CPU处理对应进程。</li><li><strong>设备管理</strong>：将键盘、显示器等设备分配给该程序。</li></ul><p>接下来的几章也会围绕以上功能展开。</p><h2 id="操作系统的发展"><a href="#操作系统的发展" class="headerlink" title="操作系统的发展"></a>操作系统的发展</h2><ul><li><strong>手工操作阶段</strong>：早期的计算机程序要使用打孔卡来运作，需要人工放入打孔卡来交给计算机去执行。</li><li><strong>批处理阶段</strong><ul><li>单道批处理系统：单周期处理器。</li><li>多道批处理系统：流水线处理器。</li></ul></li><li><strong>分时操作系统</strong>：计算机以<strong>时间片</strong>为单位<strong>轮流</strong>为各个用户、作业服务，各个用户可通过终端与计算机进行交互。</li><li><strong>实时操作系统</strong>：在前者的基础上更能优先处理某些紧急任务。</li><li>网络操作系统</li><li>分布式操作系统</li><li>个人计算机操作系统</li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><strong>异常</strong>（Exception）其实是一个硬件和软件组合到一起的处理过程。当处理器检测到有事件发生时，会通过<strong>异常表</strong>(Exception Table)来确定跳转的位置，到一个专门处理这类事件的操作系统子程序（异常处理程序）。当异常处理程序完成处理后，根据引起异常事件的类型，发生以下三种情况中的一种：</p><ul><li>返回当前指令。</li><li>返回下一条指令。</li><li><p>终止。</p> </li></ul><h3 id="异步异常（中断）"><a href="#异步异常（中断）" class="headerlink" title="异步异常（中断）"></a>异步异常（中断）</h3><p><strong>异步异常</strong>(Asynchronous Exception)称之为<strong>中断</strong>(Interrupt)，是由处理器外面发生的事情引起的。对于执行程序来说，这种“中断”的发生完全是异步的，因为不知道什么时候会发生，CPU对其的响应也完全是被动的。例如：</p><ul><li><strong>计时器中断</strong>：计时器中断是由计时器芯片每隔几毫秒触发的，内核用计时器终端来从用户程序手上拿回控制权。</li><li><strong>I/O 中断</strong>：I/O 中断类型比较多样，比方说键盘输入了 ctrl-c，网络中一个包接收完毕，都会触发这样的中断。</li></ul><h3 id="同步异常"><a href="#同步异常" class="headerlink" title="同步异常"></a>同步异常</h3><p><strong>同步异常</strong>(Synchronous Exception)是因为执行某条指令所导致的事件，分为<strong>陷阱</strong>(Trap)、<strong>故障</strong>(Fault)和<strong>终止</strong>(Abort)三种情况。</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">原因</th><th style="text-align:center">示例</th><th style="text-align:center">触发时机</th><th style="text-align:center">处理后操作</th></tr></thead><tbody><tr><td style="text-align:center">中断</td><td style="text-align:center">I/O设备信号</td><td style="text-align:center">用户键盘输入</td><td style="text-align:center">异步</td><td style="text-align:center">下一条指令</td></tr><tr><td style="text-align:center">陷阱</td><td style="text-align:center">程序刻意触发</td><td style="text-align:center">程序进行系统调用</td><td style="text-align:center">同步</td><td style="text-align:center">下一条指令</td></tr><tr><td style="text-align:center">故障</td><td style="text-align:center">程序执行出错</td><td style="text-align:center">程序加载时缺页</td><td style="text-align:center">同步</td><td style="text-align:center">当前指令</td></tr><tr><td style="text-align:center">中止</td><td style="text-align:center">故障无法恢复</td><td style="text-align:center">整数除零</td><td style="text-align:center">同步</td><td style="text-align:center">退出程序</td></tr></tbody></table></div><h2 id="操作系统的基本特征"><a href="#操作系统的基本特征" class="headerlink" title="操作系统的基本特征"></a>操作系统的基本特征</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ul><li><strong>并发</strong>：指的是两个或多个事件在同一时间间隔内发生。这些事件在宏观上是同时发生的，但在微观上是交替发生的。</li><li><strong>并行</strong>：指的是两个或多个事件在同一时刻同时发生。</li></ul><p>例如：我们可以边写作业边听歌，这是并行。也可以写一会儿作业听一会儿歌，只要我们做事情足够快，就会在宏观上看起来同时发生。</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p><strong>异步</strong>：在多通道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p><p>例如：我们有时候会在特定时间间隔内写完作业，以至于我们听歌并不能一贯到底。</p><h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><p><strong>虚拟</strong>：把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p><p>例如：</p><ul><li>CPU 的<strong>时分复用技术</strong>，使得在用户看来有多个 CPU 为自己服务。</li><li>内存的<strong>空分复用技术</strong>，虚拟内存</li></ul><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p><strong>共享</strong>：资源共享，指系统中的资源可供内存中多个并发执行的进程共同使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章由计算机组成过渡到了计算机操作系统，重点为大家介绍了操作系统的特征和异常。接下来几章也会围绕上述内容展开。</p><p>下一章将为大家带来<strong>进程与线程</strong>的知识，带大家看看 CPU 是如何分配和调度自己的资源的。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://www.bilibili.com/video/av70156862/" target="_blank" rel="noopener">王道考研 - 操作系统</a></li><li><a href="https://time.geekbang.org/column/intro/100026001" target="_blank" rel="noopener">徐文浩 - 深入浅出计算机组成原理</a></li><li><a href="https://wdxtub.com/csapp/thin-csapp-5/2016/04/16/" target="_blank" rel="noopener">小土刀 - 【读薄 CSAPP】伍 异常控制流</a></li><li><a href="https://book.douban.com/subject/27096665/" target="_blank" rel="noopener">Andrew S. Tanenbaum / Herbert Bos - 现代操作系统（原书第4版）</a></li><li><a href="https://book.douban.com/subject/26912767/" target="_blank" rel="noopener">Randal E.Bryant / David O’Hallaron - 深入理解计算机系统（原书第3版）</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前我们介绍了计算机的&lt;strong&gt;组成原理&lt;/strong&gt;，从今天开始，我们要开始介绍计算机的&lt;strong&gt;操作系统&lt;/strong&gt;。操作系统作为用户与硬件之间最重要的枢纽，有着非常重要的意义。&lt;/p&gt;
&lt;p&gt;本章将带来操作系统的基本概念、功能特性、发展历史以及体系结构，也会补充些硬件方面的知识，完善知识结构。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>5 存储器</title>
    <link href="http://yoursite.com/2020/02/03/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%20%E5%86%85%E5%AD%98/"/>
    <id>http://yoursite.com/2020/02/03/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%20%E5%86%85%E5%AD%98/</id>
    <published>2020-02-03T05:53:53.000Z</published>
    <updated>2020-02-04T08:35:34.605Z</updated>
    
    <content type="html"><![CDATA[<p>上一章我们介绍计算机中<strong>流水线指令系统设计</strong>，介绍一下计算机如何<strong>「更快」</strong>地执行，也会介绍如何去解决流水线处理器中的<strong>冒险</strong>。</p><p>这一章会为大家介绍计算机中各式各样的<strong>存储器</strong>，重点介绍<strong>高速缓存</strong>的工作原理。</p><a id="more"></a><h2 id="存储层次结构概况"><a href="#存储层次结构概况" class="headerlink" title="存储层次结构概况"></a>存储层次结构概况</h2><p>我们先把计算机的存储器层次结构和我们日常生活里处理信息、阅读书籍做个对照，好让你更容易理解、记忆存储器的层次结构。</p><p>我们常常把 CPU 比喻成计算机的「大脑」。我们思考的东西，就好比 CPU 中的<strong>寄存器</strong>（Register）。寄存器与其说是存储器，其实它更像是 CPU 本身的一部分，只能存放极其有限的信息，但是速度非常快，和 CPU 同步。而我们大脑中的记忆，就好比 <strong>CPU Cache</strong>（CPU 高速缓存，我们常常简称为<strong>缓存</strong>）。<strong>CPU Cache </strong>用的是一种叫作 <strong>SRAM</strong>（Static Random-Access Memory，静态随机存取存储器）的芯片。</p><h3 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h3><p>在 CPU 里，通常会有 L1、L2、L3 这样三层高速缓存。每个 CPU 核心都有一块属于自己的 L1 高速缓存，通常分成<strong>指令缓存</strong>和<strong>数据缓存</strong>，分开存放 CPU 使用的指令和数据。</p><p>L2 的 Cache 同样是每个 CPU 核心都有的，不过它往往不在 CPU 核心的内部。所以，L2 Cache 的访问速度会比 L1 稍微慢一些。而 L3 Cache，则通常是多个 CPU 核心共用的，尺寸会更大一些，访问速度自然也就更慢一些。</p><p>你可以把 CPU 中的 L1 Cache 理解为我们的<strong>短期记忆</strong>，把 L2/L3 Cache 理解成<strong>长期记忆</strong>，把内存当成我们拥有的<strong>书架</strong>。 当我们自己记忆中没有资料的时候，可以从书架上拿书来翻阅。这个过程中就相当于，数据从内存中加载到 CPU 的寄存器和 Cache 中，然后通过「大脑」，也就是 CPU，进行处理和运算。</p><h3 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h3><p>内存用的芯片和 Cache 有所不同，它用的是一种叫作 <strong>DRAM</strong>（Dynamic Random Access Memory，动态随机存取存储器）的芯片，比起 SRAM 来说，它的密度更高，有更大的容量，而且它也比 SRAM 芯片便宜不少。</p><p>因为数据是存储在电容里的，电容会不断漏电，所以需要定时刷新充电，才能保持数据不丢失。DRAM 的数据访问电路和刷新电路都比 SRAM 更复杂，所以访问延时也就更长。</p><img src="/2020/02/03/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%20%E5%86%85%E5%AD%98/1.png" class=""> <p>各个存储器只和相邻的一层存储器打交道，并且随着一层层向下，存储器的容量逐层增大，访问速度逐层变慢，而单位存储成本也逐层下降，也就构成了我们日常所说的存储器层次结构。</p><img src="/2020/02/03/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%20%E5%86%85%E5%AD%98/2.png" class="" title="存储器的层次关系图"> <h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><p>性能和价格的巨大差异，给我们工程师带来了一个挑战：我们能不能既享受 CPU Cache 的速度，又享受内存、硬盘巨大的容量和低廉的价格呢？</p><p>存储器中数据的<strong>局部性原理</strong>（Principle of Locality）。我们可以利用这个局部性原理，来制定管理和访问数据的策略。这个局部性原理包括<strong>时间局部性</strong>（temporal locality）和<strong>空间局部性</strong>（spatial locality）这两种策略。</p><h3 id="时间局部性"><a href="#时间局部性" class="headerlink" title="时间局部性"></a>时间局部性</h3><p>我们先来看时间局部性。这个策略是说，如果一个数据被访问了，那么它在短时间内还会被再次访问。</p><p>比如说，「哈利波特与魔法石」这本小说，我今天读了一会儿，没读完，明天还会继续读。同理，在一个电子商务型系统中，如果一个用户打开了 App，看到了首屏。我们推断他应该很快还会再次访问网站的其他内容或者页面，我们就将这个用户的个人信息，从存储在硬盘的数据库读取到内存的缓存中来。这利用的就是时间局部性。</p><img src="/2020/02/03/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%20%E5%86%85%E5%AD%98/3.png" class="" title="时间局部性"> <h3 id="空间局部性"><a href="#空间局部性" class="headerlink" title="空间局部性"></a>空间局部性</h3><p>我们再来看空间局部性。这个策略是说，如果一个数据被访问了，那么和它相邻的数据也很快会被访问。</p><p>我们还拿刚才读「哈利波特与魔法石」的例子来说。我读完了这本书之后，感觉这书不错，所以就会借阅整套「哈利波特」。这就好比我们的程序，在访问了数组的首项之后，多半会循环访问它的下一项。因为，在存储数据的时候，数组内的多项数据会存储在相邻的位置。这就好比图书馆会把「哈利波特」系列放在一个书架上，摆放在一起，加载的时候，也会一并加载。我们去图书馆借书，往往会一次性把 7 本都借回来。</p><img src="/2020/02/03/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%20%E5%86%85%E5%AD%98/4.png" class="" title="空间局部性"> <h2 id="高速缓存的工作原理"><a href="#高速缓存的工作原理" class="headerlink" title="高速缓存的工作原理"></a>高速缓存的工作原理</h2><p>现代 CPU 进行数据读取的时候，无论数据是否已经存储在 Cache 中，CPU 始终会首先访问 Cache。只有当 CPU 在 Cache 中找不到数据的时候，才会去访问内存，并将读取到的数据写入 Cache 之中。当时间局部性原理起作用后，这个最近刚刚被访问的数据，会很快再次被访问。而 Cache 的访问速度远远快于内存，这样，CPU 花在等待内存访问上的时间就大大变短了。</p><p>我就从最基本的<strong>直接映射</strong> Cache（Direct Mapped Cache）为例，来看看整个 Cache 的数据结构和访问逻辑。</p><p>直接映射 Cache 采用的策略，就是确保任何一个<strong>内存块</strong>（Block）的地址，始终映射到一个固定的 CPU Cache 地址（Cache Line）。而这个映射关系，通常用 mod 运算（求余运算）来实现。</p><img src="/2020/02/03/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%20%E5%86%85%E5%AD%98/5.png" class="" title="Cache 采用 mod 的方式，把内存块映射到对应的 CPU Cache 中"> <p>实际计算中，有一个小小的技巧，通常我们会把缓存块的数量设置成 2 的 N 次方。这样在计算取模的时候，可以直接取地址的低 N 位，也就是二进制里面的后几位。比如这里的 8 个缓存块，就是 2 的 3 次方。那么，在对 21 取模的时候，可以对 21 的 2 进制表示 10101 取地址的低三位，也就是 101，对应的 5，就是对应的缓存块地址。</p><img src="/2020/02/03/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%20%E5%86%85%E5%AD%98/6.png" class=""> <p>因此，当处理器需要访问一个地址时，会先在高速缓冲存储器中进行查找，查找过程中我们首先在概念上把这个地址划分成三个部分：</p><img src="/2020/02/03/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%20%E5%86%85%E5%AD%98/7.jpg" class=""> <h3 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h3><p>在<strong>直接映射</strong>中，因为每个 set 对应 1 个 line，所以 set index 的位数就会较多（和之后的多路映射对比）。具体的检索过程就是先通过 set index 确定哪个 set，然后看是否 valid，然后比较那个 set 里唯一 line 的 tag 和地址的 t bits 是否一致，就可以确定是否缓存命中。命中之后根据 block offset 确定偏移量。如果 tag 不匹配的话，这行会被扔掉并放新的数据进来。</p><img src="/2020/02/03/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%20%E5%86%85%E5%AD%98/8.jpg" class=""> <p>对于 4 位地址，对应 Block = 2，Set = 4，Line = 1 </p><ul><li><code>0 00 0</code>, miss</li><li><code>0 00 1</code>, hit</li><li><code>0 11 1</code>, miss</li><li><code>1 00 0</code>, miss</li><li><code>0 00 0</code>, miss</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">       v  Tag   Block</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Set 0  1   0    M[0-1]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Set 1  x   x      x</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">Set 2  x   x      x</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">Set 3  1   0    M[6-7]</span></pre></td></tr></table></figure><p>缓存的大小如图所示，对应就是有 4 个 set，所以需要 2 位的 set index，所以进行读入的时候，会根据中间两位来确定在哪个 set 中查找，其中 8 和 0，因为中间两位相同，会产生冲突，导致连续 miss，这个问题可以用多路映射来解决。</p><h3 id="多路映射"><a href="#多路映射" class="headerlink" title="多路映射"></a>多路映射</h3><p>当每个 set 有 E 个 line 的时候，称之为 E 路联结缓存。</p><p>假设每个 set 有 2 个 line，所以就没有那么多 set，也就是说 set index 可以少一位（集合数量少一倍），tag 多一位。</p><p>我们再用刚才的例子来看看是否会增加命中率，对应 Block = 2, Set = 2, Line = 2，我们按照如下顺序进行数据读取：</p><ul><li><code>00 0 0</code>, miss</li><li><code>00 0 1</code>, hit</li><li><code>01 1 1</code>, miss</li><li><code>10 0 0</code>, miss</li><li><code>00 0 0</code>, miss</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">       v   Tag   Block</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Set 0  1   00    M[0-1]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Set 0  1   10    M[8-9]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">Set 1  1   01    M[6-7]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">Set 1  0   x     x</span></pre></td></tr></table></figure><p>可以看到因为每个 set 有 2 个 line，所以只有 2 个 set，set index 也只需要 1 位了，这个情况下即使 8 和 0 的 set index 一致，因为一个 set 可以容纳两个数据，所以最后一次访问 0，就不会 miss 了。</p><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>如果发生写入命中的时候（也就是要写入的地址在缓存中有），有两种策略：</p><ul><li><strong>写直达</strong>（Write-through）: 命中后更新缓存，同时写入到内存中</li><li><strong>写回</strong>（Write-back）: 直到这个缓存需要被置换出去，才写入到内存中（需要额外的 dirty bit 来表示缓存中的数据是否和内存中相同，因为可能在其他的时候内存中对应地址的数据已经更新，那么重复写入就会导致原有数据丢失）</li></ul><p>在写入 miss 的时候，同样有两种方式：</p><ul><li><strong>写分配</strong>（Write-allocate）: 载入到缓存中，并更新缓存（如果之后还需要对其操作，这个方式就比较好）</li><li><strong>写不分配</strong>（No-write-allocate）: 直接写入到内存中，不载入到缓存</li></ul><p>这四种策略通常的搭配是：</p><ul><li>Write-through + No-write-allocate</li><li>Write-back + Write-allocate</li></ul><p>其中第一种可以保证绝对的数据一致性，第二种效率会比较高（通常情况下）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章为大家介绍计算机中<strong>存储器框架结构</strong>，重点介绍了<strong>高速缓存的工作原理</strong>。</p><p>到目前为止，计算机组成原理的重点知识就介绍的差不多了，接下来我们就要开始更新操作系统的相关知识了。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://time.geekbang.org/column/intro/100026001" target="_blank" rel="noopener">徐文浩 - 深入浅出计算机组成原理</a></li><li><a href="http://www.chinesemooc.org/mooc/4392" target="_blank" rel="noopener">陆俊林- 计算机组成</a></li><li><a href="https://book.douban.com/subject/26604008/" target="_blank" rel="noopener">戴维 A.帕特森 (David A.Patterson) / 约翰 L.亨尼斯 (John L.Hennessy) - 计算机组成与设计：硬件/软件接口（原书第5版）</a></li><li><a href="https://wdxtub.com/csapp/thin-csapp-3/2016/04/16/" target="_blank" rel="noopener">小土刀 - 【读薄 CSAPP】叁 内存与缓存</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一章我们介绍计算机中&lt;strong&gt;流水线指令系统设计&lt;/strong&gt;，介绍一下计算机如何&lt;strong&gt;「更快」&lt;/strong&gt;地执行，也会介绍如何去解决流水线处理器中的&lt;strong&gt;冒险&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这一章会为大家介绍计算机中各式各样的&lt;strong&gt;存储器&lt;/strong&gt;，重点介绍&lt;strong&gt;高速缓存&lt;/strong&gt;的工作原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="组成原理" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="组成原理" scheme="http://yoursite.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>4 流水线指令设计</title>
    <link href="http://yoursite.com/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
    <id>http://yoursite.com/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/</id>
    <published>2020-02-02T05:53:53.000Z</published>
    <updated>2020-02-04T06:18:06.439Z</updated>
    
    <content type="html"><![CDATA[<p>上一章我们计算机中的指令系统，重点介绍了传送指令、流程控制和过程调用，了解了在高级语言如何转化为汇编语言来指导计算机工作。</p><p>这一章会为大家介绍计算机中<strong>流水线指令系统设计</strong>，介绍一下计算机如何<strong>「更快」</strong>地执行，也会介绍如何去解决流水线处理器中的<strong>冒险</strong>。</p><a id="more"></a><h2 id="单周期处理器"><a href="#单周期处理器" class="headerlink" title="单周期处理器"></a>单周期处理器</h2><p>首先，我们先介绍一下几个概念。</p><h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><ol><li><strong>取指</strong>（Fetch）<ul><li>从 PC 寄存器里找到对应的指令地址，根据指令地址从内存里把具体的指令，加载到指令寄存器中，然后把 PC 寄存器自增，好在未来执行下一条指令。</li></ul></li><li><strong>译码</strong>（Decode）<ul><li>根据指令寄存器里面的指令，解析成要进行什么样的操作，是 R、I、J 中的哪一种指令，具体要操作哪些寄存器、数据或者内存地址。</li></ul></li><li><strong>执行</strong>（Execute）<ul><li>实际运行对应的 R、I、J 这些特定的指令，进行算术逻辑操作、数据传输或者直接的地址跳转。</li></ul></li><li><strong>回写</strong>（Write-back）<ul><li>将运算结果写入通用寄存器或存储器</li></ul></li></ol><img src="/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/1.jpeg" class="" title="不同步骤在不同组件之内完成"> <p>样的步骤，其实就是一个永不停歇的循环，我们把这个循环称之为<strong>指令周期</strong>（Instruction Cycle）。</p><h3 id="机器周期"><a href="#机器周期" class="headerlink" title="机器周期"></a>机器周期</h3><p>例如，取指令、读写存储器等，这每一项工作称为一个基本操作。完成一个基本操作所需要的时间称为<strong>机器周期</strong>（Machine Cycle）或<strong>CPU周期</strong>。</p><h3 id="时钟周期"><a href="#时钟周期" class="headerlink" title="时钟周期"></a>时钟周期</h3><p><strong>时钟周期</strong>也称为振荡周期，定义为时钟频率的倒数。时钟周期是计算机中最基本的、最小的时间单位。在一个时钟周期内，CPU仅完成一个最基本的动作。</p><p>一个 CPU 周期，通常会由几个时钟周期累积起来。一个 CPU 周期的时间，就是这几个时钟周期的总和。对于一个指令周期来说，我们取出一条指令，然后执行它，至少需要两个 CPU 周期。取出指令至少需要一个 CPU 周期，执行至少也需要一个 CPU 周期，复杂的指令则需要更多的 CPU 周期。</p><img src="/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/2.jpeg" class="" title="三个周期（Cycle）之间的关系"> <h2 id="流水线概述"><a href="#流水线概述" class="headerlink" title="流水线概述"></a>流水线概述</h2><h3 id="单周期处理的局限"><a href="#单周期处理的局限" class="headerlink" title="单周期处理的局限"></a>单周期处理的局限</h3><p>对于单指令周期处理器（Single Cycle Processor）而言，在一个时钟周期内，处理器正好能处理一条指令。不过，我们的时钟周期是固定的，但是指令的电路复杂程度是不同的，随着门电路层数的增加，由于门延迟的存在，位数多、计算复杂的指令需要的执行时间会更长，所以<strong>实际一条指令执行的时间是不同的</strong>。</p><p>不同指令的执行时间不同，但是我们需要让所有指令都在一个时钟周期内完成，那就只好把时钟周期和执行时间最长的那个指令设成一样。这就好比学校体育课 1000 米考试，我们要给这场考试预留的时间，肯定得和跑得最慢的那个同学一样。因为就算其他同学先跑完，也要等最慢的同学跑完间，我们才能进行下一项活动。</p><img src="/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/3.jpeg" class="" title="单周期处理器的指令周期"> <h3 id="流水线的基本原理"><a href="#流水线的基本原理" class="headerlink" title="流水线的基本原理"></a>流水线的基本原理</h3><p>我们对于不同的指令步骤，所用的电路模块也是不同。因此我们可以让每一个阶段的电路在完成对应的任务之后，也不需要等待整个指令执行完成，而是可以直接执行下一条指令的对应阶段。这样的协作模式，就是我们所说的<strong>流水线</strong>。这里面每一个独立的步骤，我们就称之为<strong>流水线阶段</strong>或者流水线级（Pipeline Stage）。</p><img src="/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/4.jpeg" class="" title="流水线执行示意图"> <p>流水线中的各个处理部件可并行工作，从而可使<strong>整个程序</strong>的执行时间缩短，但并不会缩短单条指令的执行时间，甚至会增加时间（流水线寄存器），而是提高了<strong>CPU的吞吐率</strong>。</p><h3 id="超长流水线的性能瓶颈"><a href="#超长流水线的性能瓶颈" class="headerlink" title="超长流水线的性能瓶颈"></a>超长流水线的性能瓶颈</h3><p>对于较为复杂的指令，我们可将其拆分成更多的步骤，分为更多的流水线阶段，提高CPU的<strong>吞吐率</strong>。但是增加流水线的深度，会导致性能成本的问题。</p><p>时钟周期的衡量，不再是指令级别的，而是<strong>流水线阶段</strong>级别的。每一级流水线对应的输出，都要放到<strong>流水线寄存器</strong>（Pipeline Register）里面，然后在下一个时钟周期，交给下一个<strong>流水线阶段</strong>去处理。所以，每增加一级的流水线，就要多一级写入到流水线寄存器的操作。虽然流水线寄存器非常快，比如只有 20 ps。</p><p>但是，如果我们不断加深流水线，这些操作占整个指令的执行时间的比例就会不断增加。最后，我们的性能瓶颈就会出现在这些单条指令的延迟上。这也就意味着，单纯地增加流水线级数，不仅不能提升性能，反而会有更多的无谓损失。所以，设计合理的流水线级数也是现代 CPU 中非常重要的一点。</p><img src="/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/5.jpeg" class=""> <h2 id="流水线的「冒险」"><a href="#流水线的「冒险」" class="headerlink" title="流水线的「冒险」"></a>流水线的「冒险」</h2><p>流水线优质这样一种情况，在下一个时钟周期中下一条指令不能执行。这种情况称为<strong>冒险</strong>（Hazard）。下面我们介绍三种流水线冒险。</p><h3 id="结构冒险"><a href="#结构冒险" class="headerlink" title="结构冒险"></a>结构冒险</h3><p><strong>结构冒险</strong>（structural hazard）本质上是一个硬件层面的资源竞争问题。即硬件不支持多条指令在同一时钟周期执行。</p><p>例如流水线结构只有一个存储器，因此只能在一个时钟周期里面读取一条数据，没办法同时执行第 1 条指令的读取内存数据和第 4 条指令的读取指令代码。</p><img src="/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/6.jpeg" class=""> <h4 id="增加资源"><a href="#增加资源" class="headerlink" title="增加资源"></a>增加资源</h4><p>解决方案的本质就是<strong>增加资源</strong>。对于访问内存数据和取指令的冲突，一个直观的解决方案就是把我们的内存分成两部分，让它们各有各的地址译码器。这两部分分别是存放指令的<strong>程序内存</strong>和存放数据的<strong>数据内存</strong>。</p><p>这样把内存拆成两部分的解决方案，在计算机体系结构里叫作<strong>哈佛架构</strong>（Harvard Architecture），来自哈佛大学设计Mark I 型计算机时候的设计。对应的，我们之前说的<strong>冯·诺依曼体系结构</strong>，又叫作普林斯顿架构（Princeton Architecture）。</p><p>不过，我们今天使用的 CPU，仍然是冯·诺依曼体系结构的，并没有把内存拆成程序内存和数据内存这两部分。因为如果那样拆的话，对程序指令和数据需要的内存空间，我们就没有办法根据实际的应用去动态分配了。虽然解决了资源冲突的问题，但是也失去了灵活性。</p><img src="/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/7.jpeg" class=""> <p>不过，借鉴了哈佛结构的思路，现代的 CPU 虽然没有在内存层面进行对应的拆分，却在 CPU 内部的高速缓存部分进行了区分，把高速缓存分成了<strong>指令缓存</strong>（Instruction Cache）和<strong>数据缓存</strong>（Data Cache）两部分。这个我们之后会介绍。</p><h3 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h3><p><strong>数据冒险</strong>（data hazard）发生在由于一条指令必须等待另一条指令的完成而造成流水线暂停的情况。</p><p>下面我们以两条先后发生的 ADD 指令作为例子，来具体阐述一下：</p><h4 id="流水线停顿"><a href="#流水线停顿" class="headerlink" title="流水线停顿"></a>流水线停顿</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">add $t0, $s2,$s1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">add $s2, $s1,$t0</span></pre></td></tr></table></figure><ul><li>把 s1 和 s2 寄存器里面的数据相加，存入到 t0 这个寄存器里面。</li><li>把 s1 和 t0 寄存器里面的数据相加，存入到 s2 这个寄存器里面。</li></ul><p>因为后一条的 add 指令，依赖寄存器 t0 里的值。而 t0 里面的值，又来自于前一条指令的计算结果。所以后一条指令，需要等待前一条指令的数据写回阶段完成之后，才能执行。</p><p>于是，我们可以通过<strong>流水线停顿</strong>（Pipeline Stall）来解决这个冒险问题。我们要在第二条指令的译码阶段之后，插入对应的 NOP 指令，直到前一条指令的数据写回完成之后，才能继续执行。</p><p>这样的方案，虽然解决了数据冒险的问题，但是也浪费了两个时钟周期。</p><img src="/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/8.jpeg" class=""> <h4 id="操作数前推"><a href="#操作数前推" class="headerlink" title="操作数前推"></a>操作数前推</h4><p>插入过多的 NOP 操作，意味着我们的 CPU 总是在空转。那么，我们有没有什么办法，尽量少插入一些 NOP 操作呢？</p><p>其实我们第二条指令的执行，未必要等待第一条指令写回完成，才能进行。我们完全可以在第一条指令的执行阶段完成之后，直接将结果数据传输给到下一条指令的 ALU。作为输入，那我们的第二条指令，就不用再从寄存器里面，把数据再单独读出来一次，才来执行代码。</p><p>在 CPU 的硬件里面，单独拉一根信号传输的线路出来，使得 ALU 的计算结果，能够重新回到 ALU 的输入里来。这样的一条线路，就是我们的<strong>旁路</strong>（Bypassing）。它跳过了写入寄存器，再从寄存器读出的过程，也为我们节省了 2 个时钟周期。</p><img src="/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/9.jpeg" class=""> <h3 id="控制冒险"><a href="#控制冒险" class="headerlink" title="控制冒险"></a>控制冒险</h3><p><strong>控制冒险</strong>（control hazard）由于决策依赖于一条指令的结果，而其他指令正在执行中。</p><p>在遇到了控制冒险之后，我们的 CPU 除了流水线停顿，等待前面的指令执行完成之后，再去取最新的指令，还有什么好办法吗？</p><h4 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h4><p>最简单的分支预测技术，叫作<strong>「假装分支不发生」</strong>。顾名思义，自然就是仍然按照顺序，把指令往下执行。其实就是 CPU 预测，条件跳转一定不发生。这样的预测方法，其实也是一种<strong>静态预测技术</strong>。就好像猜硬币的时候，你一直猜正面，会有 50% 的正确率。</p><h4 id="动态分支预测"><a href="#动态分支预测" class="headerlink" title="动态分支预测"></a>动态分支预测</h4><p>上面的静态预测策略，看起来比较简单，预测的准确率也许有 50%。但是如果运气不好，可能就会特别差。如果根据之前条件跳转的比较结果来预测，是不是会更准一点？</p><p>我们日常生活里，最经常会遇到的预测就是天气预报。如果没有气象台给你天气预报，你想要猜一猜明天是不是下雨，你会怎么办？有一个简单的策略，就是完全根据今天的天气来猜。如果今天下雨，我们就预测明天下雨。如果今天天晴，就预测明天也不会下雨。这是一个很符合我们日常生活经验的预测。</p><p>而同样的策略，我们一样可以放在分支预测上。这种策略，我们叫<strong>一级分支预测</strong>（One Level Branch Prediction），或者叫 <strong>1 比特饱和计数</strong>（1-bit saturating counter）。这个方法，其实就是用一个比特，去记录当前分支的比较情况，直接用当前分支的比较情况，来预测下一次分支时候的比较情况。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章为大家介绍计算机中<strong>流水线指令系统设计</strong>，介绍一下计算机如何加深<strong>流水线深度</strong>，提高<strong>吞吐率</strong>，从而<strong>「更快」</strong>地执行，也介绍了流水线处理器中的<strong>冒险</strong>以及解决方案。</p><p>下一章将为大家带来<strong>存储器</strong>的相关知识，介绍一下计算机是如何高效地读写数据。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://time.geekbang.org/column/intro/100026001" target="_blank" rel="noopener">徐文浩 - 深入浅出计算机组成原理</a></li><li><a href="http://www.chinesemooc.org/mooc/4392" target="_blank" rel="noopener">陆俊林 - 计算机组成</a></li><li><a href="https://book.douban.com/subject/26604008/" target="_blank" rel="noopener">戴维 A.帕特森 (David A.Patterson) / 约翰 L.亨尼斯 (John L.Hennessy) - 计算机组成与设计：硬件/软件接口（原书第5版）</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一章我们计算机中的指令系统，重点介绍了传送指令、流程控制和过程调用，了解了在高级语言如何转化为汇编语言来指导计算机工作。&lt;/p&gt;
&lt;p&gt;这一章会为大家介绍计算机中&lt;strong&gt;流水线指令系统设计&lt;/strong&gt;，介绍一下计算机如何&lt;strong&gt;「更快」&lt;/strong&gt;地执行，也会介绍如何去解决流水线处理器中的&lt;strong&gt;冒险&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="组成原理" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="组成原理" scheme="http://yoursite.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>3 指令系统</title>
    <link href="http://yoursite.com/2020/02/01/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2020/02/01/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-02-01T05:53:53.000Z</published>
    <updated>2020-02-04T06:17:56.775Z</updated>
    
    <content type="html"><![CDATA[<p>上一章我们介绍了计算机中信息的表示，重点介绍了浮点数和补码。</p><p>这一章会为大家介绍计算机中<strong>指令系统</strong>，重点介绍<strong>汇编语言</strong>。</p><a id="more"></a><h2 id="传送指令"><a href="#传送指令" class="headerlink" title="传送指令"></a>传送指令</h2><h3 id="通用数据传送指令"><a href="#通用数据传送指令" class="headerlink" title="通用数据传送指令"></a>通用数据传送指令</h3><p>对于 <code>movq</code> 指令来说，需要源操作数和目标操作数，源操作数可以是立即数、寄存器值或内存值的任意一种，但目标操作数只能是寄存器值或内存值。指令的具体格式可以这样写 <code>movq [Imm|Reg|Mem], [Reg|Mem]</code>，第一个是源操作数，第二个是目标操作数，例如：</p><ul><li><code>movq Imm, Reg</code> $\rightarrow$ <code>mov $0x5, %rax</code> $\rightarrow$ <code>temp = 0x5;</code></li><li><code>movq Imm, Mem</code> $\rightarrow$ <code>mov $0x5, (%rax)</code> $\rightarrow$ <code>*p = 0x5;</code></li><li><code>movq Reg, Reg</code> $\rightarrow$ <code>mov %rax, %rdx</code> $\rightarrow$ <code>temp2 = temp1;</code></li><li><code>movq Reg, Mem</code> $\rightarrow$ <code>mov %rax, (%rdx)</code> $\rightarrow$ <code>*p = temp;</code></li><li><code>movq Mem, Reg</code> $\rightarrow$ <code>mov (%rax), %rdx</code> $\rightarrow$ <code>temp = *p;</code></li></ul><h3 id="地址传送指令"><a href="#地址传送指令" class="headerlink" title="地址传送指令"></a>地址传送指令</h3><p>以 <code>leaq</code> 指令为例子。具体格式为 <code>leaq Src, Dst</code>，其中 <code>Src</code> 是地址的表达式，然后把计算的值存入 <code>Dst</code> 指定的寄存器。</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h3><p>CPU还有一组<strong>条件码</strong>寄存器，它们描述了最近的算术或逻辑操作的属性，来执行条件分支指令。最常用的条件码有：</p><ul><li>CF: 进位标志。用来检查无符号操作的溢出。</li><li>ZF: 零标志。</li><li>SF: 符号标志。最近的操作得到结果为负数。</li><li>OF: 溢出标志。对于有符号数的溢出。</li></ul><p>假设有表达式 <code>t=a+b​</code> ，有如下设置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">CF(<span class="keyword">unsigned</span>) t &lt; (<span class="keyword">unsigned</span>) a无符号溢出</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">ZF(t == <span class="number">0</span>)零</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">SF(t &lt; <span class="number">0</span>)负数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">OF(a &lt; <span class="number">0</span> == b &lt; <span class="number">0</span>) &amp;&amp; (t &lt; <span class="number">0</span> != a&lt; <span class="number">0</span>)有符号溢出</span></pre></td></tr></table></figure><p>假设<code>cmpq Src2(b), Src1(a)</code> ，等同于计算 <code>a-b</code>，然后利用 <code>a-b</code> 的结果来对应进行条件代码的设置：</p><ul><li>如果在最高位还需要进位（也就是溢出了），那么 CF 标识位就会被设置</li><li>a 和 b 相等时，也就是 <code>a-b</code> 等于零时，ZF 标识位会被设置</li><li>如果 a &lt; b，也就是 <code>(a-b)&lt;0</code> 时，那么 SF 标识位会被设置</li><li>如果溢出，那么 OF 标识位会被设置（溢出的情况是 <code>(a&gt;0 &amp;&amp; b &gt; 0 &amp;&amp; t &lt;0) || (a&lt;0 &amp;&amp; b&lt;0 &amp;&amp; t&gt;=0)</code>）</li></ul><h3 id="跳转指令编码"><a href="#跳转指令编码" class="headerlink" title="跳转指令编码"></a>跳转指令编码</h3><p>我们先来看一个比较原始的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">absdiff</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">long</span> result;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (x &gt; y)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        result = x-y;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        result = y-x;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> result;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>对应的汇编代码如下，这里 <code>%rdi</code> 中保存了参数 <code>x</code>，<code>%rsi</code> 中保存了参数 <code>y</code>，而 <code>%rax</code> 一般用来存储返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">absdiff:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    cmpq    %rsi, %rdi# x &gt; y?</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    jle     .L4# if ⩽ goto loop</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    movq    %rdi, %rax# result &#x3D; x</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    subq    %rsi, %rax# result &#x3D; x - y</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    ret</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">.L4:    # x &lt;&#x3D; y</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    movq    %rsi, %rax# result &#x3D; y</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    subq    %rdi, %rax# result &#x3D; y - x</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    ret</span></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>先来看看并不那么常用的 Do-While 语句以及对应使用 goto 语句进行跳转的版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Do While 的 C 语言代码</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fact_do</span><span class="params">(<span class="keyword">long</span> n)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">long</span> result = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">do</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        result *= n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        n = n - <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">while</span> (n &gt; <span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> result;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Goto 版本</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fact_do_goto</span><span class="params">(<span class="keyword">long</span> x)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">long</span> result = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">loop:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    result *= n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    n = n - <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">goto</span> loop;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> result;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这个函数计算阶乘，翻译成汇编如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">fact_do:    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    movl    $1, %eax    # result &#x3D; 0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">.L2:                    # loop:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    imulq   %rdi, %rax# result *&#x3D; n</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    subq    $1, %rdi    # n &#x3D; n - 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    cmpq    %1, %rdi  # n &gt; 1?</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    jg      .L2         # if &gt; goto loop</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    rep; ret</span></pre></td></tr></table></figure><p>其中 <code>%rdi</code> 中存储的是参数 <code>n</code>，<code>%rax</code> 存储的是返回值。换成更通用的形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// C Code</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Body</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (Test);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Goto Version</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">loop:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">Body</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Test)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> loop</span></pre></td></tr></table></figure><p>而对于 While 语句的转换，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// C While version</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (Test)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Body</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Goto Version</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> test;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">loop:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">Body</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">test:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Test)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> loop;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">done:</span></pre></td></tr></table></figure><p>而对于 For 循环语句的转换，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// For</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Init; Test; Update)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Body</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// While Version</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">Init;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (Test) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">Body</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">Update;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>我们在使用 if…else 这样的条件分支，或者 while/for 这样的循环方式，来实现程序运行流程时，回归到计算机可以识别的机器指令级别，其实都只是一个简单的地址跳转而已，也就是一个类似于 goto 的语句。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>所谓的栈，实际上一块内存区域，这个区域的数据进出满足先进后出的原则。越新入栈的数据，地址越低，所以栈顶的地址是最小的。寄存器 %rsp 是栈指针，用来记录栈顶的位置。寄存器 %rbp 是栈帧指针。具体实例如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span> <span class="params">( <span class="keyword">int</span> x, <span class="keyword">int</span> y )</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> x+y;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">caller</span> <span class="params">( )</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> t1 = <span class="number">125</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> t2 = <span class="number">80</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = add (t1, t2);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> sum;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>汇编如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">caller：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">pushl %rbp&#x2F;* 准备阶段 *&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">movl  %rsp, %rbp</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">subl $24, %rsp</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">movl $125, -12(%rbp)&#x2F;* 分配局部变量 *&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">movl $80, -8(%rbp)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">movl -8(%rbp), %rax&#x2F;* 准备入口参数 *&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">movl %rax, 4(%rsp)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">movl -12(%rbp), %rax</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">movl %rax, (%rsp)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">call add&#x2F;* 返回参数在 %rax 中*&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">movl %rax, -4(%rbp)&#x2F;* 准备返回参数 *&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">movl -4(%rbp), %rax</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">leave&#x2F;* 结束 *&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">ret</span></pre></td></tr></table></figure><img src="/2020/02/01/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/1.png" class="" title="过程调用栈示意图"> <h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章介绍了<strong>指令系统</strong>，介绍了传送、流程、过程这几种汇编语言指令，了解了高级语言到较为底层语言的过程。</p><p>下一章将为大家带来<strong>流水线处理器指令设计</strong>，介绍一下CPU是如何<strong>「同时」</strong>进行多项任务的。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://wdxtub.com/csapp/thin-csapp-1/2016/04/16/" target="_blank" rel="noopener">小土刀 - 【读薄 CSAPP】壹 数据表示</a></li><li><a href="https://book.douban.com/subject/26912767/" target="_blank" rel="noopener">Randal E.Bryant / David O’Hallaron - 深入理解计算机系统（原书第3版）</a></li><li><a href="https://www.icourse163.org/course/NJU-1001625001" target="_blank" rel="noopener">袁春风 - 计算机系统基础(一)：程序的表示、转换与链接</a></li><li><a href="https://time.geekbang.org/column/intro/100026001" target="_blank" rel="noopener">徐文浩 - 深入浅出计算机组成原理</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一章我们介绍了计算机中信息的表示，重点介绍了浮点数和补码。&lt;/p&gt;
&lt;p&gt;这一章会为大家介绍计算机中&lt;strong&gt;指令系统&lt;/strong&gt;，重点介绍&lt;strong&gt;汇编语言&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="组成原理" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="组成原理" scheme="http://yoursite.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>2 信息的表示与处理</title>
    <link href="http://yoursite.com/2020/01/31/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA/"/>
    <id>http://yoursite.com/2020/01/31/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA/</id>
    <published>2020-01-31T05:53:53.000Z</published>
    <updated>2020-02-04T06:17:50.703Z</updated>
    
    <content type="html"><![CDATA[<p>上一章我们介绍了计算机的基本硬件组成，让我们对计算机大致有一个了解。</p><p>这一章会为大家介绍计算机中信息的表示，有些也是之前学到的，比如二进制的计算。将重点介绍<strong>无符号</strong>（unsigned）、<strong>带符号</strong>、<strong>浮点数</strong>（floating-point）这三种编码方式。</p><p>当然溢出和浮点数特殊的编码方式也会产生与预期不一样的结果，我们也会介绍。</p><a id="more"></a><h2 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h2><p>一个<strong>字节</strong>（byte）由8位组成。二进制、十进制与十六进制之间的转化如下表：</p><div class="table-container"><table><thead><tr><th style="text-align:center">十六进制</th><th style="text-align:center">十进制</th><th style="text-align:center">二进制</th><th style="text-align:center">十六进制</th><th style="text-align:center">十进制</th><th style="text-align:center">二进制</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0000</td><td style="text-align:center">8</td><td style="text-align:center">8</td><td style="text-align:center">1000</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0001</td><td style="text-align:center">9</td><td style="text-align:center">9</td><td style="text-align:center">1001</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">0010</td><td style="text-align:center">A</td><td style="text-align:center">10</td><td style="text-align:center">1010</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">0011</td><td style="text-align:center">B</td><td style="text-align:center">11</td><td style="text-align:center">1011</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:center">0100</td><td style="text-align:center">C</td><td style="text-align:center">12</td><td style="text-align:center">1100</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">5</td><td style="text-align:center">0101</td><td style="text-align:center">D</td><td style="text-align:center">13</td><td style="text-align:center">1101</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:center">0110</td><td style="text-align:center">E</td><td style="text-align:center">14</td><td style="text-align:center">1110</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">7</td><td style="text-align:center">0111</td><td style="text-align:center">F</td><td style="text-align:center">15</td><td style="text-align:center">1111</td></tr></tbody></table></div><h2 id="字数据大小"><a href="#字数据大小" class="headerlink" title="字数据大小"></a>字数据大小</h2><p>C语言支持的基本数据类型分配的字节数如下表所示：</p><div class="table-container"><table><thead><tr><th style="text-align:center">C语言声明</th><th style="text-align:center">32位 / 字节</th><th style="text-align:center">64位 / 字节</th></tr></thead><tbody><tr><td style="text-align:center">(unsigned) char</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">(unsigned) short</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">(unsigned) int</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">(unsigned) long</td><td style="text-align:center">4</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">char *</td><td style="text-align:center">4</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">8</td><td style="text-align:center">8</td></tr></tbody></table></div><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>对于带符号数而言，其编码方式与无符号数不同，为补码编码（two’ s complement）。最高有效位为符号位，当符号位为1时，值为负；符号位为0时，值为正。正负数之间补码的关系有如下结论：<strong>一个负数的补码等于将对应正数补码各位取反、末位加一</strong>。</p><p>例如：<code>11010110</code>的真值为<code>-0101010 = -(32+8+2) = -42</code></p><h2 id="整数的表示"><a href="#整数的表示" class="headerlink" title="整数的表示"></a>整数的表示</h2><p>下面定义三个整数数据：$Tmin$ - 最小补码值，$TMax$ - 最大补码值，$UMax$ - 最大无符号数。</p><p>假设字长为 <code>w</code>，定义如下的常量：</p><ul><li>$UMin = 0$ 即 <code>000…0</code></li><li>$UMax =  2^w−1 $ 即 <code>111…1</code></li><li>$TMin = −2^w−1 $ 即 <code>100…0</code></li><li>$ TMax = 2^{w−1}−1 $ 即 <code>011…1</code></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">数</th><th style="text-align:center">8</th><th style="text-align:center">16</th><th style="text-align:center">32</th><th style="text-align:center">64</th></tr></thead><tbody><tr><td style="text-align:center">$UMax$</td><td style="text-align:center">255</td><td style="text-align:center">65535</td><td style="text-align:center">4294967295</td><td style="text-align:center">18446744073709551615</td></tr><tr><td style="text-align:center">$TMin$</td><td style="text-align:center">-128</td><td style="text-align:center">-32768</td><td style="text-align:center">-2147483648</td><td style="text-align:center">-9223372036854775808</td></tr><tr><td style="text-align:center">$TMax$</td><td style="text-align:center">127</td><td style="text-align:center">32767</td><td style="text-align:center">2147483647</td><td style="text-align:center">9223372036854775807</td></tr></tbody></table></div><p>其中          $ | Tmin | = |TMax| + 1 $          $ UMax = 2*TMax + 1 $</p><h2 id="位扩展和位截断运算"><a href="#位扩展和位截断运算" class="headerlink" title="位扩展和位截断运算"></a>位扩展和位截断运算</h2><ul><li><strong>扩展：短转长</strong><br>无符号数：0扩展（前面补0）<br>带符号整数：符号扩展（前面补符）</li><li><strong>截断：长转短</strong><br>强行将高位丢弃，故可能发生“溢出”</li></ul><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 扩展操作 */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> si = <span class="number">-32768</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> usi = si;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = si;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">unsingned ui = usi ;</span></pre></td></tr></table></figure><p>输出为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">si = <span class="number">-32768</span> <span class="number">80</span> <span class="number">00</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">usi = <span class="number">32768</span> <span class="number">80</span> <span class="number">00</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">i = <span class="number">-32768</span> FF FF <span class="number">80</span> <span class="number">00</span> <span class="comment">/* 带符号整数：符号扩展 */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">ui = <span class="number">32768</span> <span class="number">00</span> <span class="number">00</span> <span class="number">80</span> <span class="number">00</span> <span class="comment">/* 无符号整数：0扩展 */</span></span></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 截断操作 */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">32768</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> si = (<span class="keyword">short</span>) i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j = si;</span></pre></td></tr></table></figure><p>输出为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">i = <span class="number">32768</span> <span class="number">00</span> <span class="number">00</span> <span class="number">80</span> <span class="number">00</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">si = <span class="number">-32768</span> <span class="number">80</span> <span class="number">00</span> <span class="comment">/* 截断时发生了“溢出” */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">j = <span class="number">-32768</span> FF FF <span class="number">80</span> <span class="number">00</span></span></pre></td></tr></table></figure><h2 id="IEEE-浮点数标准"><a href="#IEEE-浮点数标准" class="headerlink" title="IEEE 浮点数标准"></a>IEEE 浮点数标准</h2><p>IEEE浮点标准用如下公式表示：</p><script type="math/tex; mode=display">V = (-1)^s*M*2^E</script><ul><li><strong>符号</strong>：$s$ 决定其正负号。</li><li><strong>尾数</strong>：$M$ 为二进制小数。对于<strong>规格化的值</strong>而言，$M=1.f_{n-1}…f_1f_0$；对于<strong>非规格化的值</strong>而言，$M=0.f_{n-1}…f_1f_0$。其中$f_{n-1}…f_1f_0$的部分就是 frac 的编码部分。</li><li><strong>阶码</strong>：$E$ 为指数位。对于<strong>规格化的值</strong>而言，$E=Exp−Bias$，对于<strong>非规格化的值</strong>而言，$E=1−Bias$。<ul><li>$Exp$: 是 exp 编码区域的无符号数值</li><li>$Bias$：值为$2^{k−1}−1$的偏移量，其中 $k$ 是 exp 编码的位数。</li></ul></li></ul><p>对于不同的格式，也有不同的编码结构，如下图所示：</p> <img src="/2020/01/31/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA/1.jpg" class="" title="标准浮点格式"> <h3 id="数字示例"><a href="#数字示例" class="headerlink" title="数字示例"></a>数字示例</h3><p>下面假定8位浮点数，其中有 $k=4$ 的阶码位和 $n=3$ 的小数位。偏移量为 $2^{4-1}-1=7$ 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">    s exp  frac   E   值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">------------------------------------------------------------------</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    0 0000 000   -6   0   # 这部分是非规范化数值，下一部分是规范化值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    0 0000 001   -6   1&#x2F;8 * 1&#x2F;64 &#x3D; 1&#x2F;512 # 能表示的最接近零的值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    0 0000 010   -6   2&#x2F;8 * 1&#x2F;64 &#x3D; 2&#x2F;512 </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    0 0000 110   -6   6&#x2F;8 * 1&#x2F;64 &#x3D; 6&#x2F;512</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    0 0000 111   -6   7&#x2F;8 * 1&#x2F;64 &#x3D; 7&#x2F;512 # 能表示的最大非规范化值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">------------------------------------------------------------------</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    0 0001 000   -6   8&#x2F;8 * 1&#x2F;64 &#x3D; 8&#x2F;512 # 能表示的最小规范化值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    0 0001 001   -6   9&#x2F;8 * 1&#x2F;64 &#x3D; 9&#x2F;512</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    0 0110 110   -1   14&#x2F;8 * 1&#x2F;2 &#x3D; 14&#x2F;16</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    0 0110 111   -1   15&#x2F;8 * 1&#x2F;2 &#x3D; 15&#x2F;16 # 最接近且小于 1 的值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    0 0111 000    0   8&#x2F;8 * 1 &#x3D; 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    0 0111 001    0   9&#x2F;8 * 1 &#x3D; 9&#x2F;8      # 最接近且大于 1 的值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    0 0111 010    0   10&#x2F;8 * 1 &#x3D; 10&#x2F;8</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    0 1110 110    7   14&#x2F;8 * 128 &#x3D; 224</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    0 1110 111    7   15&#x2F;8 * 128 &#x3D; 240   # 能表示的最大规范化值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">------------------------------------------------------------------</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    0 1111 000   n&#x2F;a  无穷               # 特殊值</span></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章介绍了不同编码方式表示不同的数据，重点介绍了<strong>补码</strong>、<strong>浮点数</strong>。</p><p>下一章将为大家带来指引计算机工作的<strong>指令系统</strong>，介绍一下<strong>指令系统</strong>的基本概念，涉及少部分<strong>汇编语言</strong>。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://wdxtub.com/csapp/thin-csapp-1/2016/04/16/" target="_blank" rel="noopener">小土刀 - 【读薄 CSAPP】壹 数据表示</a></li><li><a href="https://book.douban.com/subject/26912767/" target="_blank" rel="noopener">Randal E.Bryant / David O’Hallaron - 深入理解计算机系统（原书第3版）</a></li><li><a href="https://time.geekbang.org/column/intro/100026001" target="_blank" rel="noopener">徐文浩 - 深入浅出计算机组成原理</a></li><li><a href="https://www.icourse163.org/course/NJU-1001625001" target="_blank" rel="noopener">袁春风 - 计算机系统基础(一)：程序的表示、转换与链接</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一章我们介绍了计算机的基本硬件组成，让我们对计算机大致有一个了解。&lt;/p&gt;
&lt;p&gt;这一章会为大家介绍计算机中信息的表示，有些也是之前学到的，比如二进制的计算。将重点介绍&lt;strong&gt;无符号&lt;/strong&gt;（unsigned）、&lt;strong&gt;带符号&lt;/strong&gt;、&lt;strong&gt;浮点数&lt;/strong&gt;（floating-point）这三种编码方式。&lt;/p&gt;
&lt;p&gt;当然溢出和浮点数特殊的编码方式也会产生与预期不一样的结果，我们也会介绍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="组成原理" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="组成原理" scheme="http://yoursite.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>1 计算机基本结构</title>
    <link href="http://yoursite.com/2020/01/30/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2020/01/30/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</id>
    <published>2020-01-30T05:53:53.000Z</published>
    <updated>2020-01-31T08:38:01.426Z</updated>
    
    <content type="html"><![CDATA[<p>本章将介绍计算机的基本硬件，以让大家对计算机大致框架有所了解，这些硬件都要完成以下功能：输入数据、输出数据、处理数据和存储数据。</p><a id="more"></a><h2 id="计算机的基本硬件组成"><a href="#计算机的基本硬件组成" class="headerlink" title="计算机的基本硬件组成"></a>计算机的基本硬件组成</h2><ol><li><strong>中央处理器CPU</strong>（Central Processing Unit）：是计算机中最核心的部分。用于执行指令。</li><li><strong>内存</strong>（Memory）：程序读取的数据、计算得到的结果都会存放在内存中，计算机程序也要加载到内存中才可以运行。</li><li><strong>主板</strong>（Motherboard）：将CPU和内存插在主板上，主板中的<strong>芯片组</strong>（Chipset）和<strong>总线</strong>（Bus）解决CPU与内存之间的通信问题。</li><li><strong>I/O设备</strong>：输入/输出设备。</li></ol><h2 id="冯·诺依曼体系结构"><a href="#冯·诺依曼体系结构" class="headerlink" title="冯·诺依曼体系结构"></a>冯·诺依曼体系结构</h2><p>1945年，冯·诺伊曼基于当时在秘密开发的<strong>EDVAC</strong>（Electronic Discrete Variable Automatic Computer），以<a href="https://ieeexplore.ieee.org/document/238389" target="_blank" rel="noopener">「First Draft of a Report on the EDVAC」</a>为题，起草了长达101页的总结报告，发表了全新的「存储程序通用电子计算机方案」。</p><h3 id="冯·诺依曼体系结构的主要思想"><a href="#冯·诺依曼体系结构的主要思想" class="headerlink" title="冯·诺依曼体系结构的主要思想"></a>冯·诺依曼体系结构的主要思想</h3><ol><li><p>计算机应由运算器、控制器、存储器、输入设备和输出设备五个基本部件组成。</p></li><li><p>各基本部件的功能是：</p><ul><li><p><strong>控制器单元</strong>（Control Unit/CU）：控制程序的流程，通常是不同条件下的分支与跳转。可自动地从存储器中取出指令加以执行；</p></li><li><p><strong>处理器单元</strong>（Processing Unit）：包含算术逻辑单元（Arithmetic Logic Unit， ALU）和处理器寄存器（Processor Register）可进行加/减/乘/除四种基本算术运算，并且也能进行一些逻辑运算和附加运算；</p></li><li><p><strong>存储器</strong>：不仅能存放数据（Data），而且也能存放指令（Instruction），形式上两者没有区别，但计算机应能区分数据还是指令；</p></li><li><p>操作人员可以通过<strong>输入/输出设备</strong>和主机进行通信。</p></li></ul></li><li><p>内部以<strong>二进制表示</strong>指令和数据。每条指令由操作码和地址码两部分组成。操作码指出操作类型，地址码指出操作数的地址。由一串指令组成程序。</p></li><li><p>采用<strong>存储程序</strong>工作方式。 </p><img src="/2020/01/30/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/1.jpeg" class="" title="冯·诺依曼体系结构示意图"> </li></ol><h2 id="计算机执行指令的过程"><a href="#计算机执行指令的过程" class="headerlink" title="计算机执行指令的过程"></a>计算机执行指令的过程</h2><ol><li><strong>取指</strong>（Fetch）<ul><li>控制器将指令的地址送往存储器；</li><li>存储器按给定的地址读出指令内容，送回控制器。</li></ul></li><li><strong>译码</strong>（Decode）<ul><li>控制器分析指令的操作性质；</li><li>控制器向有关部件发出指令所需的控制信号。</li></ul></li><li><strong>执行</strong>（Execute）<ul><li>控制器从通用寄存器或存储器取出操作数；</li><li>控制器命令运算器对操作数进行指令规定的运算。</li></ul></li><li><strong>回写</strong>（Write-back）<ul><li>将运算结果写入通用寄存器或存储器</li></ul></li></ol><img src="/2020/01/30/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/2.png" class="" title="计算机结构的简化模型"> <h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章内容相对简单，介绍了计算机的基本硬件组成、冯·诺依曼体系结构、每个基本硬件的主要功能以及计算机执行指令的过程，让大家对计算机基本组成以及功能有所了解。</p><p>下一章将为大家带来指引计算机中<strong>信息的表示与处理</strong>，来看看计算机是如何用0和1来记录信息的。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="http://www.chinesemooc.org/mooc/4392" target="_blank" rel="noopener">陆俊林 - 计算机组成</a></li><li><a href="https://time.geekbang.org/column/intro/100026001" target="_blank" rel="noopener">徐文浩 - 深入浅出计算机组成原理</a></li><li><a href="https://www.icourse163.org/course/NJU-1001625001" target="_blank" rel="noopener">袁春风 - 计算机系统基础(一)：程序的表示、转换与链接</a></li><li><a href="https://ieeexplore.ieee.org/document/238389" target="_blank" rel="noopener">J. von Neumann - First Draft of a Report on the EDVAC</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章将介绍计算机的基本硬件，以让大家对计算机大致框架有所了解，这些硬件都要完成以下功能：输入数据、输出数据、处理数据和存储数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="组成原理" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="组成原理" scheme="http://yoursite.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>我的2019年个人总结</title>
    <link href="http://yoursite.com/2020/01/01/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/%E6%88%91%E7%9A%842019%E5%B9%B4%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/01/01/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/%E6%88%91%E7%9A%842019%E5%B9%B4%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</id>
    <published>2020-01-01T03:36:39.000Z</published>
    <updated>2020-02-19T04:51:52.596Z</updated>
    
    <content type="html"><![CDATA[<p>大家好呀。在此记录一下我的2019年个人总结。</p><a id="more"></a><h2 id="个人管理"><a href="#个人管理" class="headerlink" title="个人管理"></a>个人管理</h2><p>个人管理分为身体管理、精力管理以及财务管理。</p><p>今年年初为自己添置了两份保险，以应对生活中的风险，也算是对家人和自己负责。由于学习工作的缘故，运动时间相对减少（说白了就是懒），这点不足预期。后来在平时通勤的时候尽量选择爬楼梯来增加运动量。同时对自己的饮食习惯进行调整，少盐多果蔬，一年下来也没生什么病。</p><p>年中的时候读了很多管理精力的内容，慢慢调整自己的习惯。利用日程本和计划表来规划每天的日程。期间也会放任自己的「惰性」，发展新的爱好，结识了新朋友，以此放松，恢复精力。</p><p>财务方面个人还是比较满意的，当然入门的时候也交了不少学费，但是现在也做到了每天记账，每月预算，定期投资，也达到了还算不错的收益。</p><h2 id="个人提升"><a href="#个人提升" class="headerlink" title="个人提升"></a>个人提升</h2><p>研一初决定开启「劝退大业」，但正式实施还是在今年，研一下学期选了一门计算机基础课，也取得了还算不错的分数，算是给自己一点信心吧。研二开始系统学习计算机基础知识，到目前为止基本完成了算法、组成原理、操作系统的学习，同时也点了爬虫和网页等技能树。以此搭建了自己了博客，通过Typora + CSS改进了微信排版。</p><p>这一年读了不少非虚构类书籍，并学习了很多网课，这点我是比较满意的，除了专业书籍外，也读了理财管理的书籍，并进行了输出。</p><p>今年也看了不少电影，很多自己喜欢的大作。也渐渐感觉到审查制度愈发严苛，流媒体冲击传统电影行业。</p><h2 id="2020年的计划"><a href="#2020年的计划" class="headerlink" title="2020年的计划"></a>2020年的计划</h2><h3 id="1-坚持生活"><a href="#1-坚持生活" class="headerlink" title="1. 坚持生活"></a>1. 坚持生活</h3><p>做好情绪管理，坚持运动，保持身心健康。</p><h3 id="2-职业发展"><a href="#2-职业发展" class="headerlink" title="2. 职业发展"></a>2. 职业发展</h3><p>距离毕业不到一年，年初寻找机会，为职业发展做好准备。</p><h3 id="3-内容输出"><a href="#3-内容输出" class="headerlink" title="3. 内容输出"></a>3. 内容输出</h3><p>未来一年会继续学习理财投资与专业知识，定期输出优质内容。</p><h3 id="4-内心平静"><a href="#4-内心平静" class="headerlink" title="4. 内心平静"></a>4. 内心平静</h3><p>与家人朋友坦诚沟通。</p><hr><p>「南方周末」的一篇新年祝辞我很喜欢，在此送给看到这里的朋友：</p><blockquote><p>总有一种力量它让我们泪流满面，总有一种力量它让我们抖擞精神，总有一种力量它驱使我们不断寻求「正义、爱心、良知」。这种力量来自于你，来自于你们中间的每一个人。所以，在这样的时候，在新年的第一天，我们要想向你、向你身边的每一个人，说一声，新年好！祝愿阳光打在你的脸上。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家好呀。在此记录一下我的2019年个人总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="我的年度个人总结" scheme="http://yoursite.com/categories/%E6%88%91%E7%9A%84%E5%B9%B4%E5%BA%A6%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="个人总结" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>我的2018年个人总结</title>
    <link href="http://yoursite.com/2018/12/31/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/2018%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/12/31/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/2018%E6%80%BB%E7%BB%93/</id>
    <published>2018-12-31T13:46:12.000Z</published>
    <updated>2019-12-09T06:58:57.804Z</updated>
    
    <content type="html"><![CDATA[<p>在此向朋友们分享一下我的2018年。</p><a id="more"></a><p>上半年处于低谷期。我是个理想主义者，曾坚信一点：这个世界是美好的，每个人都有基本的道德底线。纵使社会有许多不公，我们依然有法律作为最后的武器。但是上半年各种事件的冲击，使我对此产生了怀疑。</p><p>于是产生了许多负面情绪，那个时候唯一坚持的事就是胶片摄影。镜头也开始对准了一些生活小事，每一次按下快门都会给我带来无限期待，胶片记录下来的影像，也带给了我前所未有的喜悦。</p><p>毕业之后，开始为家中老人拍摄一部纪录片，记录他们七十余年的人生经历。这是我第一次拍摄较大题材的视频，前期做了不少准备，自己的摄影后期水平也得到了进一步的提升。在镜头前，老人们表现出了从未有过的状态，我也开始真正理解「家人」这一词的含义。</p><p>自己做的一切可能真的很难改变现状，但是不经意间的一个善举就会给身边的人带来莫大的温暖。而这，也许是在这个世界中我们依旧呼吸与共的理由吧。</p><p>下半年的生活并没有想象中那么符合预期，年初的时候我也调侃过这只不过是给自己的软弱找了3年的缓冲期，想不到一语成谶。我现在唯一能做的就是让自己有更多自由选择的机会。</p><p>今年年底我经历了前所未有的情绪失控。我自诩极度理性，不会轻易由情感左右，很多朋友也这样认为。但我也只是不会「轻易」由情感左右，就像在自己心中下起了雨，慢慢积蓄，最后决堤，冲垮了自己的心理防线。不过现在精神状态好了些，勉强冷静地去处理这件事了。</p><p>在这期间特别感谢几位朋友和长辈的开导与关心。这段期间我也理解「陪伴」的重要性，真正的陪伴并不是生活上细枝末节的关照与物质上的付出，而是发自内心的理解与支持。这种情感是出于双方之间的信任与尊重，并非通过不停的地位互换所带来的管控与满足。否则这种关系是畸形的，是被绑架的，是孤独而又疲惫的。而这却又是约定俗成的，是符合社会要求的，是被外界认为是幸福的。</p><p>个人提升方面依旧是技能树乱点：暑假开始学习做饭，目前勉强能够做到解决温饱；初步了解了经济学相关的知识，开启了通往「财富自由」的道路；在专业的要求下重拾编程，依旧从入门到入土。</p><p>我自己也添置了不少个人用品：「飞利浦HX6730电动牙刷」治愈了困扰多年的口腔溃疡；「iPad Pro」使小屏观影的时代成为历史；「VALIO无乳糖脱脂奶粉」对乳糖不耐受人群极为友好。</p><hr><p>2019年的计划：</p><p><strong>1.依旧不满足于现状</strong></p><p>趁着年轻，出去看看，做改变自己的事。</p><p><strong>2.身体健康</strong></p><p>这一年做的不是很好，新的一年要保持运动。</p><p><strong>3.坚持记录</strong></p><p>影像与文字是时间最忠实的朋友。</p><p><strong>4.陪伴</strong></p><p>这个世界上最美好的词。</p><hr><p>感谢家人与朋友们的陪伴，感谢你们一直都在。</p><p>新年快乐。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在此向朋友们分享一下我的2018年。&lt;/p&gt;
    
    </summary>
    
    
      <category term="我的年度个人总结" scheme="http://yoursite.com/categories/%E6%88%91%E7%9A%84%E5%B9%B4%E5%BA%A6%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="个人总结" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>「重庆森林」简评</title>
    <link href="http://yoursite.com/2018/12/03/%E7%AE%80%E8%AF%84/%E3%80%8C%E9%87%8D%E5%BA%86%E6%A3%AE%E6%9E%97%E3%80%8D%E7%AE%80%E8%AF%84/"/>
    <id>http://yoursite.com/2018/12/03/%E7%AE%80%E8%AF%84/%E3%80%8C%E9%87%8D%E5%BA%86%E6%A3%AE%E6%9E%97%E3%80%8D%E7%AE%80%E8%AF%84/</id>
    <published>2018-12-03T13:46:12.000Z</published>
    <updated>2019-12-09T06:14:25.915Z</updated>
    
    <content type="html"><![CDATA[<p>许久不见，这次聊聊王家卫导演的「重庆森林」后半部分王菲与梁朝伟之间的故事。</p><a id="more"></a><p>王家卫导演的电影中爱情总是一条主线，他电影中的主角总会做一些「不合乎逻辑」的事，这也是我之前不那么中意王家卫导演的原因。在我的电影观里，逻辑才是评判一部电影的标准。</p><p>后来才发现，现实的许多事情是从不合逻辑的。许多看似突然发生的事情过程却异常平静，带给人无穷回味；许多看似平静的事情其下却暗流涌动，积累着情绪准备迸发。而这恐怕也是生活迷人的地方。</p><p>影片中梁朝伟看似有些木讷，后知后觉。但也许他是个很难放下过去的人，喝了许久的咖啡也不愿换一个口味。很多时候无声的安静却显得十分吵闹，因为你很难把情绪排除在外，它们就伴随你左右。就像王菲总把音乐开得很大，试图盖过这无声的喧嚣。</p><p>而影片中另一个意象「房子」正好反映了梁朝伟的内心世界，伤心之人可能在外表上与常人无异，生活仿佛并没有受到什么影响。而他的内心早已下起了雨，在积水淹没自己的时候，才会在那一刻感到窒息般的痛苦。</p><p>王菲则体察到了梁朝伟的内心，这时她充当了一个合格的暗恋者，不声不响地帮梁朝伟打理内心的房间，带他走出阴霾。</p><p>我最喜欢王菲这个角色，她或许是许多对爱情保持克制的缩影。她生性自由，不想心事却有自己的心事；她渴望爱情，不停制造「巧合」来引起对方注意；她害怕爱情，对渴望已久的表白却表现得有些不知所措。</p><p>而「加州」则成了她的精神避难所，或许专注于某一件事情，是排解情绪唯一的办法，即使是不那么有效的办法。</p><p>还好这次王家卫给予了观众希望，让他二人在阔别一年之后重逢。</p><p>于1994年上映的「重庆森林」是王家卫导演在拍摄完「东邪西毒」遇到创作瓶颈，却只花了两个月时间拍摄出来的影片。影片分为上下两个部分，相互独立。它讲述了都市男女之间的情愫，有许多我们可能永远都无法察觉的情感羁绊。</p><p>这也是王家卫之所以为王家卫的原因，将生活中的种种小事拍摄出来，将种种细节埋在画面里，呈现给观众。初次观影时可能会觉得费解又矫情，当自己的阅历逐渐丰满时，才会在这其中或多或少看到自己的影子。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;许久不见，这次聊聊王家卫导演的「重庆森林」后半部分王菲与梁朝伟之间的故事。&lt;/p&gt;
    
    </summary>
    
    
      <category term="简评" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/"/>
    
      <category term="2018" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/2018/"/>
    
    
      <category term="剧情" scheme="http://yoursite.com/tags/%E5%89%A7%E6%83%85/"/>
    
      <category term="简评" scheme="http://yoursite.com/tags/%E7%AE%80%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>「狐步舞」简评</title>
    <link href="http://yoursite.com/2018/07/03/%E7%AE%80%E8%AF%84/%E7%8B%90%E6%AD%A5%E8%88%9E%E7%AE%80%E8%AF%84/"/>
    <id>http://yoursite.com/2018/07/03/%E7%AE%80%E8%AF%84/%E7%8B%90%E6%AD%A5%E8%88%9E%E7%AE%80%E8%AF%84/</id>
    <published>2018-07-03T13:46:12.000Z</published>
    <updated>2019-12-09T06:52:00.575Z</updated>
    
    <content type="html"><![CDATA[<p>有这样一种舞蹈，不论从哪里开始，永远都会回到同样的起点。</p><a id="more"></a><h2 id="第一幕"><a href="#第一幕" class="headerlink" title="第一幕"></a>第一幕</h2><p>在以色列，一个平静的中产家庭迎来几位军人的到访。母亲率先察觉到异样，昏厥倒地。父亲看着他们麻利地拿出注射器，给妻子来了一发镇定剂。接着他们宣布一个消息：在外服役的长子牺牲了。</p><p>父亲强忍悲痛接受了军方的专业「慰问」，并告知自己在精神病院的母亲，在商量儿子葬礼事宜时，却得知儿子并没有死，死的是与自己儿子同名的人。这时父亲慌了神，不惜动用特殊关系，要求儿子回家。</p><h2 id="第二幕"><a href="#第二幕" class="headerlink" title="第二幕"></a>第二幕</h2><p>在边境，不满20岁的儿子与其他三位战友驻扎在一个简陋的房中，他们百无聊赖，听着收音机，抱着M4步枪跳舞，为漫步的骆驼放行，用罐头的滚动速度来论证房子在不断倾斜。儿子则将父亲的床边故事改编成漫画，绘在笔记本上。</p><p>一天晚上，战友错将通行车辆上掉落的啤酒罐认作手雷，神经紧绷的儿子端起机枪杀了车内四名巴勒斯坦青年。</p><p>第二天，一辆推土机掩埋了报废的轿车，处理此事的军官对儿子说：你可以回家了。</p><h2 id="中场：最后的床边故事"><a href="#中场：最后的床边故事" class="headerlink" title="中场：最后的床边故事"></a>中场：最后的床边故事</h2><p>父亲儿时用传家宝希伯来圣经换取了色情杂志，自己的母亲也为此精神崩溃。后来父亲参军，期满退役，以优异成绩从大学毕业，娶妻生子，最后成为优秀的建筑师。在一切荣光背后，只有在无人的夜晚才会拭去眼泪。</p><h2 id="第三幕"><a href="#第三幕" class="headerlink" title="第三幕"></a>第三幕</h2><p>转眼便是儿子二十岁生日，只不过却只有夫妻二人在烛光前独饮。</p><p>想不到父亲极力避免的事情最后成为葬送儿子的原因。母亲控诉了父亲之后，与之吸起了大麻，在烟雾缭绕的烛火前调侃起儿子的葬礼。</p><p>在余晖中，夫妻跳起了狐步舞。</p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>在军车上，儿子画完了最后一幅画，那是一辆高举着轿车的推土机。这时，路面上出现了那只悠闲的骆驼，司机躲闪不及，车辆坠入崖中。</p><hr><p>这是一部战争片。有趣的是这部电影出奇地克制，不同于一般印象中战争电影的固有形象，片中没有对战争的强烈表现或对英雄的过分渲染。</p> <img src="/2018/07/03/%E7%AE%80%E8%AF%84/%E7%8B%90%E6%AD%A5%E8%88%9E%E7%AE%80%E8%AF%84/1.jpg" class=""> <p>驻守边疆的四名年轻士兵，任务就是筛查来往的一切车辆，消遣着每日时光。湛蓝的天空映衬着无垠的荒原，色彩艳丽的涂鸦点缀着独舞士兵的孤寂内心，没有丝毫战争的痕迹。</p><p>直到第一声枪响，观众的思绪才被拽回到现实。宁可错杀一千也不放过一个，即便对方是互有好感的年轻女郎，士兵也会抛下画笔端起机枪，屠尽眼前的一切。</p><p>片中还有另一个描写战争的细节，在军方慰问家属时，其「专业性」令人胆寒。在家国大义面前丧子之痛似乎显得微不足道，悲痛也就见怪不怪了。</p><hr><p>片中有三段狐步舞，分别是第一幕的养老院老人；第二幕的年轻士兵；第三幕的共舞夫妻，分别对应着各自的孤独，宿命的。</p><p>这部电影的主角是父亲。但没有太多对父亲过去的刻画，这也就为观众解读提供发挥空间。父亲像是一个摒弃世俗的利己主义者，会做出任何有利于自己的事情。父亲年轻时也是校园中的风云人物，似乎是这种众星捧月的虚荣会让他去拿传家宝来换取色情杂志。在战役胜利回程的路上，他才会让战友带队引路。</p><img src="/2018/07/03/%E7%AE%80%E8%AF%84/%E7%8B%90%E6%AD%A5%E8%88%9E%E7%AE%80%E8%AF%84/2.jpg" class=""><p>光鲜亮丽的外表，都是掩饰自己脆弱的秘密。</p><p>家人都深知自己的脆弱，他们陪着自己的伤口生活，让自己显得坚强。亲情是他最后的防线。这也是为什么在得知儿子「去世」的第一时间他会选择通知自己的母亲，也是为什么在得知儿子存活的第一时间选择让儿子回到自己身边，而这种对儿子的保护恰恰成为害死他的缘由。</p><p>影片的最后，妻子盯着儿子最后的那幅画说：你是那辆推土机，我是那辆轿车。</p><p>或许同这位父亲一样，极力想掩埋的秘密，最终会成为惩罚自己的恶果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有这样一种舞蹈，不论从哪里开始，永远都会回到同样的起点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="简评" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/"/>
    
      <category term="2018" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/2018/"/>
    
    
      <category term="剧情" scheme="http://yoursite.com/tags/%E5%89%A7%E6%83%85/"/>
    
      <category term="简评" scheme="http://yoursite.com/tags/%E7%AE%80%E8%AF%84/"/>
    
      <category term="战争" scheme="http://yoursite.com/tags/%E6%88%98%E4%BA%89/"/>
    
  </entry>
  
  <entry>
    <title>「血观音」简评</title>
    <link href="http://yoursite.com/2018/05/23/%E7%AE%80%E8%AF%84/%E3%80%8C%E8%A1%80%E8%A7%82%E9%9F%B3%E3%80%8D%E7%AE%80%E8%AF%84/"/>
    <id>http://yoursite.com/2018/05/23/%E7%AE%80%E8%AF%84/%E3%80%8C%E8%A1%80%E8%A7%82%E9%9F%B3%E3%80%8D%E7%AE%80%E8%AF%84/</id>
    <published>2018-05-23T13:46:12.000Z</published>
    <updated>2019-12-09T06:17:27.203Z</updated>
    
    <content type="html"><![CDATA[<p>最近观看了去年台湾金马奖的两大热门：「大佛普拉斯」与「血观音」。两者都是讲述台湾本土故事，如果说前者是道出底层人口的无可奈何，那么后者则是深刻剖析上层权贵的尔虞我诈。</p><a id="more"></a><p>「血观音」最吸引人的地方莫过于散落片中角落的细节拼图，通过对这些细节的拼凑，看清这些拼图的真相。暴力象征的<strong>血</strong>与慈眉善目的<strong>观音</strong>相结合，展现出权术更迭中无尽的修罗场，令人窒息的黑暗。</p><p>「血观音」最胆战心惊的地方是这部电影中没有一个人心存善念，甚至包括开局就领盒饭的林夫人。林夫人表面是个人畜无害的日本少妇，实则一直将马童Marco当作性奴。在问棠真话的时候，开始一直用日语与之交流，随后在问：「Marco为什么没有来帮你」时却用的是国语，为的是让棠真放下戒心，套出实情。</p><p>要说留有人性最后一丝温存的应该是棠宁。在她终于不愿再受母亲棠夫人摆布，执意赴死的时候，听到自己女儿棠真对自己的控诉：「你们不都是一样吗」。她则打开手铐，表达了自己对女儿最后的关切。</p><p>片中刻画最为深刻的角色当属棠真，演员文淇也获得了去年的金马奖最佳女配角。影片以她开头，并以她结尾。一句在外人看来平常无奇的「救救她」，则是她对自己外婆最后的复仇。影片也多次通过细节表现了她内心的变化，例如她多次用日语说「我很孤独」，并在脑海中无数次想象自己理直气壮说出Marco与林翩翩私情的情形，以及从病榻上滚下的「罪恶之果」。而她最后对爱情的追求也在Marco的冲撞下化作泡影。</p><p>以上也只是谈谈我对这部电影的看法，更多细节已经在豆瓣许多影评中阐释，这里不再赘述。</p><p>最后向大家推荐这部值得二刷的「血观音」。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近观看了去年台湾金马奖的两大热门：「大佛普拉斯」与「血观音」。两者都是讲述台湾本土故事，如果说前者是道出底层人口的无可奈何，那么后者则是深刻剖析上层权贵的尔虞我诈。&lt;/p&gt;
    
    </summary>
    
    
      <category term="简评" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/"/>
    
      <category term="2018" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/2018/"/>
    
    
      <category term="剧情" scheme="http://yoursite.com/tags/%E5%89%A7%E6%83%85/"/>
    
      <category term="简评" scheme="http://yoursite.com/tags/%E7%AE%80%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>我的2017年个人总结</title>
    <link href="http://yoursite.com/2017/12/31/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/2017%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/12/31/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/2017%E6%80%BB%E7%BB%93/</id>
    <published>2017-12-31T13:46:12.000Z</published>
    <updated>2019-12-09T06:57:26.410Z</updated>
    
    <content type="html"><![CDATA[<p>年终总结，既是对一年的回顾，又是对未来的展望。</p><a id="more"></a><p>先说一下完成的大事，年初本以为达不成这个目标，没想到最终顺利完成。过程也很曲折，柳暗花明，说好听点是学业上又步入了一个阶段，说难听点就是为自己的胆小怯弱又找到了三年的缓冲期。不过我很期待新的生活。</p><p>年初立志要司考，最终也不了了之，很是惭愧。但依旧收获满满，法律是人类行为的准则，但身边很少人具备基本的法律常识，以致于面对有争议的事件时，大多数人选择了站队，人云亦云。</p><p>暑假在北京呆了一个月，感受了现实北京的残酷。但实习的单位很好，每个人都给予了我足够多的帮助，也发生了不少值得思考的事情。</p><p>年中开始锻炼身体，现在身体得到明显改善，再接再厉。</p><p>我一直相信<strong>「教育是打破阶级固化的唯一途径」</strong>，即使生活再累再苦，步入中产意味着我的后辈实现了阶级上的飞跃。</p><p>但是面对大不公，我们也只能做围观群众，一面撸起袖子加油干，继续把自己累个半死；一面幸灾乐祸，庆幸厄运不是发生在自己头上，继续像蝼蚁一样活下去。</p><p>为众抱薪者，都已死绝。</p><p>这一年看了不少电影，参加了一次影展，去了四座城市，做了4个视频，写了7篇影评。摄影从入门到进阶，Python从入门到放弃，看到许多美好的事情，也发掘了不一样的世界。</p><hr><p>对2018年的一些计划：</p><p><strong>1. 锻炼身体，克服坏习惯</strong></p><p>继续健身，早点睡觉，少去怼人，用爱感化。</p><p><strong>2. 旅行，摄影，学习</strong></p><p>掌握新的技能，记录不一样的世界。</p><p><strong>3. 应对各种糟糕的事情</strong></p><p>糟糕的事情总是毫无征兆，未来应对这些事情时能够更加成熟。</p><p><strong>4. 发掘新事物</strong></p><p>普通的生活如此之难，自己也不希求有大起大落，保持乐观，面对未来，这就是生活的一切。</p><p>感谢所有帮助过我的人，感谢一切美好事物。</p><p>新年快乐。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;年终总结，既是对一年的回顾，又是对未来的展望。&lt;/p&gt;
    
    </summary>
    
    
      <category term="我的年度个人总结" scheme="http://yoursite.com/categories/%E6%88%91%E7%9A%84%E5%B9%B4%E5%BA%A6%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="个人总结" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>「喜丧」简评</title>
    <link href="http://yoursite.com/2017/12/27/%E7%AE%80%E8%AF%84/%E3%80%8C%E5%96%9C%E4%B8%A7%E3%80%8D%E7%AE%80%E8%AF%84/"/>
    <id>http://yoursite.com/2017/12/27/%E7%AE%80%E8%AF%84/%E3%80%8C%E5%96%9C%E4%B8%A7%E3%80%8D%E7%AE%80%E8%AF%84/</id>
    <published>2017-12-27T13:46:12.000Z</published>
    <updated>2019-12-09T06:16:10.151Z</updated>
    
    <content type="html"><![CDATA[<p>「喜丧」获得第10届FIRST青年电影展最佳影片和最佳导演，前几天观看了这部电影。</p><a id="more"></a><p>农村85岁老人含辛茹苦拉扯大六个孩子，到老来却难享天伦之乐，在突发脑血栓后，子女们纷纷想把老人送去敬老院。在子女轮流照看老人期间，发生了许多令人寒心的事情。</p><p>影片分为三个部分，场景分别发生在三个子女家庭中，这其中也有三个关键词。</p><h2 id="三儿子：外面的世界"><a href="#三儿子：外面的世界" class="headerlink" title="三儿子：外面的世界"></a>三儿子：外面的世界</h2><p>影片中有多处细节反映农村青年在外务工的现状，三儿子年轻的时候出来闯荡，生活条件是同辈人中相对较好的，但是在三孙女想去浙江时遭到了父母一致反对，反应最强烈的莫过是三儿媳。她蔑视婆婆，希望自己的女儿留在家中找个条件不错的女婿。</p><p>老人却是相当开明，鼓励三孙女出外闯荡。在三孙女去的车站里放的是黄渤的「我的要求不算高」，也反映了当代青年的心境。</p><h2 id="四女儿：笑病"><a href="#四女儿：笑病" class="headerlink" title="四女儿：笑病"></a>四女儿：笑病</h2><p>四女儿和四女婿开的是一家杂货铺，在二人怀疑老人偷了钱之后，老人精神受到刺激，得了笑病，以至于老人时不时就会突然笑起来。在四外孙外出务工去世后，全家人沉浸在悲痛的气氛中，老人却是突然大笑。</p><p>到后来老人的笑受到了子女的不解，并对其恶语相加，老人依然大笑，但老人内心却是异常痛苦，笑声却像是哭声。</p><h2 id="二儿子：菩萨"><a href="#二儿子：菩萨" class="headerlink" title="二儿子：菩萨"></a>二儿子：菩萨</h2><p>老人随身携带的物件是一尊瓷质菩萨，不管到哪里都要拜一拜，保佑子女平平安安。在遭到三儿媳的谩骂后，老人唯一一次为自己祷告。在遭到二儿媳驱赶住到牛棚里的时候，老人仍在拜菩萨，二儿子面对妻子的嫌弃和老母的怪笑，一怒之下砸碎了菩萨。自那以后老人就一直问敬老院的来信。</p><p>菩萨是老人的精神寄托，丈夫早亡，独自一人乞讨养活了六个孩子，晚年子女不孝，只能寄托于菩萨。在菩萨被砸碎后，老人对这个世界的唯一眷恋也随之破碎，在子女送她去敬老院的前一天，老人吞药自杀。</p><h2 id="喜丧"><a href="#喜丧" class="headerlink" title="喜丧"></a>喜丧</h2><p>老人并非寿寝而终，但子女却为其置办了喜丧，在舞台脱衣舞的表演中，子女的麻木不仁，台下老人的黑白遗照和舞台中央的「祭」字显得极为讽刺。影片的最后二儿媳也同样倒在地上，没有音乐，影片在沉寂中结束。</p><p><strong>我个人认为这是一部聚焦农村人口的电影，并非人性。这部电影英文名叫「Laughing to Die」，无时不刻讽刺着这个笑着死去的中国梦，将她最痛苦的那层伤疤撕开给人看。</strong></p><p>子女们并非都没有孝心，二儿子在老人去世前一晚对老人忏悔。在老人把传家宝送给二儿媳的时候，二儿媳假仁假义地寒暄了几句，便问「还有什么好东西吗？再给我点」。他们都是迫于生计，正如影片中一句台词「有钱走遍天下，没钱寸步难行」。<strong>儿女一多，也会计较个人付出的多少，孝顺的性质也就发生了变化。</strong></p><p>影片的镜头语言非常直白，也大胆启用非专业演员，二儿媳就像是个农村悍妇。真心呼吁大家可以多多关注这些小成本独立电影，不要用制作粗糙绑架他们，年轻导演可以关注到中国农村人口的残酷生活现状，难能可贵。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;「喜丧」获得第10届FIRST青年电影展最佳影片和最佳导演，前几天观看了这部电影。&lt;/p&gt;
    
    </summary>
    
    
      <category term="简评" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/"/>
    
      <category term="2017" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/2017/"/>
    
    
      <category term="剧情" scheme="http://yoursite.com/tags/%E5%89%A7%E6%83%85/"/>
    
      <category term="简评" scheme="http://yoursite.com/tags/%E7%AE%80%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>「芳华」简评</title>
    <link href="http://yoursite.com/2017/12/21/%E7%AE%80%E8%AF%84/%E3%80%8C%E8%8A%B3%E5%8D%8E%E3%80%8D%E7%AE%80%E8%AF%84/"/>
    <id>http://yoursite.com/2017/12/21/%E7%AE%80%E8%AF%84/%E3%80%8C%E8%8A%B3%E5%8D%8E%E3%80%8D%E7%AE%80%E8%AF%84/</id>
    <published>2017-12-21T13:46:12.000Z</published>
    <updated>2019-12-09T06:11:01.726Z</updated>
    
    <content type="html"><![CDATA[<p>简评主要关注其电影本身而非议论揣测。</p><a id="more"></a><p>前几天有幸在平遥国际电影展上观摩了这部电影。虽然在寒风中冻了四个小时，但是整体观影体验不错，最出彩的就是那饱受争议的6分钟长镜头，写实程度在国内战争片中极为罕见。 </p><p>本片重点描写70年代到90年代间中国发生的一系列重大事件中文工团这一群体的变迁，典型的大时代下的纪实人物电影。这其中就不免会涉及一些敏感话题，这也是本片的一大看点。</p><p>但是，冯小刚在这部电影中堆砌的东西实在太多，导致整部电影的主题模糊。文工团是摧残何小萍这类局外人的集权主义代表，而文工团则是那个时代的产物，我大胆猜想冯小刚真实的意思是批判那个时代。就连影片的结尾刘峰、肖穗子、郝淑雯三人重逢的场景中，肖郝二人还是认为当年刘峰确实猥亵的林丁丁，这也加重了刘峰人物的悲剧色彩。但是不知怎么，这种时代批判莫名其妙转化为青春赞歌，最后那个文工团告别仪式堪称影片中最大的败笔，伤害了何小萍和刘峰的集体居然要花大笔墨去写他们的引吭高歌，这也是我最不能理解的。并不是说林丁丁、郝淑雯等人没有资格缅怀青春，只是放在「芳华」整部电影背景下，她们的缅怀显得十分突兀。 </p><p>冯小刚想拍属于自己的史诗，影片中人物的服饰发型和广告牌都在体现着时代的变迁。但是，刻意渲染未免也有些造作，影片完全可以花些时间来讲何刘二人。类似像这种大时代下的人物纪实电影，最重要的一条就是单线叙事，主人公可以是事件的旁观者参与者甚至是缔造者，但是唯独不能有和主线同等地位的故事线存在。这也是为什么某些游戏大作有超越史诗电影的趋势。 </p><p>有些人可能对冯小刚比较反感，坊间也有关于他的流言蜚语。冯小刚近几年拍的这些电影都会涉及一些敏感话题，不断挑战当局的红线，也算是为下一代的电影创作营造一个更好的环境。反观第五代导演的其他几人，早年都有反响不菲的作品，而现在却也是音信杳无，只有冯小刚不甘向庸俗趣味妥协，坚持基本的道德良心，认真拍经得起时间流逝的电影，难能可贵。</p><p>期待未来有更多优秀的国产电影问世。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简评主要关注其电影本身而非议论揣测。&lt;/p&gt;
    
    </summary>
    
    
      <category term="简评" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/"/>
    
      <category term="2017" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/2017/"/>
    
    
      <category term="剧情" scheme="http://yoursite.com/tags/%E5%89%A7%E6%83%85/"/>
    
      <category term="简评" scheme="http://yoursite.com/tags/%E7%AE%80%E8%AF%84/"/>
    
      <category term="战争" scheme="http://yoursite.com/tags/%E6%88%98%E4%BA%89/"/>
    
  </entry>
  
  <entry>
    <title>「大护法」简评</title>
    <link href="http://yoursite.com/2017/07/17/%E7%AE%80%E8%AF%84/%E3%80%8C%E5%A4%A7%E6%8A%A4%E6%B3%95%E3%80%8D%E7%AE%80%E8%AF%84/"/>
    <id>http://yoursite.com/2017/07/17/%E7%AE%80%E8%AF%84/%E3%80%8C%E5%A4%A7%E6%8A%A4%E6%B3%95%E3%80%8D%E7%AE%80%E8%AF%84/</id>
    <published>2017-07-17T13:46:12.000Z</published>
    <updated>2019-12-09T06:09:27.243Z</updated>
    
    <content type="html"><![CDATA[<p>近期写简评极少，毕竟作为一个专业的段子手影评人，一定要对自己推荐的每一部电影负责。</p><a id="more"></a><p>昨天去看了「大护法」，相比于同期院线热门电影来说，这部电影的关注度真的少得可怜。偌大的影院只有我一个人，影片结束后工作人员直接赶我走，都不给一个看彩蛋的机会。同样地，与前几年国产电影保护月的国漫相比也是相形见绌，两年前的国产动漫里程碑「大圣归来」催生一批自来水军，一年前号称「十二年磨一剑」的「大鱼海棠」即使毁誉参半，但是不乏一些女粉的追捧。</p><p>而这部「大护法」没有自来水的宣传，也没有主创花絮的噱头，使我看这部电影的时候没有抱太大期望，但是观影效果却是出奇地好。这部电影号称PG-13（建议13岁以上的人群观看），但在我看来，血腥暴力程度不亚于一部R级电影。</p><p>「大护法」讲的是一名大护法寻找太子时误入与世隔绝的「花生镇」之后的奇闻异事。里面的居民「花生人」由上官吉安饲养，他们身上长出的「毒蘑菇」，就是成熟的标志，随后会被屠杀并肢解获得果实。</p><p>为了防止花生人的暴动，吉安大搞个人崇拜，称自己为吉安大神仙，说「毒蘑菇」是一种传染病，雇佣一批花生人作为自己的红卫兵，屠杀同类。并且剥夺他们说话的权力，毕竟猪猡是不会说话的。每一个花生人都会贴上假眼和假嘴，使自己更像「人」。他们都活在恐惧和仇恨中。</p><p>以上剧情是不是特别熟悉（自行脑补）。</p><p>在这个特殊的时代，这样一部含沙射影的电影以动漫的姿态上映，而且能够用一个半小时把自己想表达的东西说清楚，让电影的上映更加难能可贵。</p><p>当然这部电影也有缺陷，不知所云的台词（不排除导演故意装疯卖傻）和挖下但是没有填完的坑：大护法和保镖罗丹的背后故事、罗丹和爆乳姘头之间的关系（我的猜想是类似林仙儿和阿飞之间的关系）、小鸣和黄衣花生人的关系。</p><p>当然这些并不是我重点要说的东西。</p><p>我最喜欢的一个镜头是吉安的雇佣兵开口说话后，转身开枪将不会说话的同类打死。取得权力的花生人，会以为同类幸福生活的借口铲除异己。没有一个例外。</p><p>在此，推荐大家观看「大护法」。在这个「悟空传」和「绣春刀2」等烂片横行的国产保护月，这部电影存活的时间会很短，我希望有限的公映时间里，能够有更多的人欣赏它的价值。</p><p>最后引用马伯庸的一段话：</p><blockquote><p>尼尔·波兹曼在「娱乐至死」里说：「有两种方法可以让文化精神枯萎，一种是奥威尔式的——文化成为一个监狱；另一种是赫胥黎式的——文化成为一场滑稽戏。」有那么一阵子，大家觉得时代应该是滑向赫胥黎，奥威尔的预言只是个过于夸张的预言罢了。但没想到，有人从赫胥黎那硬把局面拽回奥威尔手里。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期写简评极少，毕竟作为一个专业的段子手影评人，一定要对自己推荐的每一部电影负责。&lt;/p&gt;
    
    </summary>
    
    
      <category term="简评" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/"/>
    
      <category term="2017" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/2017/"/>
    
    
      <category term="剧情" scheme="http://yoursite.com/tags/%E5%89%A7%E6%83%85/"/>
    
      <category term="简评" scheme="http://yoursite.com/tags/%E7%AE%80%E8%AF%84/"/>
    
      <category term="动画" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
</feed>
