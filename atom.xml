<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>吸口好时光</title>
  
  <subtitle>读书观影写字</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-09T16:01:06.483Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Brikarl</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2 进程</title>
    <link href="http://yoursite.com/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/</id>
    <published>2020-02-07T05:53:53.000Z</published>
    <updated>2020-02-09T16:01:06.483Z</updated>
    
    <content type="html"><![CDATA[<p>上一章我们介绍了操作系统的基本概念以及特性，补充了些在<strong>组成原理</strong>中未涉及的内容。</p><p>接下来两章我们会从<strong>虚拟性</strong>出发，去分别介绍<strong>进程</strong>（ CPU 虚拟）和<strong>内存管理</strong>（内存虚拟）。这一章先介绍进程的基本概念以及进程的<strong>调度算法</strong>。</p><a id="more"></a><h2 id="进程的基本概念"><a href="#进程的基本概念" class="headerlink" title="进程的基本概念"></a>进程的基本概念</h2><p>首先，我们先来明确<strong>进程</strong>这个概念。</p><ul><li><strong>程序</strong>（Program）：就是存放在硬盘中的可执行文件，是一系列的指令集合，是<strong>静态</strong>的。</li><li><strong>进程</strong>（Process）：是程序的一次执行过程，是<strong>动态</strong>的。同一个程序多次执行可对应多个进程。</li></ul><p>对于不同进程，操作系统也会为其创造特定的<strong>PID</strong>（Process ID）。PID与分配的资源、运行的情况等信息，共同保存在一个数据结构，<strong>进程控制块</strong>（ <strong>PCB</strong> Process Control Block）。PCB与<strong>程序段</strong>、<strong>数据段</strong>共同构成进程。</p><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/1.png" class="" title="进程的运行"> <h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><ul><li><strong>创建态</strong>：当进程正在被创建时，它的状态就是<strong>创建态</strong>。操作系统会为其分配资源，初始化 PCB。</li><li><strong>就绪态</strong>：处于<strong>就绪态</strong>的进程已经具备运行条件，但由于没有空闲的 CPU ，就暂时不能运行。</li><li><strong>运行态</strong>：如果一个进程此时在 CPU 上运行，那么这个进程处于<strong>运行态</strong>。</li><li><strong>阻塞态</strong>：在进程运行的过程中，可能会请求等待某个事件的发生，如等待某种资源的分配，或者等待其他进程的响应。在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下 CPU ，并让其进入<strong>阻塞态</strong>。</li><li><strong>终止态</strong>：当一个进程请求操作系统终止该进程时，该进程会进入<strong>终止态</strong>，操作系统会回收其所有资源。</li></ul><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/2.png" class="" title="进程的状态"> <h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>这部分我们将讨论 <strong>Unix 系统</strong>的进程创建，首先先介绍一下三个进程的 API：</p><ul><li><strong>fork()</strong>：用来创建新的进程，原来的进程称为<strong>父进程</strong>，新创建的进程称为<strong>子进程</strong>。这两个进程几乎完全相同，但是其 <strong>PID</strong> 不同。</li><li><strong>wait()</strong>：允许父进程等待子进程执行结束。</li><li><strong>exec()</strong>：允许子进程<strong>「偏离」</strong>父进程，执行新的程序。</li></ul><p>下面我们来看一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world (pid:%d)\n"</span>, (<span class="keyword">int</span>) getpid());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> rc = fork();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#123; <span class="comment">// fork 失败并退出</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"fork failed\n"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#123; <span class="comment">// 子进程</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello, I am child (pid:%d)\n"</span>, (<span class="keyword">int</span>) getpid());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">char</span> * myargs[<span class="number">3</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        myargs[<span class="number">0</span>] = strdup(<span class="string">"wc"</span>); <span class="comment">// 新的程序：计算程序行数、词数、字节数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        myargs[<span class="number">1</span>] = strdup(<span class="string">"p3.c"</span>); <span class="comment">// 需要计算的程序</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        myargs[<span class="number">2</span>] = <span class="literal">NULL</span>; <span class="comment">// 标记结束</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        execvp(myargs[<span class="number">0</span>], myargs); <span class="comment">// 执行程序并退出</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"this shouldn’t print out"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> rc_wait = wait(<span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello, I am parent of %d (rc_wait:%d) (pid:%d)\n"</span>, rc, rc_wait, (<span class="keyword">int</span>) getpid());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>对于这个例子，<code>fork()</code>之后，创建子进程，对于父进程来讲<code>rc = 子进程的PID</code>，对于子进程来讲<code>rc = 0</code>，故在子进程执行时，会跳转至其分支，并通过调用<code>execvp()</code>来执行新的程序。</p><p>对于父进程，先调用<code>wait()</code>，以至于先输出子进程结果，不会因为时间片耗尽而提前执行父进程。</p><p>最后输出结果为：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">prompt&gt; ./p3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">hello world (pid:<span class="number">29383</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">hello, I am child (pid:<span class="number">29384</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="number">29</span> <span class="number">107</span> <span class="number">1030</span> p3.c</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">hello, I am parent of <span class="number">29384</span> (rc_wait:<span class="number">29384</span>) (pid:<span class="number">29383</span>)</span></pre></td></tr></table></figure><h2 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h2><p>在计算机运行过程中，通常会有多个进程同时竞争 CPU。因此，计算机要选择运行的程序。完成这项工作的部分称为<strong>调度程序</strong>（Scheduler），该程序使用的算法称为<strong>调度算法</strong>（Scheduling Algorithm）。</p><h3 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h3><p>首先，我们引入假设，以简化调度过程。</p><ul><li>每个任务运行相同时间。</li><li>所有任务同时到达。</li><li>一旦启动，每个任务运行到结束。</li><li>所有任务只使用 CPU。</li><li>已知每个任务的运行时间。</li></ul><p>之后，我们会逐步消除假设，以探讨调度问题。</p><h3 id="评价标准"><a href="#评价标准" class="headerlink" title="评价标准"></a>评价标准</h3><p>我们引入两个评价指标，以评价调度算法的优劣：</p><ul><li><strong>周转时间</strong>（Turnaround Time）：$ T_{turnaround} = T_{completion}-T_{arrival} $</li><li><strong>响应时间</strong>（Response Time）：$T_{response}=T_{firstrun}-T_{arrival}$</li></ul><h3 id="先来先服务（First-In-First-Out）"><a href="#先来先服务（First-In-First-Out）" class="headerlink" title="先来先服务（First In, First Out）"></a>先来先服务（First In, First Out）</h3><p>有三个任务A、B、C几乎同时到达（$T_A&lt;T_B&lt;T_C$）。</p><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/3.png" class="" title="FIFO 简单例子"> <p>从上图我们可以看出，A 于 10 结束，B 于 20 结束，C 于 30 结束。因此其平均周转时间为 $\frac{10+20+30}{3}=20$.</p><p>下面，我们舍弃第一条假设（每个任务运行相同时间），还是刚才那三个任务，只不过 A 运行 100 秒，B、C 分别运行 10 秒。</p><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/4.png" class="" title="FIFO 为什么不是最优解"> <p>由此可见，A 任务要整整运行 100 秒，才可以轮到 B 任务。其平均周转时间也高达 $\frac{100+110+120}{3}=110$.</p><p>这种现象称为<strong>车队效应</strong>（Convey effect），有点类似在现实生活中，你在超市排队时，前面的人买了三车食品的样子。</p><h3 id="最短作业优先（Shortest-Job-First）"><a href="#最短作业优先（Shortest-Job-First）" class="headerlink" title="最短作业优先（Shortest Job First）"></a>最短作业优先（Shortest Job First）</h3><p>之前在宜家购物的时候，有一个专门的购物通道是为小件商品用户提供的，这也是 SJF 调度算法的策略。</p><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/5.png" class="" title="SJF 简单例子"> <p>同样是 A、B、C 几乎同时到达。但是由于 B 任务较 A 任务较短。因此其平均周转时间为 $\frac{10+20+120}{3}=50$.缩短了很多。</p><p>这时，我们舍弃第二条假设（所有任务同时到达）。此时假设 A 任务于 $t =0$ 时刻到达且运行 100 秒，而 B、C 任务于 $t =10$ 时刻到达且运行 10 秒。</p><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/6.png" class="" title="当 B、C 稍晚到达 SJF 调度算法"> <p>此时的平均周转时间为 $\frac{100+(110-20)+(120-10)}{3}=103.33$.</p><h3 id="最短时间完成优先（Shortest-Time-to-Completion）"><a href="#最短时间完成优先（Shortest-Time-to-Completion）" class="headerlink" title="最短时间完成优先（Shortest Time-to-Completion）"></a>最短时间完成优先（Shortest Time-to-Completion）</h3><p>现在我们舍弃第三条假设（一旦启动，每个任务运行到结束），使调度程序成为<strong>抢占型</strong>（Preemptive），可以切换上下文（Context switch），暂停运行任务，转而运行其他任务。因此 STCF 中会抢占 A 任务以让 B、C 任务运行，直到后者运行结束后才会继续运行 A 任务。</p><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/7.png" class="" title="STCF 简单示例"> <p>此时的平均周转时间为 $\frac{(120-0)+(20-10)+(30-10)}{3}=50$.</p><p>由于现代计算机采用时分技术，用户更希望能够与操作系统发生交互。因此<strong>响应时间</strong>也是衡量调度算法的关键。上述例子中，A 的响应时间为 0，B 为 0，C 为 10，平均响应时间为$\frac{0+0+10}{3}=3.33$.</p><p>但是三个任务同时到达时，那么第三个任务需要等待很长时间才可以得到响应。</p><h3 id="时间片轮转（Round-Robin）"><a href="#时间片轮转（Round-Robin）" class="headerlink" title="时间片轮转（Round Robin）"></a>时间片轮转（Round Robin）</h3><p>不同于之前每个任务都要完成，RR 则只在一个<strong>时间片</strong>（Time slice）中运行任务，然后会切换到下一个任务，如此往复直到任务全部完成。</p><p>假设三个任务同时到达，每个运行 5 秒，时间片为 1 秒。</p><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/8.png" class=""> <p>对于 RR，其平均响应时间为 $\frac{0+1+2}{3}=1$.而 SJF 则为 $\frac{0+5+10}{3}=5$.</p><p>时间片长短对于 RR 来说非常关键，时间片越短，其响应越快；相应的，上下文切换的消耗会主导其整体性能。</p><p>RR 有着很好的响应速度，但是对于平均周转时间来说，表现并不是那么出色。$\frac{13+14+15}{3}=14$.</p><h3 id="I-O交互"><a href="#I-O交互" class="headerlink" title="I/O交互"></a>I/O交互</h3><p>现在，我们舍弃第四个假设（所有任务只使用 CPU）。当一个运行中的任务发起 I/O 请求时，CPU 会处于空转，等待 I/O 完成。因此，调度程序可以在这段时间内将 CPU 交给下一个任务，等待 I/O 完成后，发起中断。</p><p>假设 A、B 任务都在 CPU 上运行 50ms，但 A 任务每运行 10ms 时，会发起一次 I/O 请求。下图为两种不同的调度算法。</p><img src="/2020/02/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%20%E8%BF%9B%E7%A8%8B/9.png" class=""> <p>A 任务会分成 5 个 10ms 的子任务。我们可以把子任务当作独立的任务，当系统开始运行时，有 10ms A 与 50ms B，采用 STCF 调度，毫无疑问选择 A 任务。当第一个子任务完成时，CPU 上只剩下 B 任务，因此开始运行。当新的子任务提交后，A 会抢占 B运行 10ms。由此会产生交叠（Overlap），使 CPU 利用率最大化。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章开始介绍操作系统的第一个特性<strong>虚拟化</strong>，先介绍<strong>进程</strong>的相关概念。接着介绍了进程调度的相关知识。</p><p>下一章将为大家带来<strong>内存管理</strong>的相关知识，看看内存是如何虚拟化的。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://book.douban.com/subject/33463930/" target="_blank" rel="noopener">雷姆兹·H.阿帕希杜塞尔 / 安德莉亚·C.阿帕希杜塞尔 - 操作系统导论</a></li><li><a href="https://www.bilibili.com/video/av70156862/" target="_blank" rel="noopener">王道考研 - 操作系统</a></li><li><a href="https://book.douban.com/subject/27096665/" target="_blank" rel="noopener">Andrew S. Tanenbaum / Herbert Bos - 现代操作系统（原书第4版）</a></li><li><a href="https://time.geekbang.org/column/intro/100024701" target="_blank" rel="noopener">刘超 - 趣谈Linux操作系统</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一章我们介绍了操作系统的基本概念以及特性，补充了些在&lt;strong&gt;组成原理&lt;/strong&gt;中未涉及的内容。&lt;/p&gt;
&lt;p&gt;接下来两章我们会从&lt;strong&gt;虚拟性&lt;/strong&gt;出发，去分别介绍&lt;strong&gt;进程&lt;/strong&gt;（ CPU 虚拟）和&lt;strong&gt;内存管理&lt;/strong&gt;（内存虚拟）。这一章先介绍进程的基本概念以及进程的&lt;strong&gt;调度算法&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>1 操作系统概述</title>
    <link href="http://yoursite.com/2020/02/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2020/02/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</id>
    <published>2020-02-06T05:53:53.000Z</published>
    <updated>2020-02-07T06:40:00.483Z</updated>
    
    <content type="html"><![CDATA[<p>之前我们介绍了计算机的<strong>组成原理</strong>，从今天开始，我们要开始介绍计算机的<strong>操作系统</strong>。操作系统作为用户与硬件之间最重要的枢纽，有着非常重要的意义。</p><p>本章将带来操作系统的基本概念、功能特性、发展历史以及体系结构，也会补充些硬件方面的知识，完善知识结构。</p><a id="more"></a><h2 id="操作系统的基本概念"><a href="#操作系统的基本概念" class="headerlink" title="操作系统的基本概念"></a>操作系统的基本概念</h2><p>之前我们了解过、计算机由处理器、内存、磁盘、输入输出等设备组成。而我们现在操作这些硬件以实现某些功能的时候，并不需要去掌握其底层逻辑。这是因为<strong>操作系统</strong>为用户程序提供了一个更简洁、更清晰的计算机模型，并且管理硬件部分。</p><p>目前，计算机有两种运行模式：</p><ul><li><strong>内核态</strong>：操作系统运行于此，在这个模式下，操作系统拥有对所有硬件的完全访问权。</li><li><p><strong>用户态</strong>：软件的其余部分均运行于此。</p><ul><li>用户接口程序：shell（基于文本），图形用户界面（GUI）。</li></ul><img src="/2020/02/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/1.png" class="" title="操作系统所处的位置"> </li></ul><p>下面我们以应用程序的实际例子，来介绍下操作系统对硬件资源管理的功能：</p><ul><li><strong>文件管理</strong>：打开文件夹，找到可执行文件存放的位置。</li><li><strong>存储器管理</strong>：把程序相关数据加载到内存中。</li><li><strong>处理器管理</strong>：CPU处理对应进程。</li><li><strong>设备管理</strong>：将键盘、显示器等设备分配给该程序。</li></ul><p>接下来的几章也会围绕以上功能展开。</p><h2 id="操作系统的发展"><a href="#操作系统的发展" class="headerlink" title="操作系统的发展"></a>操作系统的发展</h2><ul><li><strong>手工操作阶段</strong>：早期的计算机程序要使用打孔卡来运作，需要人工放入打孔卡来交给计算机去执行。</li><li><strong>批处理阶段</strong><ul><li>单道批处理系统：单周期处理器。</li><li>多道批处理系统：流水线处理器。</li></ul></li><li><strong>分时操作系统</strong>：计算机以<strong>时间片</strong>为单位<strong>轮流</strong>为各个用户、作业服务，各个用户可通过终端与计算机进行交互。</li><li><strong>实时操作系统</strong>：在前者的基础上更能优先处理某些紧急任务。</li><li>网络操作系统</li><li>分布式操作系统</li><li>个人计算机操作系统</li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><strong>异常</strong>（Exception）其实是一个硬件和软件组合到一起的处理过程。当处理器检测到有事件发生时，会通过<strong>异常表</strong>(Exception Table)来确定跳转的位置，到一个专门处理这类事件的操作系统子程序（异常处理程序）。当异常处理程序完成处理后，根据引起异常事件的类型，发生以下三种情况中的一种：</p><ul><li>返回当前指令。</li><li>返回下一条指令。</li><li><p>终止。</p> </li></ul><h3 id="异步异常（中断）"><a href="#异步异常（中断）" class="headerlink" title="异步异常（中断）"></a>异步异常（中断）</h3><p><strong>异步异常</strong>(Asynchronous Exception)称之为<strong>中断</strong>(Interrupt)，是由处理器外面发生的事情引起的。对于执行程序来说，这种“中断”的发生完全是异步的，因为不知道什么时候会发生，CPU对其的响应也完全是被动的。例如：</p><ul><li><strong>计时器中断</strong>：计时器中断是由计时器芯片每隔几毫秒触发的，内核用计时器终端来从用户程序手上拿回控制权。</li><li><strong>I/O 中断</strong>：I/O 中断类型比较多样，比方说键盘输入了 ctrl-c，网络中一个包接收完毕，都会触发这样的中断。</li></ul><h3 id="同步异常"><a href="#同步异常" class="headerlink" title="同步异常"></a>同步异常</h3><p><strong>同步异常</strong>(Synchronous Exception)是因为执行某条指令所导致的事件，分为<strong>陷阱</strong>(Trap)、<strong>故障</strong>(Fault)和<strong>终止</strong>(Abort)三种情况。</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">原因</th><th style="text-align:center">示例</th><th style="text-align:center">触发时机</th><th style="text-align:center">处理后操作</th></tr></thead><tbody><tr><td style="text-align:center">中断</td><td style="text-align:center">I/O设备信号</td><td style="text-align:center">用户键盘输入</td><td style="text-align:center">异步</td><td style="text-align:center">下一条指令</td></tr><tr><td style="text-align:center">陷阱</td><td style="text-align:center">程序刻意触发</td><td style="text-align:center">程序进行系统调用</td><td style="text-align:center">同步</td><td style="text-align:center">下一条指令</td></tr><tr><td style="text-align:center">故障</td><td style="text-align:center">程序执行出错</td><td style="text-align:center">程序加载时缺页</td><td style="text-align:center">同步</td><td style="text-align:center">当前指令</td></tr><tr><td style="text-align:center">中止</td><td style="text-align:center">故障无法恢复</td><td style="text-align:center">整数除零</td><td style="text-align:center">同步</td><td style="text-align:center">退出程序</td></tr></tbody></table></div><h2 id="操作系统的基本特征"><a href="#操作系统的基本特征" class="headerlink" title="操作系统的基本特征"></a>操作系统的基本特征</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ul><li><strong>并发</strong>：指的是两个或多个事件在同一时间间隔内发生。这些事件在宏观上是同时发生的，但在微观上是交替发生的。</li><li><strong>并行</strong>：指的是两个或多个事件在同一时刻同时发生。</li></ul><p>例如：我们可以边写作业边听歌，这是并行。也可以写一会儿作业听一会儿歌，只要我们做事情足够快，就会在宏观上看起来同时发生。</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p><strong>异步</strong>：在多通道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p><p>例如：我们有时候会在特定时间间隔内写完作业，以至于我们听歌并不能一贯到底。</p><h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><p><strong>虚拟</strong>：把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p><p>例如：</p><ul><li>CPU 的<strong>时分复用技术</strong>，使得在用户看来有多个 CPU 为自己服务。</li><li>内存的<strong>空分复用技术</strong>，虚拟内存</li></ul><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p><strong>共享</strong>：资源共享，指系统中的资源可供内存中多个并发执行的进程共同使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章由计算机组成过渡到了计算机操作系统，重点为大家介绍了操作系统的特征和异常。接下来几章也会围绕上述内容展开。</p><p>下一章将为大家带来<strong>进程与线程</strong>的知识，带大家看看 CPU 是如何分配和调度自己的资源的。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://www.bilibili.com/video/av70156862/" target="_blank" rel="noopener">王道考研 - 操作系统</a></li><li><a href="https://time.geekbang.org/column/intro/100026001" target="_blank" rel="noopener">徐文浩 - 深入浅出计算机组成原理</a></li><li><a href="https://wdxtub.com/csapp/thin-csapp-5/2016/04/16/" target="_blank" rel="noopener">小土刀 - 【读薄 CSAPP】伍 异常控制流</a></li><li><a href="https://book.douban.com/subject/27096665/" target="_blank" rel="noopener">Andrew S. Tanenbaum / Herbert Bos - 现代操作系统（原书第4版）</a></li><li><a href="https://book.douban.com/subject/26912767/" target="_blank" rel="noopener">Randal E.Bryant / David O’Hallaron - 深入理解计算机系统（原书第3版）</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前我们介绍了计算机的&lt;strong&gt;组成原理&lt;/strong&gt;，从今天开始，我们要开始介绍计算机的&lt;strong&gt;操作系统&lt;/strong&gt;。操作系统作为用户与硬件之间最重要的枢纽，有着非常重要的意义。&lt;/p&gt;
&lt;p&gt;本章将带来操作系统的基本概念、功能特性、发展历史以及体系结构，也会补充些硬件方面的知识，完善知识结构。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>5 存储器</title>
    <link href="http://yoursite.com/2020/02/03/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%20%E5%86%85%E5%AD%98/"/>
    <id>http://yoursite.com/2020/02/03/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%20%E5%86%85%E5%AD%98/</id>
    <published>2020-02-03T05:53:53.000Z</published>
    <updated>2020-02-04T08:35:34.605Z</updated>
    
    <content type="html"><![CDATA[<p>上一章我们介绍计算机中<strong>流水线指令系统设计</strong>，介绍一下计算机如何<strong>「更快」</strong>地执行，也会介绍如何去解决流水线处理器中的<strong>冒险</strong>。</p><p>这一章会为大家介绍计算机中各式各样的<strong>存储器</strong>，重点介绍<strong>高速缓存</strong>的工作原理。</p><a id="more"></a><h2 id="存储层次结构概况"><a href="#存储层次结构概况" class="headerlink" title="存储层次结构概况"></a>存储层次结构概况</h2><p>我们先把计算机的存储器层次结构和我们日常生活里处理信息、阅读书籍做个对照，好让你更容易理解、记忆存储器的层次结构。</p><p>我们常常把 CPU 比喻成计算机的「大脑」。我们思考的东西，就好比 CPU 中的<strong>寄存器</strong>（Register）。寄存器与其说是存储器，其实它更像是 CPU 本身的一部分，只能存放极其有限的信息，但是速度非常快，和 CPU 同步。而我们大脑中的记忆，就好比 <strong>CPU Cache</strong>（CPU 高速缓存，我们常常简称为<strong>缓存</strong>）。<strong>CPU Cache </strong>用的是一种叫作 <strong>SRAM</strong>（Static Random-Access Memory，静态随机存取存储器）的芯片。</p><h3 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h3><p>在 CPU 里，通常会有 L1、L2、L3 这样三层高速缓存。每个 CPU 核心都有一块属于自己的 L1 高速缓存，通常分成<strong>指令缓存</strong>和<strong>数据缓存</strong>，分开存放 CPU 使用的指令和数据。</p><p>L2 的 Cache 同样是每个 CPU 核心都有的，不过它往往不在 CPU 核心的内部。所以，L2 Cache 的访问速度会比 L1 稍微慢一些。而 L3 Cache，则通常是多个 CPU 核心共用的，尺寸会更大一些，访问速度自然也就更慢一些。</p><p>你可以把 CPU 中的 L1 Cache 理解为我们的<strong>短期记忆</strong>，把 L2/L3 Cache 理解成<strong>长期记忆</strong>，把内存当成我们拥有的<strong>书架</strong>。 当我们自己记忆中没有资料的时候，可以从书架上拿书来翻阅。这个过程中就相当于，数据从内存中加载到 CPU 的寄存器和 Cache 中，然后通过「大脑」，也就是 CPU，进行处理和运算。</p><h3 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h3><p>内存用的芯片和 Cache 有所不同，它用的是一种叫作 <strong>DRAM</strong>（Dynamic Random Access Memory，动态随机存取存储器）的芯片，比起 SRAM 来说，它的密度更高，有更大的容量，而且它也比 SRAM 芯片便宜不少。</p><p>因为数据是存储在电容里的，电容会不断漏电，所以需要定时刷新充电，才能保持数据不丢失。DRAM 的数据访问电路和刷新电路都比 SRAM 更复杂，所以访问延时也就更长。</p><img src="/2020/02/03/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%20%E5%86%85%E5%AD%98/1.png" class=""> <p>各个存储器只和相邻的一层存储器打交道，并且随着一层层向下，存储器的容量逐层增大，访问速度逐层变慢，而单位存储成本也逐层下降，也就构成了我们日常所说的存储器层次结构。</p><img src="/2020/02/03/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%20%E5%86%85%E5%AD%98/2.png" class="" title="存储器的层次关系图"> <h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><p>性能和价格的巨大差异，给我们工程师带来了一个挑战：我们能不能既享受 CPU Cache 的速度，又享受内存、硬盘巨大的容量和低廉的价格呢？</p><p>存储器中数据的<strong>局部性原理</strong>（Principle of Locality）。我们可以利用这个局部性原理，来制定管理和访问数据的策略。这个局部性原理包括<strong>时间局部性</strong>（temporal locality）和<strong>空间局部性</strong>（spatial locality）这两种策略。</p><h3 id="时间局部性"><a href="#时间局部性" class="headerlink" title="时间局部性"></a>时间局部性</h3><p>我们先来看时间局部性。这个策略是说，如果一个数据被访问了，那么它在短时间内还会被再次访问。</p><p>比如说，「哈利波特与魔法石」这本小说，我今天读了一会儿，没读完，明天还会继续读。同理，在一个电子商务型系统中，如果一个用户打开了 App，看到了首屏。我们推断他应该很快还会再次访问网站的其他内容或者页面，我们就将这个用户的个人信息，从存储在硬盘的数据库读取到内存的缓存中来。这利用的就是时间局部性。</p><img src="/2020/02/03/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%20%E5%86%85%E5%AD%98/3.png" class="" title="时间局部性"> <h3 id="空间局部性"><a href="#空间局部性" class="headerlink" title="空间局部性"></a>空间局部性</h3><p>我们再来看空间局部性。这个策略是说，如果一个数据被访问了，那么和它相邻的数据也很快会被访问。</p><p>我们还拿刚才读「哈利波特与魔法石」的例子来说。我读完了这本书之后，感觉这书不错，所以就会借阅整套「哈利波特」。这就好比我们的程序，在访问了数组的首项之后，多半会循环访问它的下一项。因为，在存储数据的时候，数组内的多项数据会存储在相邻的位置。这就好比图书馆会把「哈利波特」系列放在一个书架上，摆放在一起，加载的时候，也会一并加载。我们去图书馆借书，往往会一次性把 7 本都借回来。</p><img src="/2020/02/03/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%20%E5%86%85%E5%AD%98/4.png" class="" title="空间局部性"> <h2 id="高速缓存的工作原理"><a href="#高速缓存的工作原理" class="headerlink" title="高速缓存的工作原理"></a>高速缓存的工作原理</h2><p>现代 CPU 进行数据读取的时候，无论数据是否已经存储在 Cache 中，CPU 始终会首先访问 Cache。只有当 CPU 在 Cache 中找不到数据的时候，才会去访问内存，并将读取到的数据写入 Cache 之中。当时间局部性原理起作用后，这个最近刚刚被访问的数据，会很快再次被访问。而 Cache 的访问速度远远快于内存，这样，CPU 花在等待内存访问上的时间就大大变短了。</p><p>我就从最基本的<strong>直接映射</strong> Cache（Direct Mapped Cache）为例，来看看整个 Cache 的数据结构和访问逻辑。</p><p>直接映射 Cache 采用的策略，就是确保任何一个<strong>内存块</strong>（Block）的地址，始终映射到一个固定的 CPU Cache 地址（Cache Line）。而这个映射关系，通常用 mod 运算（求余运算）来实现。</p><img src="/2020/02/03/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%20%E5%86%85%E5%AD%98/5.png" class="" title="Cache 采用 mod 的方式，把内存块映射到对应的 CPU Cache 中"> <p>实际计算中，有一个小小的技巧，通常我们会把缓存块的数量设置成 2 的 N 次方。这样在计算取模的时候，可以直接取地址的低 N 位，也就是二进制里面的后几位。比如这里的 8 个缓存块，就是 2 的 3 次方。那么，在对 21 取模的时候，可以对 21 的 2 进制表示 10101 取地址的低三位，也就是 101，对应的 5，就是对应的缓存块地址。</p><img src="/2020/02/03/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%20%E5%86%85%E5%AD%98/6.png" class=""> <p>因此，当处理器需要访问一个地址时，会先在高速缓冲存储器中进行查找，查找过程中我们首先在概念上把这个地址划分成三个部分：</p><img src="/2020/02/03/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%20%E5%86%85%E5%AD%98/7.jpg" class=""> <h3 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h3><p>在<strong>直接映射</strong>中，因为每个 set 对应 1 个 line，所以 set index 的位数就会较多（和之后的多路映射对比）。具体的检索过程就是先通过 set index 确定哪个 set，然后看是否 valid，然后比较那个 set 里唯一 line 的 tag 和地址的 t bits 是否一致，就可以确定是否缓存命中。命中之后根据 block offset 确定偏移量。如果 tag 不匹配的话，这行会被扔掉并放新的数据进来。</p><img src="/2020/02/03/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%20%E5%86%85%E5%AD%98/8.jpg" class=""> <p>对于 4 位地址，对应 Block = 2，Set = 4，Line = 1 </p><ul><li><code>0 00 0</code>, miss</li><li><code>0 00 1</code>, hit</li><li><code>0 11 1</code>, miss</li><li><code>1 00 0</code>, miss</li><li><code>0 00 0</code>, miss</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">       v  Tag   Block</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Set 0  1   0    M[0-1]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Set 1  x   x      x</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">Set 2  x   x      x</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">Set 3  1   0    M[6-7]</span></pre></td></tr></table></figure><p>缓存的大小如图所示，对应就是有 4 个 set，所以需要 2 位的 set index，所以进行读入的时候，会根据中间两位来确定在哪个 set 中查找，其中 8 和 0，因为中间两位相同，会产生冲突，导致连续 miss，这个问题可以用多路映射来解决。</p><h3 id="多路映射"><a href="#多路映射" class="headerlink" title="多路映射"></a>多路映射</h3><p>当每个 set 有 E 个 line 的时候，称之为 E 路联结缓存。</p><p>假设每个 set 有 2 个 line，所以就没有那么多 set，也就是说 set index 可以少一位（集合数量少一倍），tag 多一位。</p><p>我们再用刚才的例子来看看是否会增加命中率，对应 Block = 2, Set = 2, Line = 2，我们按照如下顺序进行数据读取：</p><ul><li><code>00 0 0</code>, miss</li><li><code>00 0 1</code>, hit</li><li><code>01 1 1</code>, miss</li><li><code>10 0 0</code>, miss</li><li><code>00 0 0</code>, miss</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">       v   Tag   Block</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Set 0  1   00    M[0-1]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Set 0  1   10    M[8-9]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">Set 1  1   01    M[6-7]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">Set 1  0   x     x</span></pre></td></tr></table></figure><p>可以看到因为每个 set 有 2 个 line，所以只有 2 个 set，set index 也只需要 1 位了，这个情况下即使 8 和 0 的 set index 一致，因为一个 set 可以容纳两个数据，所以最后一次访问 0，就不会 miss 了。</p><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>如果发生写入命中的时候（也就是要写入的地址在缓存中有），有两种策略：</p><ul><li><strong>写直达</strong>（Write-through）: 命中后更新缓存，同时写入到内存中</li><li><strong>写回</strong>（Write-back）: 直到这个缓存需要被置换出去，才写入到内存中（需要额外的 dirty bit 来表示缓存中的数据是否和内存中相同，因为可能在其他的时候内存中对应地址的数据已经更新，那么重复写入就会导致原有数据丢失）</li></ul><p>在写入 miss 的时候，同样有两种方式：</p><ul><li><strong>写分配</strong>（Write-allocate）: 载入到缓存中，并更新缓存（如果之后还需要对其操作，这个方式就比较好）</li><li><strong>写不分配</strong>（No-write-allocate）: 直接写入到内存中，不载入到缓存</li></ul><p>这四种策略通常的搭配是：</p><ul><li>Write-through + No-write-allocate</li><li>Write-back + Write-allocate</li></ul><p>其中第一种可以保证绝对的数据一致性，第二种效率会比较高（通常情况下）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章为大家介绍计算机中<strong>存储器框架结构</strong>，重点介绍了<strong>高速缓存的工作原理</strong>。</p><p>到目前为止，计算机组成原理的重点知识就介绍的差不多了，接下来我们就要开始更新操作系统的相关知识了。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://time.geekbang.org/column/intro/100026001" target="_blank" rel="noopener">徐文浩 - 深入浅出计算机组成原理</a></li><li><a href="http://www.chinesemooc.org/mooc/4392" target="_blank" rel="noopener">陆俊林- 计算机组成</a></li><li><a href="https://book.douban.com/subject/26604008/" target="_blank" rel="noopener">戴维 A.帕特森 (David A.Patterson) / 约翰 L.亨尼斯 (John L.Hennessy) - 计算机组成与设计：硬件/软件接口（原书第5版）</a></li><li><a href="https://wdxtub.com/csapp/thin-csapp-3/2016/04/16/" target="_blank" rel="noopener">小土刀 - 【读薄 CSAPP】叁 内存与缓存</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一章我们介绍计算机中&lt;strong&gt;流水线指令系统设计&lt;/strong&gt;，介绍一下计算机如何&lt;strong&gt;「更快」&lt;/strong&gt;地执行，也会介绍如何去解决流水线处理器中的&lt;strong&gt;冒险&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这一章会为大家介绍计算机中各式各样的&lt;strong&gt;存储器&lt;/strong&gt;，重点介绍&lt;strong&gt;高速缓存&lt;/strong&gt;的工作原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="组成原理" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="组成原理" scheme="http://yoursite.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>4 流水线指令设计</title>
    <link href="http://yoursite.com/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
    <id>http://yoursite.com/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/</id>
    <published>2020-02-02T05:53:53.000Z</published>
    <updated>2020-02-04T06:18:06.439Z</updated>
    
    <content type="html"><![CDATA[<p>上一章我们计算机中的指令系统，重点介绍了传送指令、流程控制和过程调用，了解了在高级语言如何转化为汇编语言来指导计算机工作。</p><p>这一章会为大家介绍计算机中<strong>流水线指令系统设计</strong>，介绍一下计算机如何<strong>「更快」</strong>地执行，也会介绍如何去解决流水线处理器中的<strong>冒险</strong>。</p><a id="more"></a><h2 id="单周期处理器"><a href="#单周期处理器" class="headerlink" title="单周期处理器"></a>单周期处理器</h2><p>首先，我们先介绍一下几个概念。</p><h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><ol><li><strong>取指</strong>（Fetch）<ul><li>从 PC 寄存器里找到对应的指令地址，根据指令地址从内存里把具体的指令，加载到指令寄存器中，然后把 PC 寄存器自增，好在未来执行下一条指令。</li></ul></li><li><strong>译码</strong>（Decode）<ul><li>根据指令寄存器里面的指令，解析成要进行什么样的操作，是 R、I、J 中的哪一种指令，具体要操作哪些寄存器、数据或者内存地址。</li></ul></li><li><strong>执行</strong>（Execute）<ul><li>实际运行对应的 R、I、J 这些特定的指令，进行算术逻辑操作、数据传输或者直接的地址跳转。</li></ul></li><li><strong>回写</strong>（Write-back）<ul><li>将运算结果写入通用寄存器或存储器</li></ul></li></ol><img src="/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/1.jpeg" class="" title="不同步骤在不同组件之内完成"> <p>样的步骤，其实就是一个永不停歇的循环，我们把这个循环称之为<strong>指令周期</strong>（Instruction Cycle）。</p><h3 id="机器周期"><a href="#机器周期" class="headerlink" title="机器周期"></a>机器周期</h3><p>例如，取指令、读写存储器等，这每一项工作称为一个基本操作。完成一个基本操作所需要的时间称为<strong>机器周期</strong>（Machine Cycle）或<strong>CPU周期</strong>。</p><h3 id="时钟周期"><a href="#时钟周期" class="headerlink" title="时钟周期"></a>时钟周期</h3><p><strong>时钟周期</strong>也称为振荡周期，定义为时钟频率的倒数。时钟周期是计算机中最基本的、最小的时间单位。在一个时钟周期内，CPU仅完成一个最基本的动作。</p><p>一个 CPU 周期，通常会由几个时钟周期累积起来。一个 CPU 周期的时间，就是这几个时钟周期的总和。对于一个指令周期来说，我们取出一条指令，然后执行它，至少需要两个 CPU 周期。取出指令至少需要一个 CPU 周期，执行至少也需要一个 CPU 周期，复杂的指令则需要更多的 CPU 周期。</p><img src="/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/2.jpeg" class="" title="三个周期（Cycle）之间的关系"> <h2 id="流水线概述"><a href="#流水线概述" class="headerlink" title="流水线概述"></a>流水线概述</h2><h3 id="单周期处理的局限"><a href="#单周期处理的局限" class="headerlink" title="单周期处理的局限"></a>单周期处理的局限</h3><p>对于单指令周期处理器（Single Cycle Processor）而言，在一个时钟周期内，处理器正好能处理一条指令。不过，我们的时钟周期是固定的，但是指令的电路复杂程度是不同的，随着门电路层数的增加，由于门延迟的存在，位数多、计算复杂的指令需要的执行时间会更长，所以<strong>实际一条指令执行的时间是不同的</strong>。</p><p>不同指令的执行时间不同，但是我们需要让所有指令都在一个时钟周期内完成，那就只好把时钟周期和执行时间最长的那个指令设成一样。这就好比学校体育课 1000 米考试，我们要给这场考试预留的时间，肯定得和跑得最慢的那个同学一样。因为就算其他同学先跑完，也要等最慢的同学跑完间，我们才能进行下一项活动。</p><img src="/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/3.jpeg" class="" title="单周期处理器的指令周期"> <h3 id="流水线的基本原理"><a href="#流水线的基本原理" class="headerlink" title="流水线的基本原理"></a>流水线的基本原理</h3><p>我们对于不同的指令步骤，所用的电路模块也是不同。因此我们可以让每一个阶段的电路在完成对应的任务之后，也不需要等待整个指令执行完成，而是可以直接执行下一条指令的对应阶段。这样的协作模式，就是我们所说的<strong>流水线</strong>。这里面每一个独立的步骤，我们就称之为<strong>流水线阶段</strong>或者流水线级（Pipeline Stage）。</p><img src="/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/4.jpeg" class="" title="流水线执行示意图"> <p>流水线中的各个处理部件可并行工作，从而可使<strong>整个程序</strong>的执行时间缩短，但并不会缩短单条指令的执行时间，甚至会增加时间（流水线寄存器），而是提高了<strong>CPU的吞吐率</strong>。</p><h3 id="超长流水线的性能瓶颈"><a href="#超长流水线的性能瓶颈" class="headerlink" title="超长流水线的性能瓶颈"></a>超长流水线的性能瓶颈</h3><p>对于较为复杂的指令，我们可将其拆分成更多的步骤，分为更多的流水线阶段，提高CPU的<strong>吞吐率</strong>。但是增加流水线的深度，会导致性能成本的问题。</p><p>时钟周期的衡量，不再是指令级别的，而是<strong>流水线阶段</strong>级别的。每一级流水线对应的输出，都要放到<strong>流水线寄存器</strong>（Pipeline Register）里面，然后在下一个时钟周期，交给下一个<strong>流水线阶段</strong>去处理。所以，每增加一级的流水线，就要多一级写入到流水线寄存器的操作。虽然流水线寄存器非常快，比如只有 20 ps。</p><p>但是，如果我们不断加深流水线，这些操作占整个指令的执行时间的比例就会不断增加。最后，我们的性能瓶颈就会出现在这些单条指令的延迟上。这也就意味着，单纯地增加流水线级数，不仅不能提升性能，反而会有更多的无谓损失。所以，设计合理的流水线级数也是现代 CPU 中非常重要的一点。</p><img src="/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/5.jpeg" class=""> <h2 id="流水线的「冒险」"><a href="#流水线的「冒险」" class="headerlink" title="流水线的「冒险」"></a>流水线的「冒险」</h2><p>流水线优质这样一种情况，在下一个时钟周期中下一条指令不能执行。这种情况称为<strong>冒险</strong>（Hazard）。下面我们介绍三种流水线冒险。</p><h3 id="结构冒险"><a href="#结构冒险" class="headerlink" title="结构冒险"></a>结构冒险</h3><p><strong>结构冒险</strong>（structural hazard）本质上是一个硬件层面的资源竞争问题。即硬件不支持多条指令在同一时钟周期执行。</p><p>例如流水线结构只有一个存储器，因此只能在一个时钟周期里面读取一条数据，没办法同时执行第 1 条指令的读取内存数据和第 4 条指令的读取指令代码。</p><img src="/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/6.jpeg" class=""> <h4 id="增加资源"><a href="#增加资源" class="headerlink" title="增加资源"></a>增加资源</h4><p>解决方案的本质就是<strong>增加资源</strong>。对于访问内存数据和取指令的冲突，一个直观的解决方案就是把我们的内存分成两部分，让它们各有各的地址译码器。这两部分分别是存放指令的<strong>程序内存</strong>和存放数据的<strong>数据内存</strong>。</p><p>这样把内存拆成两部分的解决方案，在计算机体系结构里叫作<strong>哈佛架构</strong>（Harvard Architecture），来自哈佛大学设计Mark I 型计算机时候的设计。对应的，我们之前说的<strong>冯·诺依曼体系结构</strong>，又叫作普林斯顿架构（Princeton Architecture）。</p><p>不过，我们今天使用的 CPU，仍然是冯·诺依曼体系结构的，并没有把内存拆成程序内存和数据内存这两部分。因为如果那样拆的话，对程序指令和数据需要的内存空间，我们就没有办法根据实际的应用去动态分配了。虽然解决了资源冲突的问题，但是也失去了灵活性。</p><img src="/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/7.jpeg" class=""> <p>不过，借鉴了哈佛结构的思路，现代的 CPU 虽然没有在内存层面进行对应的拆分，却在 CPU 内部的高速缓存部分进行了区分，把高速缓存分成了<strong>指令缓存</strong>（Instruction Cache）和<strong>数据缓存</strong>（Data Cache）两部分。这个我们之后会介绍。</p><h3 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h3><p><strong>数据冒险</strong>（data hazard）发生在由于一条指令必须等待另一条指令的完成而造成流水线暂停的情况。</p><p>下面我们以两条先后发生的 ADD 指令作为例子，来具体阐述一下：</p><h4 id="流水线停顿"><a href="#流水线停顿" class="headerlink" title="流水线停顿"></a>流水线停顿</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">add $t0, $s2,$s1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">add $s2, $s1,$t0</span></pre></td></tr></table></figure><ul><li>把 s1 和 s2 寄存器里面的数据相加，存入到 t0 这个寄存器里面。</li><li>把 s1 和 t0 寄存器里面的数据相加，存入到 s2 这个寄存器里面。</li></ul><p>因为后一条的 add 指令，依赖寄存器 t0 里的值。而 t0 里面的值，又来自于前一条指令的计算结果。所以后一条指令，需要等待前一条指令的数据写回阶段完成之后，才能执行。</p><p>于是，我们可以通过<strong>流水线停顿</strong>（Pipeline Stall）来解决这个冒险问题。我们要在第二条指令的译码阶段之后，插入对应的 NOP 指令，直到前一条指令的数据写回完成之后，才能继续执行。</p><p>这样的方案，虽然解决了数据冒险的问题，但是也浪费了两个时钟周期。</p><img src="/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/8.jpeg" class=""> <h4 id="操作数前推"><a href="#操作数前推" class="headerlink" title="操作数前推"></a>操作数前推</h4><p>插入过多的 NOP 操作，意味着我们的 CPU 总是在空转。那么，我们有没有什么办法，尽量少插入一些 NOP 操作呢？</p><p>其实我们第二条指令的执行，未必要等待第一条指令写回完成，才能进行。我们完全可以在第一条指令的执行阶段完成之后，直接将结果数据传输给到下一条指令的 ALU。作为输入，那我们的第二条指令，就不用再从寄存器里面，把数据再单独读出来一次，才来执行代码。</p><p>在 CPU 的硬件里面，单独拉一根信号传输的线路出来，使得 ALU 的计算结果，能够重新回到 ALU 的输入里来。这样的一条线路，就是我们的<strong>旁路</strong>（Bypassing）。它跳过了写入寄存器，再从寄存器读出的过程，也为我们节省了 2 个时钟周期。</p><img src="/2020/02/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%20%E6%B5%81%E6%B0%B4%E7%BA%BF/9.jpeg" class=""> <h3 id="控制冒险"><a href="#控制冒险" class="headerlink" title="控制冒险"></a>控制冒险</h3><p><strong>控制冒险</strong>（control hazard）由于决策依赖于一条指令的结果，而其他指令正在执行中。</p><p>在遇到了控制冒险之后，我们的 CPU 除了流水线停顿，等待前面的指令执行完成之后，再去取最新的指令，还有什么好办法吗？</p><h4 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h4><p>最简单的分支预测技术，叫作<strong>「假装分支不发生」</strong>。顾名思义，自然就是仍然按照顺序，把指令往下执行。其实就是 CPU 预测，条件跳转一定不发生。这样的预测方法，其实也是一种<strong>静态预测技术</strong>。就好像猜硬币的时候，你一直猜正面，会有 50% 的正确率。</p><h4 id="动态分支预测"><a href="#动态分支预测" class="headerlink" title="动态分支预测"></a>动态分支预测</h4><p>上面的静态预测策略，看起来比较简单，预测的准确率也许有 50%。但是如果运气不好，可能就会特别差。如果根据之前条件跳转的比较结果来预测，是不是会更准一点？</p><p>我们日常生活里，最经常会遇到的预测就是天气预报。如果没有气象台给你天气预报，你想要猜一猜明天是不是下雨，你会怎么办？有一个简单的策略，就是完全根据今天的天气来猜。如果今天下雨，我们就预测明天下雨。如果今天天晴，就预测明天也不会下雨。这是一个很符合我们日常生活经验的预测。</p><p>而同样的策略，我们一样可以放在分支预测上。这种策略，我们叫<strong>一级分支预测</strong>（One Level Branch Prediction），或者叫 <strong>1 比特饱和计数</strong>（1-bit saturating counter）。这个方法，其实就是用一个比特，去记录当前分支的比较情况，直接用当前分支的比较情况，来预测下一次分支时候的比较情况。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章为大家介绍计算机中<strong>流水线指令系统设计</strong>，介绍一下计算机如何加深<strong>流水线深度</strong>，提高<strong>吞吐率</strong>，从而<strong>「更快」</strong>地执行，也介绍了流水线处理器中的<strong>冒险</strong>以及解决方案。</p><p>下一章将为大家带来<strong>存储器</strong>的相关知识，介绍一下计算机是如何高效地读写数据。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://time.geekbang.org/column/intro/100026001" target="_blank" rel="noopener">徐文浩 - 深入浅出计算机组成原理</a></li><li><a href="http://www.chinesemooc.org/mooc/4392" target="_blank" rel="noopener">陆俊林 - 计算机组成</a></li><li><a href="https://book.douban.com/subject/26604008/" target="_blank" rel="noopener">戴维 A.帕特森 (David A.Patterson) / 约翰 L.亨尼斯 (John L.Hennessy) - 计算机组成与设计：硬件/软件接口（原书第5版）</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一章我们计算机中的指令系统，重点介绍了传送指令、流程控制和过程调用，了解了在高级语言如何转化为汇编语言来指导计算机工作。&lt;/p&gt;
&lt;p&gt;这一章会为大家介绍计算机中&lt;strong&gt;流水线指令系统设计&lt;/strong&gt;，介绍一下计算机如何&lt;strong&gt;「更快」&lt;/strong&gt;地执行，也会介绍如何去解决流水线处理器中的&lt;strong&gt;冒险&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="组成原理" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="组成原理" scheme="http://yoursite.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>3 指令系统</title>
    <link href="http://yoursite.com/2020/02/01/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2020/02/01/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-02-01T05:53:53.000Z</published>
    <updated>2020-02-04T06:17:56.775Z</updated>
    
    <content type="html"><![CDATA[<p>上一章我们介绍了计算机中信息的表示，重点介绍了浮点数和补码。</p><p>这一章会为大家介绍计算机中<strong>指令系统</strong>，重点介绍<strong>汇编语言</strong>。</p><a id="more"></a><h2 id="传送指令"><a href="#传送指令" class="headerlink" title="传送指令"></a>传送指令</h2><h3 id="通用数据传送指令"><a href="#通用数据传送指令" class="headerlink" title="通用数据传送指令"></a>通用数据传送指令</h3><p>对于 <code>movq</code> 指令来说，需要源操作数和目标操作数，源操作数可以是立即数、寄存器值或内存值的任意一种，但目标操作数只能是寄存器值或内存值。指令的具体格式可以这样写 <code>movq [Imm|Reg|Mem], [Reg|Mem]</code>，第一个是源操作数，第二个是目标操作数，例如：</p><ul><li><code>movq Imm, Reg</code> $\rightarrow$ <code>mov $0x5, %rax</code> $\rightarrow$ <code>temp = 0x5;</code></li><li><code>movq Imm, Mem</code> $\rightarrow$ <code>mov $0x5, (%rax)</code> $\rightarrow$ <code>*p = 0x5;</code></li><li><code>movq Reg, Reg</code> $\rightarrow$ <code>mov %rax, %rdx</code> $\rightarrow$ <code>temp2 = temp1;</code></li><li><code>movq Reg, Mem</code> $\rightarrow$ <code>mov %rax, (%rdx)</code> $\rightarrow$ <code>*p = temp;</code></li><li><code>movq Mem, Reg</code> $\rightarrow$ <code>mov (%rax), %rdx</code> $\rightarrow$ <code>temp = *p;</code></li></ul><h3 id="地址传送指令"><a href="#地址传送指令" class="headerlink" title="地址传送指令"></a>地址传送指令</h3><p>以 <code>leaq</code> 指令为例子。具体格式为 <code>leaq Src, Dst</code>，其中 <code>Src</code> 是地址的表达式，然后把计算的值存入 <code>Dst</code> 指定的寄存器。</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h3><p>CPU还有一组<strong>条件码</strong>寄存器，它们描述了最近的算术或逻辑操作的属性，来执行条件分支指令。最常用的条件码有：</p><ul><li>CF: 进位标志。用来检查无符号操作的溢出。</li><li>ZF: 零标志。</li><li>SF: 符号标志。最近的操作得到结果为负数。</li><li>OF: 溢出标志。对于有符号数的溢出。</li></ul><p>假设有表达式 <code>t=a+b​</code> ，有如下设置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">CF(<span class="keyword">unsigned</span>) t &lt; (<span class="keyword">unsigned</span>) a无符号溢出</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">ZF(t == <span class="number">0</span>)零</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">SF(t &lt; <span class="number">0</span>)负数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">OF(a &lt; <span class="number">0</span> == b &lt; <span class="number">0</span>) &amp;&amp; (t &lt; <span class="number">0</span> != a&lt; <span class="number">0</span>)有符号溢出</span></pre></td></tr></table></figure><p>假设<code>cmpq Src2(b), Src1(a)</code> ，等同于计算 <code>a-b</code>，然后利用 <code>a-b</code> 的结果来对应进行条件代码的设置：</p><ul><li>如果在最高位还需要进位（也就是溢出了），那么 CF 标识位就会被设置</li><li>a 和 b 相等时，也就是 <code>a-b</code> 等于零时，ZF 标识位会被设置</li><li>如果 a &lt; b，也就是 <code>(a-b)&lt;0</code> 时，那么 SF 标识位会被设置</li><li>如果溢出，那么 OF 标识位会被设置（溢出的情况是 <code>(a&gt;0 &amp;&amp; b &gt; 0 &amp;&amp; t &lt;0) || (a&lt;0 &amp;&amp; b&lt;0 &amp;&amp; t&gt;=0)</code>）</li></ul><h3 id="跳转指令编码"><a href="#跳转指令编码" class="headerlink" title="跳转指令编码"></a>跳转指令编码</h3><p>我们先来看一个比较原始的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">absdiff</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">long</span> result;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (x &gt; y)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        result = x-y;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        result = y-x;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> result;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>对应的汇编代码如下，这里 <code>%rdi</code> 中保存了参数 <code>x</code>，<code>%rsi</code> 中保存了参数 <code>y</code>，而 <code>%rax</code> 一般用来存储返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">absdiff:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    cmpq    %rsi, %rdi# x &gt; y?</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    jle     .L4# if ⩽ goto loop</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    movq    %rdi, %rax# result &#x3D; x</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    subq    %rsi, %rax# result &#x3D; x - y</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    ret</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">.L4:    # x &lt;&#x3D; y</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    movq    %rsi, %rax# result &#x3D; y</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    subq    %rdi, %rax# result &#x3D; y - x</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    ret</span></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>先来看看并不那么常用的 Do-While 语句以及对应使用 goto 语句进行跳转的版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Do While 的 C 语言代码</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fact_do</span><span class="params">(<span class="keyword">long</span> n)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">long</span> result = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">do</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        result *= n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        n = n - <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">while</span> (n &gt; <span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> result;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Goto 版本</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fact_do_goto</span><span class="params">(<span class="keyword">long</span> x)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">long</span> result = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">loop:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    result *= n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    n = n - <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">goto</span> loop;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> result;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这个函数计算阶乘，翻译成汇编如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">fact_do:    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    movl    $1, %eax    # result &#x3D; 0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">.L2:                    # loop:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    imulq   %rdi, %rax# result *&#x3D; n</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    subq    $1, %rdi    # n &#x3D; n - 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    cmpq    %1, %rdi  # n &gt; 1?</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    jg      .L2         # if &gt; goto loop</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    rep; ret</span></pre></td></tr></table></figure><p>其中 <code>%rdi</code> 中存储的是参数 <code>n</code>，<code>%rax</code> 存储的是返回值。换成更通用的形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// C Code</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Body</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (Test);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Goto Version</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">loop:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">Body</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Test)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> loop</span></pre></td></tr></table></figure><p>而对于 While 语句的转换，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// C While version</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (Test)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Body</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Goto Version</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> test;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">loop:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">Body</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">test:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Test)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> loop;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">done:</span></pre></td></tr></table></figure><p>而对于 For 循环语句的转换，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// For</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Init; Test; Update)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Body</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// While Version</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">Init;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (Test) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">Body</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">Update;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>我们在使用 if…else 这样的条件分支，或者 while/for 这样的循环方式，来实现程序运行流程时，回归到计算机可以识别的机器指令级别，其实都只是一个简单的地址跳转而已，也就是一个类似于 goto 的语句。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>所谓的栈，实际上一块内存区域，这个区域的数据进出满足先进后出的原则。越新入栈的数据，地址越低，所以栈顶的地址是最小的。寄存器 %rsp 是栈指针，用来记录栈顶的位置。寄存器 %rbp 是栈帧指针。具体实例如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span> <span class="params">( <span class="keyword">int</span> x, <span class="keyword">int</span> y )</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> x+y;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">caller</span> <span class="params">( )</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> t1 = <span class="number">125</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> t2 = <span class="number">80</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = add (t1, t2);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> sum;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>汇编如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">caller：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">pushl %rbp&#x2F;* 准备阶段 *&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">movl  %rsp, %rbp</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">subl $24, %rsp</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">movl $125, -12(%rbp)&#x2F;* 分配局部变量 *&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">movl $80, -8(%rbp)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">movl -8(%rbp), %rax&#x2F;* 准备入口参数 *&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">movl %rax, 4(%rsp)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">movl -12(%rbp), %rax</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">movl %rax, (%rsp)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">call add&#x2F;* 返回参数在 %rax 中*&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">movl %rax, -4(%rbp)&#x2F;* 准备返回参数 *&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">movl -4(%rbp), %rax</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">leave&#x2F;* 结束 *&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">ret</span></pre></td></tr></table></figure><img src="/2020/02/01/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/1.png" class="" title="过程调用栈示意图"> <h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章介绍了<strong>指令系统</strong>，介绍了传送、流程、过程这几种汇编语言指令，了解了高级语言到较为底层语言的过程。</p><p>下一章将为大家带来<strong>流水线处理器指令设计</strong>，介绍一下CPU是如何<strong>「同时」</strong>进行多项任务的。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://wdxtub.com/csapp/thin-csapp-1/2016/04/16/" target="_blank" rel="noopener">小土刀 - 【读薄 CSAPP】壹 数据表示</a></li><li><a href="https://book.douban.com/subject/26912767/" target="_blank" rel="noopener">Randal E.Bryant / David O’Hallaron - 深入理解计算机系统（原书第3版）</a></li><li><a href="https://www.icourse163.org/course/NJU-1001625001" target="_blank" rel="noopener">袁春风 - 计算机系统基础(一)：程序的表示、转换与链接</a></li><li><a href="https://time.geekbang.org/column/intro/100026001" target="_blank" rel="noopener">徐文浩 - 深入浅出计算机组成原理</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一章我们介绍了计算机中信息的表示，重点介绍了浮点数和补码。&lt;/p&gt;
&lt;p&gt;这一章会为大家介绍计算机中&lt;strong&gt;指令系统&lt;/strong&gt;，重点介绍&lt;strong&gt;汇编语言&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="组成原理" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="组成原理" scheme="http://yoursite.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>2 信息的表示与处理</title>
    <link href="http://yoursite.com/2020/01/31/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA/"/>
    <id>http://yoursite.com/2020/01/31/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA/</id>
    <published>2020-01-31T05:53:53.000Z</published>
    <updated>2020-02-04T06:17:50.703Z</updated>
    
    <content type="html"><![CDATA[<p>上一章我们介绍了计算机的基本硬件组成，让我们对计算机大致有一个了解。</p><p>这一章会为大家介绍计算机中信息的表示，有些也是之前学到的，比如二进制的计算。将重点介绍<strong>无符号</strong>（unsigned）、<strong>带符号</strong>、<strong>浮点数</strong>（floating-point）这三种编码方式。</p><p>当然溢出和浮点数特殊的编码方式也会产生与预期不一样的结果，我们也会介绍。</p><a id="more"></a><h2 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h2><p>一个<strong>字节</strong>（byte）由8位组成。二进制、十进制与十六进制之间的转化如下表：</p><div class="table-container"><table><thead><tr><th style="text-align:center">十六进制</th><th style="text-align:center">十进制</th><th style="text-align:center">二进制</th><th style="text-align:center">十六进制</th><th style="text-align:center">十进制</th><th style="text-align:center">二进制</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0000</td><td style="text-align:center">8</td><td style="text-align:center">8</td><td style="text-align:center">1000</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0001</td><td style="text-align:center">9</td><td style="text-align:center">9</td><td style="text-align:center">1001</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">0010</td><td style="text-align:center">A</td><td style="text-align:center">10</td><td style="text-align:center">1010</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">0011</td><td style="text-align:center">B</td><td style="text-align:center">11</td><td style="text-align:center">1011</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:center">0100</td><td style="text-align:center">C</td><td style="text-align:center">12</td><td style="text-align:center">1100</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">5</td><td style="text-align:center">0101</td><td style="text-align:center">D</td><td style="text-align:center">13</td><td style="text-align:center">1101</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:center">0110</td><td style="text-align:center">E</td><td style="text-align:center">14</td><td style="text-align:center">1110</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">7</td><td style="text-align:center">0111</td><td style="text-align:center">F</td><td style="text-align:center">15</td><td style="text-align:center">1111</td></tr></tbody></table></div><h2 id="字数据大小"><a href="#字数据大小" class="headerlink" title="字数据大小"></a>字数据大小</h2><p>C语言支持的基本数据类型分配的字节数如下表所示：</p><div class="table-container"><table><thead><tr><th style="text-align:center">C语言声明</th><th style="text-align:center">32位 / 字节</th><th style="text-align:center">64位 / 字节</th></tr></thead><tbody><tr><td style="text-align:center">(unsigned) char</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">(unsigned) short</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">(unsigned) int</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">(unsigned) long</td><td style="text-align:center">4</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">char *</td><td style="text-align:center">4</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">8</td><td style="text-align:center">8</td></tr></tbody></table></div><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>对于带符号数而言，其编码方式与无符号数不同，为补码编码（two’ s complement）。最高有效位为符号位，当符号位为1时，值为负；符号位为0时，值为正。正负数之间补码的关系有如下结论：<strong>一个负数的补码等于将对应正数补码各位取反、末位加一</strong>。</p><p>例如：<code>11010110</code>的真值为<code>-0101010 = -(32+8+2) = -42</code></p><h2 id="整数的表示"><a href="#整数的表示" class="headerlink" title="整数的表示"></a>整数的表示</h2><p>下面定义三个整数数据：$Tmin$ - 最小补码值，$TMax$ - 最大补码值，$UMax$ - 最大无符号数。</p><p>假设字长为 <code>w</code>，定义如下的常量：</p><ul><li>$UMin = 0$ 即 <code>000…0</code></li><li>$UMax =  2^w−1 $ 即 <code>111…1</code></li><li>$TMin = −2^w−1 $ 即 <code>100…0</code></li><li>$ TMax = 2^{w−1}−1 $ 即 <code>011…1</code></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">数</th><th style="text-align:center">8</th><th style="text-align:center">16</th><th style="text-align:center">32</th><th style="text-align:center">64</th></tr></thead><tbody><tr><td style="text-align:center">$UMax$</td><td style="text-align:center">255</td><td style="text-align:center">65535</td><td style="text-align:center">4294967295</td><td style="text-align:center">18446744073709551615</td></tr><tr><td style="text-align:center">$TMin$</td><td style="text-align:center">-128</td><td style="text-align:center">-32768</td><td style="text-align:center">-2147483648</td><td style="text-align:center">-9223372036854775808</td></tr><tr><td style="text-align:center">$TMax$</td><td style="text-align:center">127</td><td style="text-align:center">32767</td><td style="text-align:center">2147483647</td><td style="text-align:center">9223372036854775807</td></tr></tbody></table></div><p>其中          $ | Tmin | = |TMax| + 1 $          $ UMax = 2*TMax + 1 $</p><h2 id="位扩展和位截断运算"><a href="#位扩展和位截断运算" class="headerlink" title="位扩展和位截断运算"></a>位扩展和位截断运算</h2><ul><li><strong>扩展：短转长</strong><br>无符号数：0扩展（前面补0）<br>带符号整数：符号扩展（前面补符）</li><li><strong>截断：长转短</strong><br>强行将高位丢弃，故可能发生“溢出”</li></ul><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 扩展操作 */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> si = <span class="number">-32768</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> usi = si;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = si;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">unsingned ui = usi ;</span></pre></td></tr></table></figure><p>输出为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">si = <span class="number">-32768</span> <span class="number">80</span> <span class="number">00</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">usi = <span class="number">32768</span> <span class="number">80</span> <span class="number">00</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">i = <span class="number">-32768</span> FF FF <span class="number">80</span> <span class="number">00</span> <span class="comment">/* 带符号整数：符号扩展 */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">ui = <span class="number">32768</span> <span class="number">00</span> <span class="number">00</span> <span class="number">80</span> <span class="number">00</span> <span class="comment">/* 无符号整数：0扩展 */</span></span></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 截断操作 */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">32768</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> si = (<span class="keyword">short</span>) i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j = si;</span></pre></td></tr></table></figure><p>输出为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">i = <span class="number">32768</span> <span class="number">00</span> <span class="number">00</span> <span class="number">80</span> <span class="number">00</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">si = <span class="number">-32768</span> <span class="number">80</span> <span class="number">00</span> <span class="comment">/* 截断时发生了“溢出” */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">j = <span class="number">-32768</span> FF FF <span class="number">80</span> <span class="number">00</span></span></pre></td></tr></table></figure><h2 id="IEEE-浮点数标准"><a href="#IEEE-浮点数标准" class="headerlink" title="IEEE 浮点数标准"></a>IEEE 浮点数标准</h2><p>IEEE浮点标准用如下公式表示：</p><script type="math/tex; mode=display">V = (-1)^s*M*2^E</script><ul><li><strong>符号</strong>：$s$ 决定其正负号。</li><li><strong>尾数</strong>：$M$ 为二进制小数。对于<strong>规格化的值</strong>而言，$M=1.f_{n-1}…f_1f_0$；对于<strong>非规格化的值</strong>而言，$M=0.f_{n-1}…f_1f_0$。其中$f_{n-1}…f_1f_0$的部分就是 frac 的编码部分。</li><li><strong>阶码</strong>：$E$ 为指数位。对于<strong>规格化的值</strong>而言，$E=Exp−Bias$，对于<strong>非规格化的值</strong>而言，$E=1−Bias$。<ul><li>$Exp$: 是 exp 编码区域的无符号数值</li><li>$Bias$：值为$2^{k−1}−1$的偏移量，其中 $k$ 是 exp 编码的位数。</li></ul></li></ul><p>对于不同的格式，也有不同的编码结构，如下图所示：</p> <img src="/2020/01/31/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA/1.jpg" class="" title="标准浮点格式"> <h3 id="数字示例"><a href="#数字示例" class="headerlink" title="数字示例"></a>数字示例</h3><p>下面假定8位浮点数，其中有 $k=4$ 的阶码位和 $n=3$ 的小数位。偏移量为 $2^{4-1}-1=7$ 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">    s exp  frac   E   值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">------------------------------------------------------------------</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    0 0000 000   -6   0   # 这部分是非规范化数值，下一部分是规范化值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    0 0000 001   -6   1&#x2F;8 * 1&#x2F;64 &#x3D; 1&#x2F;512 # 能表示的最接近零的值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    0 0000 010   -6   2&#x2F;8 * 1&#x2F;64 &#x3D; 2&#x2F;512 </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    0 0000 110   -6   6&#x2F;8 * 1&#x2F;64 &#x3D; 6&#x2F;512</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    0 0000 111   -6   7&#x2F;8 * 1&#x2F;64 &#x3D; 7&#x2F;512 # 能表示的最大非规范化值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">------------------------------------------------------------------</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    0 0001 000   -6   8&#x2F;8 * 1&#x2F;64 &#x3D; 8&#x2F;512 # 能表示的最小规范化值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    0 0001 001   -6   9&#x2F;8 * 1&#x2F;64 &#x3D; 9&#x2F;512</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    0 0110 110   -1   14&#x2F;8 * 1&#x2F;2 &#x3D; 14&#x2F;16</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    0 0110 111   -1   15&#x2F;8 * 1&#x2F;2 &#x3D; 15&#x2F;16 # 最接近且小于 1 的值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    0 0111 000    0   8&#x2F;8 * 1 &#x3D; 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    0 0111 001    0   9&#x2F;8 * 1 &#x3D; 9&#x2F;8      # 最接近且大于 1 的值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    0 0111 010    0   10&#x2F;8 * 1 &#x3D; 10&#x2F;8</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    0 1110 110    7   14&#x2F;8 * 128 &#x3D; 224</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    0 1110 111    7   15&#x2F;8 * 128 &#x3D; 240   # 能表示的最大规范化值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">------------------------------------------------------------------</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    0 1111 000   n&#x2F;a  无穷               # 特殊值</span></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章介绍了不同编码方式表示不同的数据，重点介绍了<strong>补码</strong>、<strong>浮点数</strong>。</p><p>下一章将为大家带来指引计算机工作的<strong>指令系统</strong>，介绍一下<strong>指令系统</strong>的基本概念，涉及少部分<strong>汇编语言</strong>。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://wdxtub.com/csapp/thin-csapp-1/2016/04/16/" target="_blank" rel="noopener">小土刀 - 【读薄 CSAPP】壹 数据表示</a></li><li><a href="https://book.douban.com/subject/26912767/" target="_blank" rel="noopener">Randal E.Bryant / David O’Hallaron - 深入理解计算机系统（原书第3版）</a></li><li><a href="https://time.geekbang.org/column/intro/100026001" target="_blank" rel="noopener">徐文浩 - 深入浅出计算机组成原理</a></li><li><a href="https://www.icourse163.org/course/NJU-1001625001" target="_blank" rel="noopener">袁春风 - 计算机系统基础(一)：程序的表示、转换与链接</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一章我们介绍了计算机的基本硬件组成，让我们对计算机大致有一个了解。&lt;/p&gt;
&lt;p&gt;这一章会为大家介绍计算机中信息的表示，有些也是之前学到的，比如二进制的计算。将重点介绍&lt;strong&gt;无符号&lt;/strong&gt;（unsigned）、&lt;strong&gt;带符号&lt;/strong&gt;、&lt;strong&gt;浮点数&lt;/strong&gt;（floating-point）这三种编码方式。&lt;/p&gt;
&lt;p&gt;当然溢出和浮点数特殊的编码方式也会产生与预期不一样的结果，我们也会介绍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="组成原理" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="组成原理" scheme="http://yoursite.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>1 计算机基本结构</title>
    <link href="http://yoursite.com/2020/01/30/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2020/01/30/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</id>
    <published>2020-01-30T05:53:53.000Z</published>
    <updated>2020-01-31T08:38:01.426Z</updated>
    
    <content type="html"><![CDATA[<p>本章将介绍计算机的基本硬件，以让大家对计算机大致框架有所了解，这些硬件都要完成以下功能：输入数据、输出数据、处理数据和存储数据。</p><a id="more"></a><h2 id="计算机的基本硬件组成"><a href="#计算机的基本硬件组成" class="headerlink" title="计算机的基本硬件组成"></a>计算机的基本硬件组成</h2><ol><li><strong>中央处理器CPU</strong>（Central Processing Unit）：是计算机中最核心的部分。用于执行指令。</li><li><strong>内存</strong>（Memory）：程序读取的数据、计算得到的结果都会存放在内存中，计算机程序也要加载到内存中才可以运行。</li><li><strong>主板</strong>（Motherboard）：将CPU和内存插在主板上，主板中的<strong>芯片组</strong>（Chipset）和<strong>总线</strong>（Bus）解决CPU与内存之间的通信问题。</li><li><strong>I/O设备</strong>：输入/输出设备。</li></ol><h2 id="冯·诺依曼体系结构"><a href="#冯·诺依曼体系结构" class="headerlink" title="冯·诺依曼体系结构"></a>冯·诺依曼体系结构</h2><p>1945年，冯·诺伊曼基于当时在秘密开发的<strong>EDVAC</strong>（Electronic Discrete Variable Automatic Computer），以<a href="https://ieeexplore.ieee.org/document/238389" target="_blank" rel="noopener">「First Draft of a Report on the EDVAC」</a>为题，起草了长达101页的总结报告，发表了全新的「存储程序通用电子计算机方案」。</p><h3 id="冯·诺依曼体系结构的主要思想"><a href="#冯·诺依曼体系结构的主要思想" class="headerlink" title="冯·诺依曼体系结构的主要思想"></a>冯·诺依曼体系结构的主要思想</h3><ol><li><p>计算机应由运算器、控制器、存储器、输入设备和输出设备五个基本部件组成。</p></li><li><p>各基本部件的功能是：</p><ul><li><p><strong>控制器单元</strong>（Control Unit/CU）：控制程序的流程，通常是不同条件下的分支与跳转。可自动地从存储器中取出指令加以执行；</p></li><li><p><strong>处理器单元</strong>（Processing Unit）：包含算术逻辑单元（Arithmetic Logic Unit， ALU）和处理器寄存器（Processor Register）可进行加/减/乘/除四种基本算术运算，并且也能进行一些逻辑运算和附加运算；</p></li><li><p><strong>存储器</strong>：不仅能存放数据（Data），而且也能存放指令（Instruction），形式上两者没有区别，但计算机应能区分数据还是指令；</p></li><li><p>操作人员可以通过<strong>输入/输出设备</strong>和主机进行通信。</p></li></ul></li><li><p>内部以<strong>二进制表示</strong>指令和数据。每条指令由操作码和地址码两部分组成。操作码指出操作类型，地址码指出操作数的地址。由一串指令组成程序。</p></li><li><p>采用<strong>存储程序</strong>工作方式。 </p><img src="/2020/01/30/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/1.jpeg" class="" title="冯·诺依曼体系结构示意图"> </li></ol><h2 id="计算机执行指令的过程"><a href="#计算机执行指令的过程" class="headerlink" title="计算机执行指令的过程"></a>计算机执行指令的过程</h2><ol><li><strong>取指</strong>（Fetch）<ul><li>控制器将指令的地址送往存储器；</li><li>存储器按给定的地址读出指令内容，送回控制器。</li></ul></li><li><strong>译码</strong>（Decode）<ul><li>控制器分析指令的操作性质；</li><li>控制器向有关部件发出指令所需的控制信号。</li></ul></li><li><strong>执行</strong>（Execute）<ul><li>控制器从通用寄存器或存储器取出操作数；</li><li>控制器命令运算器对操作数进行指令规定的运算。</li></ul></li><li><strong>回写</strong>（Write-back）<ul><li>将运算结果写入通用寄存器或存储器</li></ul></li></ol><img src="/2020/01/30/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/2.png" class="" title="计算机结构的简化模型"> <h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章内容相对简单，介绍了计算机的基本硬件组成、冯·诺依曼体系结构、每个基本硬件的主要功能以及计算机执行指令的过程，让大家对计算机基本组成以及功能有所了解。</p><p>下一章将为大家带来指引计算机中<strong>信息的表示与处理</strong>，来看看计算机是如何用0和1来记录信息的。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="http://www.chinesemooc.org/mooc/4392" target="_blank" rel="noopener">陆俊林 - 计算机组成</a></li><li><a href="https://time.geekbang.org/column/intro/100026001" target="_blank" rel="noopener">徐文浩 - 深入浅出计算机组成原理</a></li><li><a href="https://www.icourse163.org/course/NJU-1001625001" target="_blank" rel="noopener">袁春风 - 计算机系统基础(一)：程序的表示、转换与链接</a></li><li><a href="https://ieeexplore.ieee.org/document/238389" target="_blank" rel="noopener">J. von Neumann - First Draft of a Report on the EDVAC</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章将介绍计算机的基本硬件，以让大家对计算机大致框架有所了解，这些硬件都要完成以下功能：输入数据、输出数据、处理数据和存储数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="组成原理" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="组成原理" scheme="http://yoursite.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>我的2019年个人总结</title>
    <link href="http://yoursite.com/2020/01/01/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/%E6%88%91%E7%9A%842019%E5%B9%B4%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/01/01/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/%E6%88%91%E7%9A%842019%E5%B9%B4%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</id>
    <published>2020-01-01T03:36:39.000Z</published>
    <updated>2020-01-03T06:52:18.185Z</updated>
    
    <content type="html"><![CDATA[<p>大家好呀。在此记录一下我的2019年个人总结。</p><a id="more"></a><h2 id="个人管理"><a href="#个人管理" class="headerlink" title="个人管理"></a>个人管理</h2><p>个人管理分为身体管理、精力管理以及财务管理。</p><p>今年年初为自己添置了两份保险，以应对生活中的风险，也算是对家人和自己负责。由于学习工作的缘故，运动时间相对减少（说白了就是懒），这点不足预期。后来在平时通勤的时候尽量选择爬楼梯来增加运动量。同时对自己的饮食习惯进行调整，少盐多果蔬，一年下来也没生什么病。</p><p>年中的时候读了很多管理精力的内容，慢慢调整自己的习惯。利用日程本和计划表来规划每天的日程。期间也会放任自己的「惰性」，发展新的爱好，结识了新朋友，以此放松，恢复精力。</p><p>财务方面个人还是比较满意的，当然入门的时候也交了不少学费，但是现在也做到了每天记账，每月预算，定期投资，也达到了还算不错的收益。</p><h2 id="个人提升"><a href="#个人提升" class="headerlink" title="个人提升"></a>个人提升</h2><p>研一初决定开启「劝退大业」，但正式实施还是在今年，研一下学期选了一门计算机基础课，也取得了还算不错的分数，算是给自己一点信心吧。研二开始系统学习计算机基础知识，到目前为止基本完成了算法、组成原理、操作系统的学习，同时也点了爬虫和网页等技能树。以此搭建了自己了博客，通过Typora + CSS改进了微信排版。</p><p>这一年读了不少非虚构类书籍，并学习了很多网课，这点我是比较满意的，除了专业书籍外，也读了理财管理的书籍，并进行了输出。</p><p>今年也看了不少电影，很多自己喜欢的大作。也渐渐感觉到审查制度愈发严苛，流媒体冲击传统电影行业。</p><h2 id="2020年的计划"><a href="#2020年的计划" class="headerlink" title="2020年的计划"></a>2020年的计划</h2><h3 id="1-坚持生活"><a href="#1-坚持生活" class="headerlink" title="1. 坚持生活"></a>1. 坚持生活</h3><p>做好情绪管理，坚持运动，保持身心健康。</p><h3 id="2-职业发展"><a href="#2-职业发展" class="headerlink" title="2. 职业发展"></a>2. 职业发展</h3><p>距离毕业不到一年，年初寻找机会，为职业发展做好准备。</p><h3 id="3-内容输出"><a href="#3-内容输出" class="headerlink" title="3. 内容输出"></a>3. 内容输出</h3><p>未来一年会继续学习理财投资与专业知识，定期输出优质内容。</p><h3 id="4-内心平静"><a href="#4-内心平静" class="headerlink" title="4. 内心平静"></a>4. 内心平静</h3><p>与家人朋友坦诚沟通。</p><hr><p>「南方周末」的一篇新年祝辞我很喜欢，在此送给看到这里的朋友：</p><blockquote><p>总有一种力量它让我们泪流满面，总有一种力量它让我们抖擞精神，总有一种力量它驱使我们不断寻求「正义、爱心、良知」。这种力量来自于你，来自于你们中间的每一个人。所以，在这样的时候，在新年的第一天，我们要想向你、向你身边的每一个人，说一声，新年好！祝愿阳光打在你的脸上。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家好呀。在此记录一下我的2019年个人总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="我的年度个人总结" scheme="http://yoursite.com/categories/%E6%88%91%E7%9A%84%E5%B9%B4%E5%BA%A6%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="个人总结" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>我的2018年个人总结</title>
    <link href="http://yoursite.com/2018/12/31/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/2018%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/12/31/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/2018%E6%80%BB%E7%BB%93/</id>
    <published>2018-12-31T13:46:12.000Z</published>
    <updated>2019-12-09T06:58:57.804Z</updated>
    
    <content type="html"><![CDATA[<p>在此向朋友们分享一下我的2018年。</p><a id="more"></a><p>上半年处于低谷期。我是个理想主义者，曾坚信一点：这个世界是美好的，每个人都有基本的道德底线。纵使社会有许多不公，我们依然有法律作为最后的武器。但是上半年各种事件的冲击，使我对此产生了怀疑。</p><p>于是产生了许多负面情绪，那个时候唯一坚持的事就是胶片摄影。镜头也开始对准了一些生活小事，每一次按下快门都会给我带来无限期待，胶片记录下来的影像，也带给了我前所未有的喜悦。</p><p>毕业之后，开始为家中老人拍摄一部纪录片，记录他们七十余年的人生经历。这是我第一次拍摄较大题材的视频，前期做了不少准备，自己的摄影后期水平也得到了进一步的提升。在镜头前，老人们表现出了从未有过的状态，我也开始真正理解「家人」这一词的含义。</p><p>自己做的一切可能真的很难改变现状，但是不经意间的一个善举就会给身边的人带来莫大的温暖。而这，也许是在这个世界中我们依旧呼吸与共的理由吧。</p><p>下半年的生活并没有想象中那么符合预期，年初的时候我也调侃过这只不过是给自己的软弱找了3年的缓冲期，想不到一语成谶。我现在唯一能做的就是让自己有更多自由选择的机会。</p><p>今年年底我经历了前所未有的情绪失控。我自诩极度理性，不会轻易由情感左右，很多朋友也这样认为。但我也只是不会「轻易」由情感左右，就像在自己心中下起了雨，慢慢积蓄，最后决堤，冲垮了自己的心理防线。不过现在精神状态好了些，勉强冷静地去处理这件事了。</p><p>在这期间特别感谢几位朋友和长辈的开导与关心。这段期间我也理解「陪伴」的重要性，真正的陪伴并不是生活上细枝末节的关照与物质上的付出，而是发自内心的理解与支持。这种情感是出于双方之间的信任与尊重，并非通过不停的地位互换所带来的管控与满足。否则这种关系是畸形的，是被绑架的，是孤独而又疲惫的。而这却又是约定俗成的，是符合社会要求的，是被外界认为是幸福的。</p><p>个人提升方面依旧是技能树乱点：暑假开始学习做饭，目前勉强能够做到解决温饱；初步了解了经济学相关的知识，开启了通往「财富自由」的道路；在专业的要求下重拾编程，依旧从入门到入土。</p><p>我自己也添置了不少个人用品：「飞利浦HX6730电动牙刷」治愈了困扰多年的口腔溃疡；「iPad Pro」使小屏观影的时代成为历史；「VALIO无乳糖脱脂奶粉」对乳糖不耐受人群极为友好。</p><hr><p>2019年的计划：</p><p><strong>1.依旧不满足于现状</strong></p><p>趁着年轻，出去看看，做改变自己的事。</p><p><strong>2.身体健康</strong></p><p>这一年做的不是很好，新的一年要保持运动。</p><p><strong>3.坚持记录</strong></p><p>影像与文字是时间最忠实的朋友。</p><p><strong>4.陪伴</strong></p><p>这个世界上最美好的词。</p><hr><p>感谢家人与朋友们的陪伴，感谢你们一直都在。</p><p>新年快乐。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在此向朋友们分享一下我的2018年。&lt;/p&gt;
    
    </summary>
    
    
      <category term="我的年度个人总结" scheme="http://yoursite.com/categories/%E6%88%91%E7%9A%84%E5%B9%B4%E5%BA%A6%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="个人总结" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>「重庆森林」简评</title>
    <link href="http://yoursite.com/2018/12/03/%E7%AE%80%E8%AF%84/%E3%80%8C%E9%87%8D%E5%BA%86%E6%A3%AE%E6%9E%97%E3%80%8D%E7%AE%80%E8%AF%84/"/>
    <id>http://yoursite.com/2018/12/03/%E7%AE%80%E8%AF%84/%E3%80%8C%E9%87%8D%E5%BA%86%E6%A3%AE%E6%9E%97%E3%80%8D%E7%AE%80%E8%AF%84/</id>
    <published>2018-12-03T13:46:12.000Z</published>
    <updated>2019-12-09T06:14:25.915Z</updated>
    
    <content type="html"><![CDATA[<p>许久不见，这次聊聊王家卫导演的「重庆森林」后半部分王菲与梁朝伟之间的故事。</p><a id="more"></a><p>王家卫导演的电影中爱情总是一条主线，他电影中的主角总会做一些「不合乎逻辑」的事，这也是我之前不那么中意王家卫导演的原因。在我的电影观里，逻辑才是评判一部电影的标准。</p><p>后来才发现，现实的许多事情是从不合逻辑的。许多看似突然发生的事情过程却异常平静，带给人无穷回味；许多看似平静的事情其下却暗流涌动，积累着情绪准备迸发。而这恐怕也是生活迷人的地方。</p><p>影片中梁朝伟看似有些木讷，后知后觉。但也许他是个很难放下过去的人，喝了许久的咖啡也不愿换一个口味。很多时候无声的安静却显得十分吵闹，因为你很难把情绪排除在外，它们就伴随你左右。就像王菲总把音乐开得很大，试图盖过这无声的喧嚣。</p><p>而影片中另一个意象「房子」正好反映了梁朝伟的内心世界，伤心之人可能在外表上与常人无异，生活仿佛并没有受到什么影响。而他的内心早已下起了雨，在积水淹没自己的时候，才会在那一刻感到窒息般的痛苦。</p><p>王菲则体察到了梁朝伟的内心，这时她充当了一个合格的暗恋者，不声不响地帮梁朝伟打理内心的房间，带他走出阴霾。</p><p>我最喜欢王菲这个角色，她或许是许多对爱情保持克制的缩影。她生性自由，不想心事却有自己的心事；她渴望爱情，不停制造「巧合」来引起对方注意；她害怕爱情，对渴望已久的表白却表现得有些不知所措。</p><p>而「加州」则成了她的精神避难所，或许专注于某一件事情，是排解情绪唯一的办法，即使是不那么有效的办法。</p><p>还好这次王家卫给予了观众希望，让他二人在阔别一年之后重逢。</p><p>于1994年上映的「重庆森林」是王家卫导演在拍摄完「东邪西毒」遇到创作瓶颈，却只花了两个月时间拍摄出来的影片。影片分为上下两个部分，相互独立。它讲述了都市男女之间的情愫，有许多我们可能永远都无法察觉的情感羁绊。</p><p>这也是王家卫之所以为王家卫的原因，将生活中的种种小事拍摄出来，将种种细节埋在画面里，呈现给观众。初次观影时可能会觉得费解又矫情，当自己的阅历逐渐丰满时，才会在这其中或多或少看到自己的影子。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;许久不见，这次聊聊王家卫导演的「重庆森林」后半部分王菲与梁朝伟之间的故事。&lt;/p&gt;
    
    </summary>
    
    
      <category term="简评" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/"/>
    
      <category term="2018" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/2018/"/>
    
    
      <category term="剧情" scheme="http://yoursite.com/tags/%E5%89%A7%E6%83%85/"/>
    
      <category term="简评" scheme="http://yoursite.com/tags/%E7%AE%80%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>「狐步舞」简评</title>
    <link href="http://yoursite.com/2018/07/03/%E7%AE%80%E8%AF%84/%E7%8B%90%E6%AD%A5%E8%88%9E%E7%AE%80%E8%AF%84/"/>
    <id>http://yoursite.com/2018/07/03/%E7%AE%80%E8%AF%84/%E7%8B%90%E6%AD%A5%E8%88%9E%E7%AE%80%E8%AF%84/</id>
    <published>2018-07-03T13:46:12.000Z</published>
    <updated>2019-12-09T06:52:00.575Z</updated>
    
    <content type="html"><![CDATA[<p>有这样一种舞蹈，不论从哪里开始，永远都会回到同样的起点。</p><a id="more"></a><h2 id="第一幕"><a href="#第一幕" class="headerlink" title="第一幕"></a>第一幕</h2><p>在以色列，一个平静的中产家庭迎来几位军人的到访。母亲率先察觉到异样，昏厥倒地。父亲看着他们麻利地拿出注射器，给妻子来了一发镇定剂。接着他们宣布一个消息：在外服役的长子牺牲了。</p><p>父亲强忍悲痛接受了军方的专业「慰问」，并告知自己在精神病院的母亲，在商量儿子葬礼事宜时，却得知儿子并没有死，死的是与自己儿子同名的人。这时父亲慌了神，不惜动用特殊关系，要求儿子回家。</p><h2 id="第二幕"><a href="#第二幕" class="headerlink" title="第二幕"></a>第二幕</h2><p>在边境，不满20岁的儿子与其他三位战友驻扎在一个简陋的房中，他们百无聊赖，听着收音机，抱着M4步枪跳舞，为漫步的骆驼放行，用罐头的滚动速度来论证房子在不断倾斜。儿子则将父亲的床边故事改编成漫画，绘在笔记本上。</p><p>一天晚上，战友错将通行车辆上掉落的啤酒罐认作手雷，神经紧绷的儿子端起机枪杀了车内四名巴勒斯坦青年。</p><p>第二天，一辆推土机掩埋了报废的轿车，处理此事的军官对儿子说：你可以回家了。</p><h2 id="中场：最后的床边故事"><a href="#中场：最后的床边故事" class="headerlink" title="中场：最后的床边故事"></a>中场：最后的床边故事</h2><p>父亲儿时用传家宝希伯来圣经换取了色情杂志，自己的母亲也为此精神崩溃。后来父亲参军，期满退役，以优异成绩从大学毕业，娶妻生子，最后成为优秀的建筑师。在一切荣光背后，只有在无人的夜晚才会拭去眼泪。</p><h2 id="第三幕"><a href="#第三幕" class="headerlink" title="第三幕"></a>第三幕</h2><p>转眼便是儿子二十岁生日，只不过却只有夫妻二人在烛光前独饮。</p><p>想不到父亲极力避免的事情最后成为葬送儿子的原因。母亲控诉了父亲之后，与之吸起了大麻，在烟雾缭绕的烛火前调侃起儿子的葬礼。</p><p>在余晖中，夫妻跳起了狐步舞。</p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>在军车上，儿子画完了最后一幅画，那是一辆高举着轿车的推土机。这时，路面上出现了那只悠闲的骆驼，司机躲闪不及，车辆坠入崖中。</p><hr><p>这是一部战争片。有趣的是这部电影出奇地克制，不同于一般印象中战争电影的固有形象，片中没有对战争的强烈表现或对英雄的过分渲染。</p> <img src="/2018/07/03/%E7%AE%80%E8%AF%84/%E7%8B%90%E6%AD%A5%E8%88%9E%E7%AE%80%E8%AF%84/1.jpg" class=""> <p>驻守边疆的四名年轻士兵，任务就是筛查来往的一切车辆，消遣着每日时光。湛蓝的天空映衬着无垠的荒原，色彩艳丽的涂鸦点缀着独舞士兵的孤寂内心，没有丝毫战争的痕迹。</p><p>直到第一声枪响，观众的思绪才被拽回到现实。宁可错杀一千也不放过一个，即便对方是互有好感的年轻女郎，士兵也会抛下画笔端起机枪，屠尽眼前的一切。</p><p>片中还有另一个描写战争的细节，在军方慰问家属时，其「专业性」令人胆寒。在家国大义面前丧子之痛似乎显得微不足道，悲痛也就见怪不怪了。</p><hr><p>片中有三段狐步舞，分别是第一幕的养老院老人；第二幕的年轻士兵；第三幕的共舞夫妻，分别对应着各自的孤独，宿命的。</p><p>这部电影的主角是父亲。但没有太多对父亲过去的刻画，这也就为观众解读提供发挥空间。父亲像是一个摒弃世俗的利己主义者，会做出任何有利于自己的事情。父亲年轻时也是校园中的风云人物，似乎是这种众星捧月的虚荣会让他去拿传家宝来换取色情杂志。在战役胜利回程的路上，他才会让战友带队引路。</p><img src="/2018/07/03/%E7%AE%80%E8%AF%84/%E7%8B%90%E6%AD%A5%E8%88%9E%E7%AE%80%E8%AF%84/2.jpg" class=""><p>光鲜亮丽的外表，都是掩饰自己脆弱的秘密。</p><p>家人都深知自己的脆弱，他们陪着自己的伤口生活，让自己显得坚强。亲情是他最后的防线。这也是为什么在得知儿子「去世」的第一时间他会选择通知自己的母亲，也是为什么在得知儿子存活的第一时间选择让儿子回到自己身边，而这种对儿子的保护恰恰成为害死他的缘由。</p><p>影片的最后，妻子盯着儿子最后的那幅画说：你是那辆推土机，我是那辆轿车。</p><p>或许同这位父亲一样，极力想掩埋的秘密，最终会成为惩罚自己的恶果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有这样一种舞蹈，不论从哪里开始，永远都会回到同样的起点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="简评" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/"/>
    
      <category term="2018" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/2018/"/>
    
    
      <category term="剧情" scheme="http://yoursite.com/tags/%E5%89%A7%E6%83%85/"/>
    
      <category term="简评" scheme="http://yoursite.com/tags/%E7%AE%80%E8%AF%84/"/>
    
      <category term="战争" scheme="http://yoursite.com/tags/%E6%88%98%E4%BA%89/"/>
    
  </entry>
  
  <entry>
    <title>「血观音」简评</title>
    <link href="http://yoursite.com/2018/05/23/%E7%AE%80%E8%AF%84/%E3%80%8C%E8%A1%80%E8%A7%82%E9%9F%B3%E3%80%8D%E7%AE%80%E8%AF%84/"/>
    <id>http://yoursite.com/2018/05/23/%E7%AE%80%E8%AF%84/%E3%80%8C%E8%A1%80%E8%A7%82%E9%9F%B3%E3%80%8D%E7%AE%80%E8%AF%84/</id>
    <published>2018-05-23T13:46:12.000Z</published>
    <updated>2019-12-09T06:17:27.203Z</updated>
    
    <content type="html"><![CDATA[<p>最近观看了去年台湾金马奖的两大热门：「大佛普拉斯」与「血观音」。两者都是讲述台湾本土故事，如果说前者是道出底层人口的无可奈何，那么后者则是深刻剖析上层权贵的尔虞我诈。</p><a id="more"></a><p>「血观音」最吸引人的地方莫过于散落片中角落的细节拼图，通过对这些细节的拼凑，看清这些拼图的真相。暴力象征的<strong>血</strong>与慈眉善目的<strong>观音</strong>相结合，展现出权术更迭中无尽的修罗场，令人窒息的黑暗。</p><p>「血观音」最胆战心惊的地方是这部电影中没有一个人心存善念，甚至包括开局就领盒饭的林夫人。林夫人表面是个人畜无害的日本少妇，实则一直将马童Marco当作性奴。在问棠真话的时候，开始一直用日语与之交流，随后在问：「Marco为什么没有来帮你」时却用的是国语，为的是让棠真放下戒心，套出实情。</p><p>要说留有人性最后一丝温存的应该是棠宁。在她终于不愿再受母亲棠夫人摆布，执意赴死的时候，听到自己女儿棠真对自己的控诉：「你们不都是一样吗」。她则打开手铐，表达了自己对女儿最后的关切。</p><p>片中刻画最为深刻的角色当属棠真，演员文淇也获得了去年的金马奖最佳女配角。影片以她开头，并以她结尾。一句在外人看来平常无奇的「救救她」，则是她对自己外婆最后的复仇。影片也多次通过细节表现了她内心的变化，例如她多次用日语说「我很孤独」，并在脑海中无数次想象自己理直气壮说出Marco与林翩翩私情的情形，以及从病榻上滚下的「罪恶之果」。而她最后对爱情的追求也在Marco的冲撞下化作泡影。</p><p>以上也只是谈谈我对这部电影的看法，更多细节已经在豆瓣许多影评中阐释，这里不再赘述。</p><p>最后向大家推荐这部值得二刷的「血观音」。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近观看了去年台湾金马奖的两大热门：「大佛普拉斯」与「血观音」。两者都是讲述台湾本土故事，如果说前者是道出底层人口的无可奈何，那么后者则是深刻剖析上层权贵的尔虞我诈。&lt;/p&gt;
    
    </summary>
    
    
      <category term="简评" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/"/>
    
      <category term="2018" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/2018/"/>
    
    
      <category term="剧情" scheme="http://yoursite.com/tags/%E5%89%A7%E6%83%85/"/>
    
      <category term="简评" scheme="http://yoursite.com/tags/%E7%AE%80%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>我的2017年个人总结</title>
    <link href="http://yoursite.com/2017/12/31/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/2017%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/12/31/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/2017%E6%80%BB%E7%BB%93/</id>
    <published>2017-12-31T13:46:12.000Z</published>
    <updated>2019-12-09T06:57:26.410Z</updated>
    
    <content type="html"><![CDATA[<p>年终总结，既是对一年的回顾，又是对未来的展望。</p><a id="more"></a><p>先说一下完成的大事，年初本以为达不成这个目标，没想到最终顺利完成。过程也很曲折，柳暗花明，说好听点是学业上又步入了一个阶段，说难听点就是为自己的胆小怯弱又找到了三年的缓冲期。不过我很期待新的生活。</p><p>年初立志要司考，最终也不了了之，很是惭愧。但依旧收获满满，法律是人类行为的准则，但身边很少人具备基本的法律常识，以致于面对有争议的事件时，大多数人选择了站队，人云亦云。</p><p>暑假在北京呆了一个月，感受了现实北京的残酷。但实习的单位很好，每个人都给予了我足够多的帮助，也发生了不少值得思考的事情。</p><p>年中开始锻炼身体，现在身体得到明显改善，再接再厉。</p><p>我一直相信<strong>「教育是打破阶级固化的唯一途径」</strong>，即使生活再累再苦，步入中产意味着我的后辈实现了阶级上的飞跃。</p><p>但是面对大不公，我们也只能做围观群众，一面撸起袖子加油干，继续把自己累个半死；一面幸灾乐祸，庆幸厄运不是发生在自己头上，继续像蝼蚁一样活下去。</p><p>为众抱薪者，都已死绝。</p><p>这一年看了不少电影，参加了一次影展，去了四座城市，做了4个视频，写了7篇影评。摄影从入门到进阶，Python从入门到放弃，看到许多美好的事情，也发掘了不一样的世界。</p><hr><p>对2018年的一些计划：</p><p><strong>1. 锻炼身体，克服坏习惯</strong></p><p>继续健身，早点睡觉，少去怼人，用爱感化。</p><p><strong>2. 旅行，摄影，学习</strong></p><p>掌握新的技能，记录不一样的世界。</p><p><strong>3. 应对各种糟糕的事情</strong></p><p>糟糕的事情总是毫无征兆，未来应对这些事情时能够更加成熟。</p><p><strong>4. 发掘新事物</strong></p><p>普通的生活如此之难，自己也不希求有大起大落，保持乐观，面对未来，这就是生活的一切。</p><p>感谢所有帮助过我的人，感谢一切美好事物。</p><p>新年快乐。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;年终总结，既是对一年的回顾，又是对未来的展望。&lt;/p&gt;
    
    </summary>
    
    
      <category term="我的年度个人总结" scheme="http://yoursite.com/categories/%E6%88%91%E7%9A%84%E5%B9%B4%E5%BA%A6%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="个人总结" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>「喜丧」简评</title>
    <link href="http://yoursite.com/2017/12/27/%E7%AE%80%E8%AF%84/%E3%80%8C%E5%96%9C%E4%B8%A7%E3%80%8D%E7%AE%80%E8%AF%84/"/>
    <id>http://yoursite.com/2017/12/27/%E7%AE%80%E8%AF%84/%E3%80%8C%E5%96%9C%E4%B8%A7%E3%80%8D%E7%AE%80%E8%AF%84/</id>
    <published>2017-12-27T13:46:12.000Z</published>
    <updated>2019-12-09T06:16:10.151Z</updated>
    
    <content type="html"><![CDATA[<p>「喜丧」获得第10届FIRST青年电影展最佳影片和最佳导演，前几天观看了这部电影。</p><a id="more"></a><p>农村85岁老人含辛茹苦拉扯大六个孩子，到老来却难享天伦之乐，在突发脑血栓后，子女们纷纷想把老人送去敬老院。在子女轮流照看老人期间，发生了许多令人寒心的事情。</p><p>影片分为三个部分，场景分别发生在三个子女家庭中，这其中也有三个关键词。</p><h2 id="三儿子：外面的世界"><a href="#三儿子：外面的世界" class="headerlink" title="三儿子：外面的世界"></a>三儿子：外面的世界</h2><p>影片中有多处细节反映农村青年在外务工的现状，三儿子年轻的时候出来闯荡，生活条件是同辈人中相对较好的，但是在三孙女想去浙江时遭到了父母一致反对，反应最强烈的莫过是三儿媳。她蔑视婆婆，希望自己的女儿留在家中找个条件不错的女婿。</p><p>老人却是相当开明，鼓励三孙女出外闯荡。在三孙女去的车站里放的是黄渤的「我的要求不算高」，也反映了当代青年的心境。</p><h2 id="四女儿：笑病"><a href="#四女儿：笑病" class="headerlink" title="四女儿：笑病"></a>四女儿：笑病</h2><p>四女儿和四女婿开的是一家杂货铺，在二人怀疑老人偷了钱之后，老人精神受到刺激，得了笑病，以至于老人时不时就会突然笑起来。在四外孙外出务工去世后，全家人沉浸在悲痛的气氛中，老人却是突然大笑。</p><p>到后来老人的笑受到了子女的不解，并对其恶语相加，老人依然大笑，但老人内心却是异常痛苦，笑声却像是哭声。</p><h2 id="二儿子：菩萨"><a href="#二儿子：菩萨" class="headerlink" title="二儿子：菩萨"></a>二儿子：菩萨</h2><p>老人随身携带的物件是一尊瓷质菩萨，不管到哪里都要拜一拜，保佑子女平平安安。在遭到三儿媳的谩骂后，老人唯一一次为自己祷告。在遭到二儿媳驱赶住到牛棚里的时候，老人仍在拜菩萨，二儿子面对妻子的嫌弃和老母的怪笑，一怒之下砸碎了菩萨。自那以后老人就一直问敬老院的来信。</p><p>菩萨是老人的精神寄托，丈夫早亡，独自一人乞讨养活了六个孩子，晚年子女不孝，只能寄托于菩萨。在菩萨被砸碎后，老人对这个世界的唯一眷恋也随之破碎，在子女送她去敬老院的前一天，老人吞药自杀。</p><h2 id="喜丧"><a href="#喜丧" class="headerlink" title="喜丧"></a>喜丧</h2><p>老人并非寿寝而终，但子女却为其置办了喜丧，在舞台脱衣舞的表演中，子女的麻木不仁，台下老人的黑白遗照和舞台中央的「祭」字显得极为讽刺。影片的最后二儿媳也同样倒在地上，没有音乐，影片在沉寂中结束。</p><p><strong>我个人认为这是一部聚焦农村人口的电影，并非人性。这部电影英文名叫「Laughing to Die」，无时不刻讽刺着这个笑着死去的中国梦，将她最痛苦的那层伤疤撕开给人看。</strong></p><p>子女们并非都没有孝心，二儿子在老人去世前一晚对老人忏悔。在老人把传家宝送给二儿媳的时候，二儿媳假仁假义地寒暄了几句，便问「还有什么好东西吗？再给我点」。他们都是迫于生计，正如影片中一句台词「有钱走遍天下，没钱寸步难行」。<strong>儿女一多，也会计较个人付出的多少，孝顺的性质也就发生了变化。</strong></p><p>影片的镜头语言非常直白，也大胆启用非专业演员，二儿媳就像是个农村悍妇。真心呼吁大家可以多多关注这些小成本独立电影，不要用制作粗糙绑架他们，年轻导演可以关注到中国农村人口的残酷生活现状，难能可贵。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;「喜丧」获得第10届FIRST青年电影展最佳影片和最佳导演，前几天观看了这部电影。&lt;/p&gt;
    
    </summary>
    
    
      <category term="简评" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/"/>
    
      <category term="2017" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/2017/"/>
    
    
      <category term="剧情" scheme="http://yoursite.com/tags/%E5%89%A7%E6%83%85/"/>
    
      <category term="简评" scheme="http://yoursite.com/tags/%E7%AE%80%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>「芳华」简评</title>
    <link href="http://yoursite.com/2017/12/21/%E7%AE%80%E8%AF%84/%E3%80%8C%E8%8A%B3%E5%8D%8E%E3%80%8D%E7%AE%80%E8%AF%84/"/>
    <id>http://yoursite.com/2017/12/21/%E7%AE%80%E8%AF%84/%E3%80%8C%E8%8A%B3%E5%8D%8E%E3%80%8D%E7%AE%80%E8%AF%84/</id>
    <published>2017-12-21T13:46:12.000Z</published>
    <updated>2019-12-09T06:11:01.726Z</updated>
    
    <content type="html"><![CDATA[<p>简评主要关注其电影本身而非议论揣测。</p><a id="more"></a><p>前几天有幸在平遥国际电影展上观摩了这部电影。虽然在寒风中冻了四个小时，但是整体观影体验不错，最出彩的就是那饱受争议的6分钟长镜头，写实程度在国内战争片中极为罕见。 </p><p>本片重点描写70年代到90年代间中国发生的一系列重大事件中文工团这一群体的变迁，典型的大时代下的纪实人物电影。这其中就不免会涉及一些敏感话题，这也是本片的一大看点。</p><p>但是，冯小刚在这部电影中堆砌的东西实在太多，导致整部电影的主题模糊。文工团是摧残何小萍这类局外人的集权主义代表，而文工团则是那个时代的产物，我大胆猜想冯小刚真实的意思是批判那个时代。就连影片的结尾刘峰、肖穗子、郝淑雯三人重逢的场景中，肖郝二人还是认为当年刘峰确实猥亵的林丁丁，这也加重了刘峰人物的悲剧色彩。但是不知怎么，这种时代批判莫名其妙转化为青春赞歌，最后那个文工团告别仪式堪称影片中最大的败笔，伤害了何小萍和刘峰的集体居然要花大笔墨去写他们的引吭高歌，这也是我最不能理解的。并不是说林丁丁、郝淑雯等人没有资格缅怀青春，只是放在「芳华」整部电影背景下，她们的缅怀显得十分突兀。 </p><p>冯小刚想拍属于自己的史诗，影片中人物的服饰发型和广告牌都在体现着时代的变迁。但是，刻意渲染未免也有些造作，影片完全可以花些时间来讲何刘二人。类似像这种大时代下的人物纪实电影，最重要的一条就是单线叙事，主人公可以是事件的旁观者参与者甚至是缔造者，但是唯独不能有和主线同等地位的故事线存在。这也是为什么某些游戏大作有超越史诗电影的趋势。 </p><p>有些人可能对冯小刚比较反感，坊间也有关于他的流言蜚语。冯小刚近几年拍的这些电影都会涉及一些敏感话题，不断挑战当局的红线，也算是为下一代的电影创作营造一个更好的环境。反观第五代导演的其他几人，早年都有反响不菲的作品，而现在却也是音信杳无，只有冯小刚不甘向庸俗趣味妥协，坚持基本的道德良心，认真拍经得起时间流逝的电影，难能可贵。</p><p>期待未来有更多优秀的国产电影问世。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简评主要关注其电影本身而非议论揣测。&lt;/p&gt;
    
    </summary>
    
    
      <category term="简评" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/"/>
    
      <category term="2017" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/2017/"/>
    
    
      <category term="剧情" scheme="http://yoursite.com/tags/%E5%89%A7%E6%83%85/"/>
    
      <category term="简评" scheme="http://yoursite.com/tags/%E7%AE%80%E8%AF%84/"/>
    
      <category term="战争" scheme="http://yoursite.com/tags/%E6%88%98%E4%BA%89/"/>
    
  </entry>
  
  <entry>
    <title>「大护法」简评</title>
    <link href="http://yoursite.com/2017/07/17/%E7%AE%80%E8%AF%84/%E3%80%8C%E5%A4%A7%E6%8A%A4%E6%B3%95%E3%80%8D%E7%AE%80%E8%AF%84/"/>
    <id>http://yoursite.com/2017/07/17/%E7%AE%80%E8%AF%84/%E3%80%8C%E5%A4%A7%E6%8A%A4%E6%B3%95%E3%80%8D%E7%AE%80%E8%AF%84/</id>
    <published>2017-07-17T13:46:12.000Z</published>
    <updated>2019-12-09T06:09:27.243Z</updated>
    
    <content type="html"><![CDATA[<p>近期写简评极少，毕竟作为一个专业的段子手影评人，一定要对自己推荐的每一部电影负责。</p><a id="more"></a><p>昨天去看了「大护法」，相比于同期院线热门电影来说，这部电影的关注度真的少得可怜。偌大的影院只有我一个人，影片结束后工作人员直接赶我走，都不给一个看彩蛋的机会。同样地，与前几年国产电影保护月的国漫相比也是相形见绌，两年前的国产动漫里程碑「大圣归来」催生一批自来水军，一年前号称「十二年磨一剑」的「大鱼海棠」即使毁誉参半，但是不乏一些女粉的追捧。</p><p>而这部「大护法」没有自来水的宣传，也没有主创花絮的噱头，使我看这部电影的时候没有抱太大期望，但是观影效果却是出奇地好。这部电影号称PG-13（建议13岁以上的人群观看），但在我看来，血腥暴力程度不亚于一部R级电影。</p><p>「大护法」讲的是一名大护法寻找太子时误入与世隔绝的「花生镇」之后的奇闻异事。里面的居民「花生人」由上官吉安饲养，他们身上长出的「毒蘑菇」，就是成熟的标志，随后会被屠杀并肢解获得果实。</p><p>为了防止花生人的暴动，吉安大搞个人崇拜，称自己为吉安大神仙，说「毒蘑菇」是一种传染病，雇佣一批花生人作为自己的红卫兵，屠杀同类。并且剥夺他们说话的权力，毕竟猪猡是不会说话的。每一个花生人都会贴上假眼和假嘴，使自己更像「人」。他们都活在恐惧和仇恨中。</p><p>以上剧情是不是特别熟悉（自行脑补）。</p><p>在这个特殊的时代，这样一部含沙射影的电影以动漫的姿态上映，而且能够用一个半小时把自己想表达的东西说清楚，让电影的上映更加难能可贵。</p><p>当然这部电影也有缺陷，不知所云的台词（不排除导演故意装疯卖傻）和挖下但是没有填完的坑：大护法和保镖罗丹的背后故事、罗丹和爆乳姘头之间的关系（我的猜想是类似林仙儿和阿飞之间的关系）、小鸣和黄衣花生人的关系。</p><p>当然这些并不是我重点要说的东西。</p><p>我最喜欢的一个镜头是吉安的雇佣兵开口说话后，转身开枪将不会说话的同类打死。取得权力的花生人，会以为同类幸福生活的借口铲除异己。没有一个例外。</p><p>在此，推荐大家观看「大护法」。在这个「悟空传」和「绣春刀2」等烂片横行的国产保护月，这部电影存活的时间会很短，我希望有限的公映时间里，能够有更多的人欣赏它的价值。</p><p>最后引用马伯庸的一段话：</p><blockquote><p>尼尔·波兹曼在「娱乐至死」里说：「有两种方法可以让文化精神枯萎，一种是奥威尔式的——文化成为一个监狱；另一种是赫胥黎式的——文化成为一场滑稽戏。」有那么一阵子，大家觉得时代应该是滑向赫胥黎，奥威尔的预言只是个过于夸张的预言罢了。但没想到，有人从赫胥黎那硬把局面拽回奥威尔手里。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期写简评极少，毕竟作为一个专业的段子手影评人，一定要对自己推荐的每一部电影负责。&lt;/p&gt;
    
    </summary>
    
    
      <category term="简评" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/"/>
    
      <category term="2017" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/2017/"/>
    
    
      <category term="剧情" scheme="http://yoursite.com/tags/%E5%89%A7%E6%83%85/"/>
    
      <category term="简评" scheme="http://yoursite.com/tags/%E7%AE%80%E8%AF%84/"/>
    
      <category term="动画" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>「一念无明」简评</title>
    <link href="http://yoursite.com/2017/04/29/%E7%AE%80%E8%AF%84/%E3%80%8C%E4%B8%80%E5%BF%B5%E6%97%A0%E6%98%8E%E3%80%8D%E7%AE%80%E8%AF%84/"/>
    <id>http://yoursite.com/2017/04/29/%E7%AE%80%E8%AF%84/%E3%80%8C%E4%B8%80%E5%BF%B5%E6%97%A0%E6%98%8E%E3%80%8D%E7%AE%80%E8%AF%84/</id>
    <published>2017-04-29T13:46:12.000Z</published>
    <updated>2019-12-09T06:07:44.709Z</updated>
    
    <content type="html"><![CDATA[<p>好久没写简评了，一是因为最近没有值得推荐的电影，二是因为我太懒了。</p><a id="more"></a><p>最近抽出时间去看了这部默默无闻的电影——「一念无明」。其实这部电影并不是表面上这样默默无闻，它在刚刚过去的「第36届香港电影金像奖」 中获得八项提名，斩获了「最佳男配角」、「最佳女配角」和「新晋导演」这三个奖项。</p><p>电影讲述的是患有「躁郁症」的儿子和父亲之间的故事。</p><p>电影开头，曾志伟饰演的父亲接余文乐饰演的儿子出院，一年前，儿子因意外杀死了自己的母亲，成为轰动一时的弑母恶魔，他也被查出患有「躁郁症」，入院接受治疗。</p><p>随着剧情的发展和记忆的闪回，他的父亲开跨境货车常年在外奔波，他还有一个事业有成定居美国的弟弟，而自己的母亲却是生活完全不能自理，因对生活的绝望，就把心中的怨气全部发泄在自己的「扑街」儿子身上，时不时拳脚相加，而儿子也只是忍气吞声，逆来顺受。另一方面，未婚妻又一次提出要将母亲送到养老院的要求。</p><p>就这样，生活的重担和亲人的埋怨全部压在这个年轻人心头，使他变得暴躁焦虑。终于，结束一天繁重工作的他回到家中，母亲又一次情绪失控。他不说话，默默扶着母亲去洗澡，母亲反手一耳光，他终于爆发了……</p><p>出院后不久，他抗拒治疗，这让他又一次表现出「躁郁症」的症状：亢奋健谈，和邻居谈笑风生，一次次被拒绝，又一次次找工作面试。</p><p>然而好景不长，最好的朋友因为公司裁员，跳楼自杀。而自己的未婚妻也找到了他，带着他参加教堂礼拜，未婚妻在祷告中说出了自己对未婚夫的怨恨，使他情绪又一次失控。这一次，他奔到楼下的便利店，吃光了所有的巧克力[2]。</p><p>到底什么才能拯救这个无助的年轻人？是那个将苦难降临到众生头上的上帝？还是在睡觉的时候都要在枕下藏一把锤子提防自己的父亲？还是那些治病的药物和巧克力？</p><p>如果说电影的前半段导演通过儿子提出这个问题，那么后半段就是通过父亲来回答这个问题。</p><p>父亲这个角色在整部电影中戏份其实并不是很多，但是导演通过一些细节的变化展现了父亲的心路历程。</p><p>比如父亲所看书籍的变化：在儿子刚刚出院的时候，他看的是一些言情类型的小说，和一般香港的市侩没什么区别；在儿子找工作的时候，他看的是一本关于投资的书，儿子看到之后，笑着对他说：这种东西你直接问我好了；在儿子再次发病的时候，他看的是关于抑郁症的书。</p><p>在儿子发病后，他参加了由精神病患者家属组建的分享会，每一个人都要分享自己的故事。</p><p>在分享中，他说自己也不是没有想过将儿子送回精神病院，当一个「扑街」很容易，只需要一直逃避下去就可以了，但是这一次他不能再像从前那样逃避了，因为这是他的亲生儿子。</p><p>这部电影的英文名叫<em>Mad World</em>，导演不断用镜头为我们呈现这个疯狂的世界：高楼大厦林立的维多利亚港对面就是香港破砖瓦房的贫民窟；在别人婚礼大喜的日子，台下的人们都在议论些鸡毛蒜皮的事情，丝毫不顾及台上的新郎新娘；在儿子发病痛苦不已的时候，围观的群众没有一个上去救助，都在用手机拍照发推特，配文这就是从前那个杀人犯；那个从未露面的弟弟，在亲哥哥发病的时候，只对父亲说你把哥哥送回精神病院吧，我再把你送到养老院；在全体邻居都在驱赶这对父子的时候，只有隔壁邻居的小朋友，给余文乐讲安托万·德·圣·埃克苏佩里的「小王子」。</p><p>人类的悲欢并不相通，只有用心灵才能看得清事物的本质，真正重要的东西是肉眼无法看见的。</p><p>最后，挚向大家推荐余文乐主演的「一念无明」。在余文乐转型实力派演员的时候，反观同时期的港星：谢霆锋过气，陈冠希退圈，令人唏嘘。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没写简评了，一是因为最近没有值得推荐的电影，二是因为我太懒了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="简评" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/"/>
    
      <category term="2017" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/2017/"/>
    
    
      <category term="剧情" scheme="http://yoursite.com/tags/%E5%89%A7%E6%83%85/"/>
    
      <category term="简评" scheme="http://yoursite.com/tags/%E7%AE%80%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>「我不是潘金莲」简评</title>
    <link href="http://yoursite.com/2017/04/29/%E7%AE%80%E8%AF%84/%E3%80%8C%E6%88%91%E4%B8%8D%E6%98%AF%E6%BD%98%E9%87%91%E8%8E%B2%E3%80%8D%E7%AE%80%E8%AF%84/"/>
    <id>http://yoursite.com/2017/04/29/%E7%AE%80%E8%AF%84/%E3%80%8C%E6%88%91%E4%B8%8D%E6%98%AF%E6%BD%98%E9%87%91%E8%8E%B2%E3%80%8D%E7%AE%80%E8%AF%84/</id>
    <published>2017-04-29T13:46:12.000Z</published>
    <updated>2019-12-09T06:05:44.889Z</updated>
    
    <content type="html"><![CDATA[<p>「我不是潘金莲」的上映真的是一波三折，从一开始的中秋档到国庆档，最后到「史上最强十一月档」，无数人都在猜疑是不是因为审查的问题，而冯导也屡次强调并没有这么一说。</p><a id="more"></a><p>很多朋友觉得这部电影单纯讲当官不为民做主的贪官污吏，但是看过原著之后发现，里面几乎没有对贪污受贿的描写，只是一群整天想着为了自己的目的而妄自猜疑别人心思的人，包括李雪莲。（原著中她其实并不是作为一个正面人物存在）</p><p>电影也几乎还原了这一点，然而然而原著中有大量心理活动描写，这个在电影中很难表现（李安的120帧就是为了展现演员心理活动准备的），冯导的处理方式就是淡化，直接就是各种下酒店踢皮球尾大不掉，完全给人一种贪官污吏的感觉。照这么说的话，电影甚至比原著更加话题话题敏感，能上映完全是一个奇迹。</p><p>再有一处小改动就是结尾李雪莲的二胎，原著是李雪莲生下了这个孩子，在电影里面则是流产，这个改动我非常喜欢，一是符合现实，国家从前计划生育，现在推行「二孩政策」；二是给李雪莲的告状整了一个缘由，原著则是李雪莲每次告状之前都会去问牛，直到第十年牛死了，她就放弃了。</p><p>至于演员，大家都说范冰冰挑战自己。要我说，范冰冰还是那个样，演技没有任何的提升。有一个小细节，原著中李雪莲人到中年的时候已经是腰粗膀宽，但是在电影中，她和大头翻云覆雨之后，给观众一个性感的裸背，不知道有多少男观众看着就硬了，。2012年差不多也是在11月，李安「少年派的奇幻漂流」和冯导的「1942」就撞上了，少年派在海上漂泊那么长时间，瘦得只剩皮包骨头，老东家在饥荒中还是那么发福。之后就传出了一个梗：冯小刚和李安之间只差100个陆川（陆川的「王的盛宴」也在那个时候上映）。</p><p>冯导可能知道范冰冰要跪，就在一次访谈中说：真正的主角不是范冰冰，而是28个男人 [1] 。不得不说这几位老戏骨演的真是入木三分，张口闭口「精神改造」「机制建设」，给我们展现了一个个只能在央视上才能看到的领导们。（现实生活中也不乏这种人，即使他什么都不是）</p><p>最后，诚挚向大家推荐冯小刚导演的新片「我不是潘金莲」，因为我敢保证，在这之后的很长时间里，你都不会看到一部电影敢如此明目张胆地嘲讽这个社会。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;「我不是潘金莲」的上映真的是一波三折，从一开始的中秋档到国庆档，最后到「史上最强十一月档」，无数人都在猜疑是不是因为审查的问题，而冯导也屡次强调并没有这么一说。&lt;/p&gt;
    
    </summary>
    
    
      <category term="简评" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/"/>
    
      <category term="2017" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/2017/"/>
    
    
      <category term="剧情" scheme="http://yoursite.com/tags/%E5%89%A7%E6%83%85/"/>
    
      <category term="简评" scheme="http://yoursite.com/tags/%E7%AE%80%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>我的2016年个人总结</title>
    <link href="http://yoursite.com/2016/12/31/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/2016%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/12/31/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/2016%E6%80%BB%E7%BB%93/</id>
    <published>2016-12-31T13:46:12.000Z</published>
    <updated>2019-12-09T06:57:43.544Z</updated>
    
    <content type="html"><![CDATA[<p>以前从未写过任何年终总结，一是觉得写这个略显侨情，二是对自己记忆力比较自负，一年里的事都可以记下来，没有必要另作总结。</p><a id="more"></a><p>但是，我自己都没有想到这一年会经历这么多分分合合。所以，我想记录下一些事情，与大家分享。</p><p>年初的时候心血来潮，和几位朋友创立了一个社团，一开始走的也是比较艰难，但比预想的要顺利，有朋友的离开，但是也有更多的朋友加入，我们也是热情似火，一副热闹景象。</p><p>后来也是和一些人产生分歧，各种闹剧，各种不堪，中间没有贵人相助，反而有小人从中作梗。我和几位朋友之间也产生了猜疑，最后也是被泼了一身污水，众叛亲离。</p><p>最后，这个社团也是不了了之，倒是有几位朋友还是心有念想，时不时和我聊起这些事。这其中孰是孰非我已不想深究，和朋友聊起来也是一笑而过。</p><p>高兴的是，上半年过的如此艰难，倒是也帮助了不少朋友，有朋友也是脱了单。这是个种子，被帮助的人也会去帮助更多的人。</p><p>欣慰的是，虽然自己弄得声名涂地，也还是得到了朋友的支持，得到了更多人的认可。</p><p>八月中旬得到一个噩耗，自己从前学生会主席去世了。事情很意外，朋友们都一时间无法接受这个事实。学长梦想去美国读研，去世前刚从贵州支教回来。而我正好在八月初去学长的故乡旅游，当时心想反正开学也可以见到，就也没有和学长打招呼，没有想到这一别就是阴阳两隔。</p><p>后来国庆和朋友一起去看望学长，具体细节我不便阐述，也见到了学长的家人，也算了却自己的遗憾。</p><p>年末的时候得知一个消息，一位朋友和相恋四年的女友分手了，具体细节我也不便打听。他和他女友高二相恋，从高中毕业再到大学异地，从未有过如胶似漆，一直都是相濡以沫，在我们眼中也算是童子佳人。以前和朋友们调侃他们二人结婚生子的事情，现在一切也算是愿景。</p><p>这之后不久，我堂姐结婚了，姐夫是一个好人，婚礼办得相当隆重，祝他们幸福。</p><p>虽然2016年过得也是分分合合，不过想想，2016年还是有爱的一年。</p><p>这一年我居然记录了二百多条有意思的文章和摘录，写了四篇独立影评，坐飞机去了三个不同的地方，在「守望先锋」里认识了一些朋友，这算不算收获满满？</p><p>2017年，我有一些事要做：</p><ol><li><p>完善自己，好好生活。</p></li><li><p>学习，阅读，写作。</p></li><li><p>应对各种糟糕的事情。</p></li><li><p>旅行。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前从未写过任何年终总结，一是觉得写这个略显侨情，二是对自己记忆力比较自负，一年里的事都可以记下来，没有必要另作总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="我的年度个人总结" scheme="http://yoursite.com/categories/%E6%88%91%E7%9A%84%E5%B9%B4%E5%BA%A6%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="个人总结" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>「比利林恩的中场战事」简评</title>
    <link href="http://yoursite.com/2016/12/31/%E7%AE%80%E8%AF%84/%E3%80%8C%E6%AF%94%E5%88%A9%E6%9E%97%E6%81%A9%E7%9A%84%E4%B8%AD%E5%9C%BA%E6%88%98%E4%BA%8B%E3%80%8D%E7%AE%80%E8%AF%84/"/>
    <id>http://yoursite.com/2016/12/31/%E7%AE%80%E8%AF%84/%E3%80%8C%E6%AF%94%E5%88%A9%E6%9E%97%E6%81%A9%E7%9A%84%E4%B8%AD%E5%9C%BA%E6%88%98%E4%BA%8B%E3%80%8D%E7%AE%80%E8%AF%84/</id>
    <published>2016-12-31T13:46:12.000Z</published>
    <updated>2019-12-09T06:06:14.651Z</updated>
    
    <content type="html"><![CDATA[<p>之前听说北美口碑扑街了，所以看之前也没有抱太大期望。然而观影结果却出人意料地好，就单从饱受争议的剧情方面来说，这也不乏是一部大作。</p><a id="more"></a><p>故事采用闪回方式，这种方式在现在的电影中屡见不鲜，就连制作简单的美剧也采用过，所以这个没有什么好谈的。</p><p>每一个人物性格的刻画是本片的一大亮点，除主演之外，有些人物出场仅几分钟，却个个性格迥异，留下了很深的印象。</p><p>以前许多反映伊拉克战争的电影作品，如「美国狙击手」「拆弹部队」，但是这些作品拍的都像纪录片一样，大部分平铺直叙，中间穿插高潮，但是真正像「比利林恩的中场战事」这样捉住某一件事件具体阐述的作品不多。如果一件事情你用大多的事例来反映，反而会弄巧成拙。</p><p>一些反转也是比较有力的，比如一开始的盛赞，到后来演员、观众以及工作人员的讽刺嘲弄（一开始我以为那个拉拉队的也是走肾不走心的绿茶婊），这些无疑对比利的内心又进一步刻画（关于老兵回国后的窘迫作品也有很多，最著名的应该就是「第一滴血」了）。</p><p>当然这部电影剧情也是有漏洞的。</p><p>很多地方的闪回片段剪辑并不妥当，这个是个硬伤，非常影响电影剧情。（我个人认为比较成功的闪回剧情电影是「贫民窟的百万富翁」）</p><p>一些人物对话对剧情推动不足，比如范·迪塞尔饰演的Shroom在某些地方无缘无故猛灌鸡汤真的是有毒。</p><p>至于一些国外的影评觉得这部电影没有触及到他们的G点，我觉得是安叔给美国人留了个面子，不敢把美国人讽刺得太厉害：我拍你们美国本土故事拍这么好，那你们拍什么呢？（B班成员的设置也是有少数裔的）</p><p>最后，诚挚推荐李安导演的新片「比利林恩的中场战事」，南京万达影城太阳城店的是3D、120帧、2K的（真的是4K的，不过这个影响不是很大），双十一没有剁手的朋友可以尝试一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前听说北美口碑扑街了，所以看之前也没有抱太大期望。然而观影结果却出人意料地好，就单从饱受争议的剧情方面来说，这也不乏是一部大作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="简评" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/"/>
    
      <category term="2016" scheme="http://yoursite.com/categories/%E7%AE%80%E8%AF%84/2016/"/>
    
    
      <category term="剧情" scheme="http://yoursite.com/tags/%E5%89%A7%E6%83%85/"/>
    
      <category term="简评" scheme="http://yoursite.com/tags/%E7%AE%80%E8%AF%84/"/>
    
      <category term="战争" scheme="http://yoursite.com/tags/%E6%88%98%E4%BA%89/"/>
    
  </entry>
  
</feed>
